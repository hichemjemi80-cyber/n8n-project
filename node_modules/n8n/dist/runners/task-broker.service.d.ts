import { Logger } from '../logging/logger.service';
import { TaskRejectError } from './errors';
import type { N8nMessage, RunnerMessage, RequesterMessage, TaskResultData } from './runner-types';
export interface TaskRunner {
    id: string;
    name?: string;
    taskTypes: string[];
    lastSeen: Date;
}
export interface Task {
    id: string;
    runnerId: TaskRunner['id'];
    requesterId: string;
    taskType: string;
}
export interface TaskOffer {
    offerId: string;
    runnerId: TaskRunner['id'];
    taskType: string;
    validFor: number;
    validUntil: bigint;
}
export interface TaskRequest {
    requestId: string;
    requesterId: string;
    taskType: string;
    acceptInProgress?: boolean;
}
export type MessageCallback = (message: N8nMessage.ToRunner.All) => Promise<void> | void;
export type RequesterMessageCallback = (message: N8nMessage.ToRequester.All) => Promise<void> | void;
type RunnerAcceptCallback = () => void;
type TaskRejectCallback = (reason: TaskRejectError) => void;
export declare class TaskBroker {
    private readonly logger;
    private knownRunners;
    private requesters;
    private tasks;
    private runnerAcceptRejects;
    private requesterAcceptRejects;
    private pendingTaskOffers;
    private pendingTaskRequests;
    constructor(logger: Logger);
    expireTasks(): void;
    registerRunner(runner: TaskRunner, messageCallback: MessageCallback): void;
    deregisterRunner(runnerId: string): void;
    registerRequester(requesterId: string, messageCallback: RequesterMessageCallback): void;
    deregisterRequester(requesterId: string): void;
    private messageRunner;
    private messageRequester;
    onRunnerMessage(runnerId: TaskRunner['id'], message: RunnerMessage.ToN8n.All): Promise<void>;
    handleRpcRequest(taskId: Task['id'], callId: string, name: RunnerMessage.ToN8n.RPC['name'], params: unknown[]): Promise<void>;
    handleRunnerAccept(taskId: Task['id']): void;
    handleRunnerReject(taskId: Task['id'], reason: string): void;
    handleDataRequest(taskId: Task['id'], requestId: RunnerMessage.ToN8n.TaskDataRequest['requestId'], requestType: RunnerMessage.ToN8n.TaskDataRequest['requestType'], param?: string): Promise<void>;
    handleResponse(taskId: Task['id'], requestId: RunnerMessage.ToN8n.TaskDataRequest['requestId'], data: unknown): Promise<void>;
    onRequesterMessage(requesterId: string, message: RequesterMessage.ToN8n.All): Promise<void>;
    handleRequesterRpcResponse(taskId: string, callId: string, status: RequesterMessage.ToN8n.RPCResponse['status'], data: unknown): Promise<void>;
    handleRequesterDataResponse(taskId: Task['id'], requestId: string, data: unknown): Promise<void>;
    handleRequesterAccept(taskId: Task['id'], settings: RequesterMessage.ToN8n.TaskSettings['settings']): void;
    handleRequesterReject(taskId: Task['id'], reason: string): void;
    private cancelTask;
    private failTask;
    private getRunnerOrFailTask;
    sendTaskSettings(taskId: Task['id'], settings: unknown): Promise<void>;
    taskDoneHandler(taskId: Task['id'], data: TaskResultData): Promise<void>;
    taskErrorHandler(taskId: Task['id'], error: unknown): Promise<void>;
    acceptOffer(offer: TaskOffer, request: TaskRequest): Promise<void>;
    settleTasks(): void;
    taskRequested(request: TaskRequest): void;
    taskOffered(offer: TaskOffer): void;
    getTasks(): Map<string, Task>;
    getPendingTaskOffers(): TaskOffer[];
    getPendingTaskRequests(): TaskRequest[];
    getKnownRunners(): Map<string, {
        runner: TaskRunner;
        messageCallback: MessageCallback;
    }>;
    getKnownRequesters(): Map<string, RequesterMessageCallback>;
    getRunnerAcceptRejects(): Map<string, {
        accept: RunnerAcceptCallback;
        reject: TaskRejectCallback;
    }>;
    setTasks(tasks: Record<string, Task>): void;
    setPendingTaskOffers(pendingTaskOffers: TaskOffer[]): void;
    setPendingTaskRequests(pendingTaskRequests: TaskRequest[]): void;
    setRunnerAcceptRejects(runnerAcceptRejects: Record<string, {
        accept: RunnerAcceptCallback;
        reject: TaskRejectCallback;
    }>): void;
}
export {};
