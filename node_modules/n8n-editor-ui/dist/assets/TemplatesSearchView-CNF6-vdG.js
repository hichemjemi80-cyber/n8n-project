import { a as __unplugin_components_0$1, _ as __unplugin_components_2 } from "./TemplateList-DqeiM-sc.js";
import { i1 as baseOrderBy, i2 as isArray, d as defineComponent, c as openBlock, e as createBlock, aE as createSlots, w as withCtx, j as createBaseVNode, n as normalizeClass, t as toDisplayString, q as renderSlot, i as createVNode, bP as mergeProps, l as resolveComponent, _ as _export_sfc, as as withDirectives, at as vShow, k as createTextVNode, B as normalizeStyle, i3 as throttle, h as createElementBlock, f as createCommentVNode, F as Fragment, z as renderList, r as ref, H as watch, o as onMounted, C as nextTick, ar as onBeforeMount, A as unref, e0 as mapStores, aC as useTemplatesStore, J as useDebounce, a as useToast, a3 as useDocumentTitle, i4 as CREATOR_HUB_URL, gW as usePostHog, u as useUsersStore, K as useUIStore, m as useSettingsStore, V as VIEWS, c9 as resolveDirective } from "./index-TQ22MZub.js";
import { T as TemplatesView } from "./TemplatesView-2elduxzA.js";
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = orders;
  if (!isArray(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return baseOrderBy(collection, iteratees, orders);
}
const _hoisted_1$3 = ["textContent"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "CollectionWorkflowCard",
  props: {
    loading: { type: Boolean },
    title: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_n8n_loading = resolveComponent("n8n-loading");
      const _component_n8n_card = resolveComponent("n8n-card");
      return openBlock(), createBlock(_component_n8n_card, mergeProps({
        class: _ctx.$style.card
      }, _ctx.$attrs), createSlots({
        default: withCtx(() => [
          createVNode(_component_n8n_loading, {
            loading: _ctx.loading,
            rows: 3,
            variant: "p"
          }, null, 8, ["loading"])
        ]),
        _: 2
      }, [
        !_ctx.loading && _ctx.title ? {
          name: "header",
          fn: withCtx(() => [
            createBaseVNode("span", {
              class: normalizeClass(_ctx.$style.title),
              textContent: toDisplayString(_ctx.title)
            }, null, 10, _hoisted_1$3)
          ]),
          key: "0"
        } : void 0,
        !_ctx.loading ? {
          name: "footer",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "footer")
          ]),
          key: "1"
        } : void 0
      ]), 1040, ["class"]);
    };
  }
});
const card = "_card_17xq8_1";
const title$1 = "_title_17xq8_17";
const style0$3 = {
  card,
  title: title$1
};
const cssModules$3 = {
  "$style": style0$3
};
const Card = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__cssModules", cssModules$3]]);
const _sfc_main$4 = defineComponent({
  name: "TemplatesInfoCard",
  components: {
    Card,
    NodeList: __unplugin_components_0$1
  },
  props: {
    collection: {
      type: Object,
      required: true
    },
    loading: {
      type: Boolean
    },
    showItemCount: {
      type: Boolean,
      default: true
    },
    width: {
      type: String,
      required: true
    }
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_n8n_text = resolveComponent("n8n-text");
  const _component_NodeList = __unplugin_components_0$1;
  const _component_Card = resolveComponent("Card");
  return openBlock(), createBlock(_component_Card, {
    loading: _ctx.loading,
    title: _ctx.collection.name,
    style: normalizeStyle({ width: _ctx.width })
  }, {
    footer: withCtx(() => [
      createBaseVNode("span", null, [
        withDirectives(createVNode(_component_n8n_text, {
          size: "small",
          color: "text-light"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.collection.workflows.length) + " " + toDisplayString(_ctx.$locale.baseText("templates.workflows")), 1)
          ]),
          _: 1
        }, 512), [
          [vShow, _ctx.showItemCount]
        ])
      ]),
      createVNode(_component_NodeList, {
        nodes: _ctx.collection.nodes,
        "show-more": false
      }, null, 8, ["nodes"])
    ]),
    _: 1
  }, 8, ["loading", "title", "style"]);
}
const TemplatesInfoCard = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$3]]);
const mixin$6 = {
  methods: {
    handleMouseDown(e) {
      this.isMouseDown = true;
      if (e.type.indexOf("touch") !== -1) {
        this.dragStartX = e.touches[0].clientX;
        this.dragStartY = e.touches[0].clientY;
      }
      if (e.type.indexOf("mouse") !== -1) {
        this.dragStartX = e.clientX;
        this.dragStartY = e.clientY;
      }
    },
    handleMouseMove(e) {
      let positionX;
      let positionY;
      if (e.type.indexOf("touch") !== -1) {
        positionX = e.touches[0].clientX;
        positionY = e.touches[0].clientY;
      }
      if (e.type.indexOf("mouse") !== -1) {
        positionX = e.clientX;
        positionY = e.clientY;
      }
      const dragDistanceX = Math.abs(positionX - this.dragStartX);
      const dragDistanceY = Math.abs(positionY - this.dragStartY);
      if (dragDistanceX > 3 * dragDistanceY) {
        this.disableScroll();
        this.dragDistance = positionX - this.dragStartX;
      }
    },
    handleMouseUp() {
      this.isMouseDown = false;
      this.enableScroll();
    },
    handleMouseOver(element) {
      if (this.settings.autoplay) {
        if (element === "dot" && this.settings.pauseOnDotsHover || element === "track" && this.settings.pauseOnHover) {
          this.isAutoplayPaused = true;
        }
      }
    },
    handleMouseOut(element) {
      if (this.settings.autoplay) {
        if (element === "dot" && this.settings.pauseOnDotsHover || element === "track" && this.settings.pauseOnHover) {
          this.isAutoplayPaused = false;
        }
      }
    }
  }
};
const mixin$5 = {
  methods: {
    /**
     * Set window & container width
     */
    getWidth() {
      if (this.isSSR) {
        return false;
      }
      this.widthWindow = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      this.widthContainer = this.$refs.list.clientWidth;
    },
    /**
     * Convert HTML Collection to JS Array
     */
    htmlCollectionToArray(collection) {
      return Array.prototype.slice.call(collection, 0);
    }
  }
};
const mixin$4 = {
  methods: {
    clearAutoPlayPause() {
      clearTimeout(this.autoplayTimeout);
      this.autoplayRemaining = null;
    },
    disableAutoPlay() {
      clearInterval(this.autoplayInterval);
      this.autoplayInterval = null;
    },
    disableScroll() {
      document.ontouchmove = (e) => e.preventDefault();
    },
    enableScroll() {
      document.ontouchmove = () => true;
    },
    restartAutoPlay() {
      this.disableAutoPlay();
      this.toggleAutoPlay();
    },
    toggleAutoPlay() {
      const enabled = !this.settings.unagile && this.settings.autoplay;
      if (!this.autoplayInterval && enabled) {
        this.autoplayInterval = setInterval(() => {
          if (!document.hidden) {
            if (!this.canGoToNext) {
              this.disableAutoPlay();
            } else {
              this.goToNext();
            }
          }
        }, this.settings.autoplaySpeed);
      } else {
        this.disableAutoPlay();
      }
    },
    toggleFade() {
      const enabled = !this.settings.unagile && this.settings.fade;
      for (let i = 0; i < this.countSlides; i++) {
        this.slides[i].style.transition = enabled ? "opacity " + this.settings.timing + " " + this.settings.speed + "ms" : "none";
        this.slides[i].style.transform = enabled ? `translate(-${i * this.widthSlide}px)` : "none";
      }
    }
  }
};
const mixin$3 = {
  methods: {
    /**
     * Prepare slides classes and styles
     */
    prepareSlides() {
      this.slides = this.htmlCollectionToArray(this.$refs.slides.children);
      if (this.slidesCloned) {
        this.slidesClonedBefore = this.htmlCollectionToArray(this.$refs.slidesClonedBefore.children);
        this.slidesClonedAfter = this.htmlCollectionToArray(this.$refs.slidesClonedAfter.children);
      }
      for (const slide of this.slidesAll) {
        slide.classList.add("agile__slide");
      }
    },
    /**
     *  Prepare slides active/current classes
     */
    prepareSlidesClasses() {
      if (this.currentSlide === null) {
        return false;
      }
      for (let i = 0; i < this.countSlides; i++) {
        this.slides[i].classList.remove("agile__slide--active");
        this.slides[i].classList.remove("agile__slide--current");
      }
      setTimeout(() => this.slides[this.currentSlide].classList.add("agile__slide--active"), this.changeDelay);
      let start = this.slidesCloned ? this.countSlides + this.currentSlide : this.currentSlide;
      if (this.centerMode) {
        start -= Math.floor(this.settings.slidesToShow / 2) - +(this.settings.slidesToShow % 2 === 0);
      }
      for (let i = Math.max(start, 0); i < Math.min(start + this.settings.slidesToShow, this.countSlides); i++) {
        this.slidesAll[i].classList.add("agile__slide--current");
      }
    },
    /**
     * Prepare carousel styles
     */
    prepareCarousel() {
      if (this.settings.unagile) {
        this.translateX = 0;
      } else {
        if (this.currentSlide === null && this.countSlides) {
          this.currentSlide = this.settings.initialSlide;
        }
        if (this.currentSlide > this.countSlides) {
          this.currentSlide = this.countSlides - 1;
        }
        this.goTo(this.currentSlide, false, false);
      }
    }
  }
};
const mixin$2 = {
  props: {
    /**
     * Set the carousel to be the navigation of other carousels
     */
    asNavFor: {
      type: Array,
      default: function() {
        return [];
      }
    },
    /**
     * Enable autoplay
     */
    autoplay: {
      type: Boolean,
      default: false
    },
    /**
     * Autoplay interval in milliseconds
     */
    autoplaySpeed: {
      type: Number,
      default: 3e3
    },
    /**
     * Enable centered view when slidesToShow > 1
     */
    centerMode: {
      type: Boolean,
      default: false
    },
    /**
     * Slides padding in center mode
     */
    centerPadding: {
      type: String,
      default: "15%"
    },
    /**
     * Slide change delay in milliseconds
     */
    changeDelay: {
      type: Number,
      default: 0
    },
    /**
     * Enable dot indicators/pagination
     */
    dots: {
      type: Boolean,
      default: true
    },
    /**
     * Enable fade effect
     */
    fade: {
      type: Boolean,
      default: false
    },
    /**
     * Infinite loop sliding
     */
    infinite: {
      type: Boolean,
      default: true
    },
    /**
     * Index of slide to start on
     */
    initialSlide: {
      type: Number,
      default: 0
    },
    /**
     * Enable mobile first calculation for responsive settings
     */
    mobileFirst: {
      type: Boolean,
      default: true
    },
    /**
     * Enable prev/next navigation buttons
     */
    navButtons: {
      type: Boolean,
      default: true
    },
    /**
     * All settings as one object
     */
    options: {
      type: Object,
      default: () => null
    },
    /**
     * Pause autoplay when a dot is hovered
     */
    pauseOnDotsHover: {
      type: Boolean,
      default: false
    },
    /**
     * Pause autoplay when a slide is hovered
     */
    pauseOnHover: {
      type: Boolean,
      default: true
    },
    /**
     * Object containing breakpoints and settings objects
     */
    responsive: {
      type: Array,
      default: () => null
    },
    /**
     * Enable right-to-left mode
     */
    rtl: {
      type: Boolean,
      default: false
    },
    /**
     * Number of slides to scroll
     */
    slidesToScroll: {
      type: Number,
      default: 1
    },
    /**
     * Number of slides to show
     */
    slidesToShow: {
      type: Number,
      default: 1
    },
    /**
     * Slide animation speed in milliseconds
     */
    speed: {
      type: Number,
      default: 300
    },
    /**
     * Swipe distance
     */
    swipeDistance: {
      type: Number,
      default: 50
    },
    /**
     * Throttle delay in milliseconds
     */
    throttleDelay: {
      type: Number,
      default: 500
    },
    /**
     * Transition timing function
     * Available: ease, linear, ease-in, ease-out, ease-in-out
     */
    timing: {
      type: String,
      default: "ease",
      validator: (value) => {
        return ["ease", "linear", "ease-in", "ease-out", "ease-in-out"].indexOf(value) !== -1;
      }
    },
    /**
     * Disable Agile carousel
     */
    unagile: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    // Initial settings based on props and options object
    initialSettings: function() {
      let { options, ...initialSettings } = this.$props;
      if (options) {
        initialSettings = { ...initialSettings, ...options };
      }
      if (initialSettings.responsive) {
        initialSettings.responsive = orderBy(initialSettings.responsive, "breakpoint");
      }
      return initialSettings;
    },
    // Settings for current breakpoint
    settings: function() {
      const { responsive, ...settings } = this.initialSettings;
      if (responsive) {
        responsive.forEach((option) => {
          if (settings.mobileFirst ? option.breakpoint < this.widthWindow : option.breakpoint > this.widthWindow) {
            for (const key in option.settings) {
              settings[key] = option.settings[key];
            }
          }
        });
      }
      return settings;
    }
  }
};
const mixin$1 = {
  created() {
    this.goTo = throttle(this.goTo, this.throttleDelay);
    this.getWidth = throttle(this.getWidth, 500);
  }
};
const mixin = {
  watch: {
    // Recalculate settings
    currentBreakpoint() {
      this.$emit("breakpoint", { breakpoint: this.currentBreakpoint });
    },
    // Watch current slide change
    currentSlide() {
      this.prepareSlidesClasses();
      this.autoplayStartTimestamp = this.settings.autoplay ? +/* @__PURE__ */ new Date() : null;
      this.$emit("after-change", { currentSlide: this.currentSlide });
    },
    // Watch drag distance change
    dragDistance() {
      if (this.isMouseDown) {
        const { rtl } = this.settings;
        const dragDistance = this.dragDistance * (rtl ? -1 : 1);
        if (dragDistance > this.swipeDistance && this.canGoToPrev) {
          this.goToPrev();
          this.handleMouseUp();
        }
        if (dragDistance < -1 * this.swipeDistance && this.canGoToNext) {
          this.goToNext();
          this.handleMouseUp();
        }
      }
    },
    isAutoplayPaused(nevValue) {
      if (nevValue) {
        this.remaining = this.settings.autoplaySpeed - (+/* @__PURE__ */ new Date() - this.autoplayStartTimestamp);
        this.disableAutoPlay();
        this.clearAutoPlayPause();
      } else {
        this.autoplayTimeout = setTimeout(() => {
          this.clearAutoPlayPause();
          this.goToNext();
          this.toggleAutoPlay();
        }, this.remaining);
      }
    },
    "settings.autoplay"() {
      this.toggleAutoPlay();
    },
    "settings.fade"() {
      this.toggleFade();
    },
    "settings.unagile"() {
    },
    widthSlide() {
      for (let i = 0; i < this.countSlidesAll; i++) {
        this.slidesAll[i].style.width = `${this.widthSlide}${this.widthSlide !== "auto" ? "px" : ""}`;
      }
    },
    // Watch window width change
    widthWindow(newValue, oldValue) {
      if (oldValue) {
        this.prepareCarousel();
        this.toggleFade();
      }
    }
  }
};
const _sfc_main$3 = {
  name: "agile",
  mixins: [mixin$6, mixin$5, mixin$4, mixin$3, mixin$2, mixin$1, mixin],
  emits: ["before-change", "after-change", "breakpoint"],
  data() {
    return {
      autoplayInterval: null,
      autoplayRemaining: null,
      autoplayStartTimestamp: null,
      autoplayTimeout: null,
      currentSlide: null,
      dragDistance: 0,
      dragStartX: 0,
      dragStartY: 0,
      isAutoplayPaused: false,
      isMouseDown: false,
      slides: [],
      slidesClonedAfter: [],
      slidesClonedBefore: [],
      isSSR: typeof window === "undefined",
      transitionDelay: 0,
      translateX: 0,
      widthWindow: 0,
      widthContainer: 0
    };
  },
  computed: {
    breakpoints: function() {
      return !this.initialSettings.responsive ? [] : this.initialSettings.responsive.map((item2) => item2.breakpoint);
    },
    canGoToPrev: function() {
      return this.settings.infinite || this.currentSlide > 0;
    },
    canGoToNext: function() {
      return this.settings.infinite || this.currentSlide < this.countSlides - 1;
    },
    countSlides: function() {
      return this.isSSR ? this.htmlCollectionToArray(this.$slots.default).length : this.slides.length;
    },
    countSlidesAll: function() {
      return this.slidesAll.length;
    },
    currentBreakpoint: function() {
      const breakpoints = this.breakpoints.map((item2) => item2).reverse();
      return this.initialSettings.mobileFirst ? breakpoints.find((item2) => item2 < this.widthWindow) || 0 : breakpoints.find((item2) => item2 > this.widthWindow) || null;
    },
    marginX: function() {
      if (this.settings.unagile) {
        return 0;
      }
      let marginX = this.slidesCloned ? this.countSlides * this.widthSlide : 0;
      if (this.settings.centerMode) {
        marginX -= (Math.floor(this.settings.slidesToShow / 2) - +(this.settings.slidesToShow % 2 === 0)) * this.widthSlide;
      }
      return this.settings.rtl ? marginX : -1 * marginX;
    },
    slidesCloned: function() {
      return !this.settings.unagile && !this.settings.fade && this.settings.infinite;
    },
    slidesAll: function() {
      return this.slidesCloned ? [...this.slidesClonedBefore, ...this.slides, ...this.slidesClonedAfter] : this.slides;
    },
    widthSlide: function() {
      return !this.settings.unagile ? this.widthContainer / this.settings.slidesToShow : "auto";
    }
  },
  mounted() {
    window.addEventListener("resize", this.getWidth);
    this.$refs.track.addEventListener("touchstart", this.handleMouseDown);
    this.$refs.track.addEventListener("touchend", this.handleMouseUp);
    this.$refs.track.addEventListener("touchmove", this.handleMouseMove);
    this.$refs.track.addEventListener("mousedown", this.handleMouseDown);
    this.$refs.track.addEventListener("mouseup", this.handleMouseUp);
    this.$refs.track.addEventListener("mousemove", this.handleMouseMove);
    this.isSSR = false;
    this.reload();
  },
  // Vue 3
  beforeUnmount() {
    this.destroy();
  },
  methods: {
    destroy() {
      window.removeEventListener("resize", this.getWidth);
      this.$refs.track.removeEventListener("touchstart", this.handleMouseDown);
      this.$refs.track.removeEventListener("touchend", this.handleMouseUp);
      this.$refs.track.removeEventListener("touchmove", this.handleMouseMove);
      this.$refs.track.removeEventListener("mousedown", this.handleMouseDown);
      this.$refs.track.removeEventListener("mouseup", this.handleMouseUp);
      this.$refs.track.removeEventListener("mousemove", this.handleMouseMove);
      this.disableAutoPlay();
    },
    // Return current breakpoint
    getCurrentBreakpoint() {
      return this.currentBreakpoint;
    },
    // Return settings for current breakpoint
    getCurrentSettings() {
      return this.settings;
    },
    // Return current slide index
    getCurrentSlide() {
      return this.currentSlide;
    },
    // Return initial settings
    getInitialSettings() {
      return this.initialSettings;
    },
    // Go to slide
    goTo(n, transition = true, asNav = false) {
      if (this.settings.unagile) {
        return false;
      }
      if (!asNav) {
        this.settings.asNavFor.forEach((carousel) => {
          if (carousel) {
            carousel.goTo(n, transition, true);
          }
        });
      }
      let slideNextReal = n;
      if (transition) {
        if (this.settings.infinite && n < 0) {
          slideNextReal = this.countSlides - 1;
        } else if (n >= this.countSlides) {
          slideNextReal = 0;
        }
        this.$emit("before-change", { currentSlide: this.currentSlide, nextSlide: slideNextReal });
        this.currentSlide = slideNextReal;
        if (n !== slideNextReal) {
          setTimeout(() => {
            this.goTo(slideNextReal, false);
          }, this.settings.speed);
        }
      }
      const translateX = !this.settings.fade ? n * this.widthSlide * this.settings.slidesToScroll : 0;
      this.transitionDelay = transition ? this.speed : 0;
      if (this.infinite || this.currentSlide + this.slidesToShow <= this.countSlides) {
        this.translateX = this.settings.rtl ? translateX : -1 * translateX;
      }
    },
    // Go to next slide
    goToNext() {
      if (this.canGoToNext) {
        this.goTo(this.currentSlide + 1);
      }
    },
    // Go to previous slide
    goToPrev() {
      if (this.canGoToPrev) {
        this.goTo(this.currentSlide - 1);
      }
    },
    // Reload carousel
    reload() {
      this.getWidth();
      this.prepareSlides();
      this.prepareCarousel();
      this.toggleFade();
      this.toggleAutoPlay();
    }
  }
};
const _hoisted_1$2 = {
  ref: "list",
  class: "agile__list"
};
const _hoisted_2$1 = {
  ref: "slidesClonedBefore",
  class: "agile__slides agile__slides--cloned"
};
const _hoisted_3 = {
  ref: "slides",
  class: "agile__slides agile__slides--regular"
};
const _hoisted_4 = {
  ref: "slidesClonedAfter",
  class: "agile__slides agile__slides--cloned"
};
const _hoisted_5 = {
  key: 0,
  class: "agile__caption"
};
const _hoisted_6 = {
  key: 1,
  class: "agile__actions"
};
const _hoisted_7 = ["disabled"];
const _hoisted_8 = {
  key: 1,
  ref: "dots",
  class: "agile__dots"
};
const _hoisted_9 = ["onClick"];
const _hoisted_10 = ["disabled"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([{ "agile--ssr": $data.isSSR, "agile--auto-play": _ctx.settings.autoplay, "agile--disabled": _ctx.settings.unagile, "agile--fade": _ctx.settings.fade && !_ctx.settings.unagile, "agile--rtl": _ctx.settings.rtl, "agile--no-nav-buttons": !_ctx.settings.navButtons }, "agile"]),
    onTouchstart: () => {
    }
  }, [
    createBaseVNode("div", _hoisted_1$2, [
      createBaseVNode("div", {
        ref: "track",
        style: normalizeStyle({ transform: `translate(${$data.translateX + $options.marginX}px)`, transition: `transform ${_ctx.settings.timing} ${$data.transitionDelay}ms` }),
        class: "agile__track",
        onMouseout: _cache[0] || (_cache[0] = ($event) => _ctx.handleMouseOut("track")),
        onMouseover: _cache[1] || (_cache[1] = ($event) => _ctx.handleMouseOver("track"))
      }, [
        withDirectives(createBaseVNode("div", _hoisted_2$1, [
          renderSlot(_ctx.$slots, "default")
        ], 512), [
          [vShow, $options.slidesCloned]
        ]),
        createBaseVNode("div", _hoisted_3, [
          renderSlot(_ctx.$slots, "default")
        ], 512),
        withDirectives(createBaseVNode("div", _hoisted_4, [
          renderSlot(_ctx.$slots, "default")
        ], 512), [
          [vShow, $options.slidesCloned]
        ])
      ], 36)
    ], 512),
    _ctx.$slots.caption ? (openBlock(), createElementBlock("div", _hoisted_5, [
      renderSlot(_ctx.$slots, "caption")
    ])) : createCommentVNode("", true),
    !_ctx.settings.unagile && (_ctx.settings.navButtons || _ctx.settings.dots) ? (openBlock(), createElementBlock("div", _hoisted_6, [
      _ctx.settings.navButtons && !_ctx.settings.unagile ? (openBlock(), createElementBlock("button", {
        key: 0,
        ref: "prevButton",
        disabled: !$options.canGoToPrev,
        "aria-label": "Previous",
        class: "agile__nav-button agile__nav-button--prev",
        type: "button",
        onClick: _cache[2] || (_cache[2] = ($event) => ($options.goToPrev(), _ctx.restartAutoPlay()))
      }, [
        renderSlot(_ctx.$slots, "prevButton", {}, () => [
          _cache[6] || (_cache[6] = createTextVNode(" ← "))
        ])
      ], 8, _hoisted_7)) : createCommentVNode("", true),
      _ctx.settings.dots && !_ctx.settings.unagile ? (openBlock(), createElementBlock("ul", _hoisted_8, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($options.countSlides, (n) => {
          return openBlock(), createElementBlock("li", {
            key: n,
            class: normalizeClass([{ "agile__dot--current": n - 1 === $data.currentSlide }, "agile__dot"]),
            onMouseout: _cache[3] || (_cache[3] = ($event) => _ctx.handleMouseOut("dot")),
            onMouseover: _cache[4] || (_cache[4] = ($event) => _ctx.handleMouseOver("dot"))
          }, [
            createBaseVNode("button", {
              type: "button",
              onClick: ($event) => ($options.goTo(n - 1), _ctx.restartAutoPlay())
            }, toDisplayString(n), 9, _hoisted_9)
          ], 34);
        }), 128))
      ], 512)) : createCommentVNode("", true),
      _ctx.settings.navButtons && !_ctx.settings.unagile ? (openBlock(), createElementBlock("button", {
        key: 2,
        ref: "nextButton",
        disabled: !$options.canGoToNext,
        "aria-label": "Next",
        class: "agile__nav-button agile__nav-button--next",
        type: "button",
        onClick: _cache[5] || (_cache[5] = ($event) => ($options.goToNext(), _ctx.restartAutoPlay()))
      }, [
        renderSlot(_ctx.$slots, "nextButton", {}, () => [
          _cache[7] || (_cache[7] = createTextVNode(" → "))
        ])
      ], 8, _hoisted_10)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true)
  ], 34);
}
const VueAgile = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$2]]);
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "TemplatesInfoCarousel",
  props: {
    collections: {},
    loading: { type: Boolean, default: false },
    showItemCount: { type: Boolean, default: true },
    showNavigation: { type: Boolean, default: true },
    cardsWidth: { default: "240px" }
  },
  emits: ["openCollection"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const carouselScrollPosition = ref(0);
    const cardWidth = ref(parseInt(props.cardsWidth, 10));
    const scrollEnd = ref(false);
    const listElement = ref(null);
    const sliderRef = ref(null);
    const updateCarouselScroll = () => {
      if (listElement.value) {
        carouselScrollPosition.value = Number(listElement.value.scrollLeft.toFixed());
        const width = listElement.value.clientWidth;
        const scrollWidth = listElement.value.scrollWidth;
        const scrollLeft2 = carouselScrollPosition.value;
        scrollEnd.value = scrollWidth - width <= scrollLeft2 + 7;
      }
    };
    const onCardClick = (event, id) => {
      emit("openCollection", { event, id });
    };
    const scrollLeft = () => {
      if (listElement.value) {
        listElement.value.scrollBy({ left: -(cardWidth.value * 2), top: 0, behavior: "smooth" });
      }
    };
    const scrollRight = () => {
      if (listElement.value) {
        listElement.value.scrollBy({ left: cardWidth.value * 2, top: 0, behavior: "smooth" });
      }
    };
    watch(
      () => props.collections,
      () => {
        setTimeout(() => {
          updateCarouselScroll();
        }, 0);
      }
    );
    watch(
      () => props.loading,
      () => {
        setTimeout(() => {
          updateCarouselScroll();
        }, 0);
      }
    );
    onMounted(async () => {
      await nextTick();
      if (!sliderRef.value) {
        return;
      }
      listElement.value = sliderRef.value.$el.querySelector(".agile__list");
      if (listElement.value) {
        listElement.value.addEventListener("scroll", updateCarouselScroll);
      }
    });
    onBeforeMount(() => {
      if (sliderRef.value) {
        sliderRef.value.destroy();
      }
      window.addEventListener("scroll", updateCarouselScroll);
    });
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      return withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.container)
      }, [
        createVNode(unref(VueAgile), {
          ref_key: "sliderRef",
          ref: sliderRef,
          dots: false,
          "nav-buttons": false,
          infinite: false,
          "slides-to-show": 4,
          onAfterChange: updateCarouselScroll
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.loading ? 4 : 0, (n) => {
              return openBlock(), createBlock(Card, {
                key: `loading-${n}`,
                loading: _ctx.loading
              }, null, 8, ["loading"]);
            }), 128)),
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.loading ? [] : _ctx.collections, (collection) => {
              return openBlock(), createBlock(TemplatesInfoCard, {
                key: collection.id,
                "data-test-id": "templates-info-card",
                collection,
                "show-item-count": _ctx.showItemCount,
                width: _ctx.cardsWidth,
                onClick: (e) => onCardClick(e, collection.id)
              }, null, 8, ["collection", "show-item-count", "width", "onClick"]);
            }), 128))
          ]),
          _: 1
        }, 512),
        withDirectives(createBaseVNode("button", {
          class: normalizeClass({ [_ctx.$style.leftButton]: true }),
          onClick: scrollLeft
        }, [
          createVNode(_component_font_awesome_icon, { icon: "chevron-left" })
        ], 2), [
          [vShow, _ctx.showNavigation && carouselScrollPosition.value > 0]
        ]),
        withDirectives(createBaseVNode("button", {
          class: normalizeClass({ [_ctx.$style.rightButton]: true }),
          onClick: scrollRight
        }, [
          createVNode(_component_font_awesome_icon, { icon: "chevron-right" })
        ], 2), [
          [vShow, _ctx.showNavigation && !scrollEnd.value]
        ])
      ], 2)), [
        [vShow, _ctx.loading || _ctx.collections.length]
      ]);
    };
  }
});
const container = "_container_1lokv_1";
const button$1 = "_button_1lokv_5";
const leftButton = "_leftButton_1lokv_26 _button_1lokv_5";
const rightButton = "_rightButton_1lokv_35 _button_1lokv_5";
const style0$2 = {
  container,
  button: button$1,
  leftButton,
  rightButton
};
const cssModules$2 = {
  "$style": style0$2
};
const __unplugin_components_1 = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__cssModules", cssModules$2]]);
const _sfc_main$1 = defineComponent({
  name: "TemplateFilters",
  props: {
    categories: {
      type: Array,
      default: () => []
    },
    sortOnPopulate: {
      type: Boolean,
      default: false
    },
    expandLimit: {
      type: Number,
      default: 12
    },
    loading: {
      type: Boolean
    },
    selected: {
      type: Array,
      default: () => []
    }
  },
  emits: ["clearAll", "select", "clear"],
  data() {
    return {
      collapsed: true,
      sortedCategories: []
    };
  },
  computed: {
    ...mapStores(useTemplatesStore),
    allSelected() {
      return this.selected.length === 0;
    }
  },
  watch: {
    sortOnPopulate: {
      handler(value) {
        if (value) {
          this.sortCategories();
        }
      },
      immediate: true
    },
    categories: {
      handler(categories2) {
        if (categories2.length > 0) {
          this.sortCategories();
        }
      },
      immediate: true
    }
  },
  methods: {
    sortCategories() {
      if (!this.sortOnPopulate) {
        this.sortedCategories = this.categories;
      } else {
        const selected = this.selected || [];
        const selectedCategories = this.categories.filter((cat) => selected.includes(cat));
        const notSelectedCategories = this.categories.filter((cat) => !selected.includes(cat));
        this.sortedCategories = selectedCategories.concat(notSelectedCategories);
      }
    },
    collapseAction() {
      this.collapsed = false;
    },
    handleCheckboxChanged(value, selectedCategory) {
      this.$emit(value ? "select" : "clear", selectedCategory);
    },
    isSelected(category) {
      return this.selected.includes(category);
    },
    resetCategories() {
      this.$emit("clearAll");
    }
  }
});
const title = "_title_1sb10_1";
const categories = "_categories_1sb10_6";
const item = "_item_1sb10_11";
const button = "_button_1sb10_18";
const style0$1 = {
  title,
  categories,
  item,
  button
};
const _hoisted_1$1 = ["textContent"];
const _hoisted_2 = ["data-test-id"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_n8n_loading = resolveComponent("n8n-loading");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_n8n_text = resolveComponent("n8n-text");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.$style.filters, "template-filters"]),
    "data-test-id": "templates-filter-container"
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.$style.title),
      textContent: toDisplayString(_ctx.$locale.baseText("templates.categoriesHeading"))
    }, null, 10, _hoisted_1$1),
    _ctx.loading ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.$style.list)
    }, [
      createVNode(_component_n8n_loading, {
        loading: _ctx.loading,
        rows: _ctx.expandLimit
      }, null, 8, ["loading", "rows"])
    ], 2)) : createCommentVNode("", true),
    !_ctx.loading ? (openBlock(), createElementBlock("ul", {
      key: 1,
      class: normalizeClass(_ctx.$style.categories)
    }, [
      createBaseVNode("li", {
        class: normalizeClass(_ctx.$style.item),
        "data-test-id": "template-filter-all-categories"
      }, [
        createVNode(_component_el_checkbox, {
          "model-value": _ctx.allSelected,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = () => _ctx.resetCategories())
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("templates.allCategories")), 1)
          ]),
          _: 1
        }, 8, ["model-value"])
      ], 2),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.collapsed ? _ctx.sortedCategories.slice(0, _ctx.expandLimit) : _ctx.sortedCategories, (category, index) => {
        return openBlock(), createElementBlock("li", {
          key: index,
          class: normalizeClass(_ctx.$style.item),
          "data-test-id": `template-filter-${category.name.toLowerCase().replaceAll(" ", "-")}`
        }, [
          createVNode(_component_el_checkbox, {
            "model-value": _ctx.isSelected(category),
            "onUpdate:modelValue": (value) => _ctx.handleCheckboxChanged(value, category)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(category.name), 1)
            ]),
            _: 2
          }, 1032, ["model-value", "onUpdate:modelValue"])
        ], 10, _hoisted_2);
      }), 128))
    ], 2)) : createCommentVNode("", true),
    _ctx.sortedCategories.length > _ctx.expandLimit && _ctx.collapsed && !_ctx.loading ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(_ctx.$style.button),
      "data-test-id": "expand-categories-button",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.collapseAction && _ctx.collapseAction(...args))
    }, [
      createVNode(_component_n8n_text, {
        size: "small",
        color: "primary"
      }, {
        default: withCtx(() => [
          createTextVNode(" + " + toDisplayString(`${_ctx.sortedCategories.length - _ctx.expandLimit} more`), 1)
        ]),
        _: 1
      })
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
const cssModules$1 = {
  "$style": style0$1
};
const __unplugin_components_0 = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__cssModules", cssModules$1]]);
const _sfc_main = defineComponent({
  name: "TemplatesSearchView",
  components: {
    TemplatesInfoCarousel: __unplugin_components_1,
    TemplateFilters: __unplugin_components_0,
    TemplateList: __unplugin_components_2,
    TemplatesView
  },
  beforeRouteLeave(_to, _from, next) {
    var _a, _b;
    const contentArea = document.getElementById("content");
    if (contentArea) {
      (_b = (_a = this.$route.meta) == null ? void 0 : _a.setScrollPosition) == null ? void 0 : _b.call(_a, contentArea.scrollTop);
    }
    this.trackSearch();
    next();
  },
  setup() {
    const { callDebounced } = useDebounce();
    return {
      callDebounced,
      ...useToast(),
      documentTitle: useDocumentTitle()
    };
  },
  data() {
    return {
      areCategoriesPrepopulated: false,
      categories: [],
      loading: true,
      loadingCategories: true,
      loadingCollections: true,
      loadingWorkflows: true,
      search: "",
      searchEventToTrack: null,
      errorLoadingWorkflows: false,
      creatorHubUrl: CREATOR_HUB_URL
    };
  },
  computed: {
    ...mapStores(useSettingsStore, useTemplatesStore, useUIStore, useUsersStore, usePostHog),
    totalWorkflows() {
      return this.templatesStore.getSearchedWorkflowsTotal(this.createQueryObject("name"));
    },
    workflows() {
      return this.templatesStore.getSearchedWorkflows(this.createQueryObject("name")) ?? [];
    },
    collections() {
      return this.templatesStore.getSearchedCollections(this.createQueryObject("id")) ?? [];
    },
    endOfSearchMessage() {
      if (this.loadingWorkflows) {
        return null;
      }
      if (!this.loadingCollections && this.workflows.length === 0 && this.collections.length === 0) {
        if (!this.settingsStore.isTemplatesEndpointReachable && this.errorLoadingWorkflows) {
          return this.$locale.baseText("templates.connectionWarning");
        }
        return this.$locale.baseText("templates.noSearchResults");
      }
      return null;
    },
    nothingFound() {
      return !this.loadingWorkflows && !this.loadingCollections && this.workflows.length === 0 && this.collections.length === 0;
    }
  },
  watch: {
    workflows(newWorkflows) {
      if (newWorkflows.length === 0) {
        this.scrollTo(0);
      }
    }
  },
  async mounted() {
    this.documentTitle.set("Templates");
    await this.loadCategories();
    void this.loadWorkflowsAndCollections(true);
    void this.usersStore.showPersonalizationSurvey();
    this.restoreSearchFromRoute();
    setTimeout(() => {
      var _a;
      const scrollOffset = (_a = this.$route.meta) == null ? void 0 : _a.scrollOffset;
      if (typeof scrollOffset === "number" && scrollOffset > 0) {
        this.scrollTo(scrollOffset, "auto");
      }
    }, 100);
  },
  methods: {
    createQueryObject(categoryId) {
      return {
        categories: this.categories.map(
          (category) => categoryId === "name" ? category.name : String(category.id)
        ),
        search: this.search
      };
    },
    restoreSearchFromRoute() {
      let updateSearch = false;
      if (this.$route.query.search && typeof this.$route.query.search === "string") {
        this.search = this.$route.query.search;
        updateSearch = true;
      }
      if (typeof this.$route.query.categories === "string" && this.$route.query.categories.length) {
        const categoriesFromURL = this.$route.query.categories.split(",");
        this.categories = this.templatesStore.allCategories.filter(
          (category) => categoriesFromURL.includes(category.id.toString())
        );
        updateSearch = true;
      }
      if (updateSearch) {
        this.updateSearch();
        this.trackCategories();
        this.areCategoriesPrepopulated = true;
      }
    },
    onOpenCollection({ event, id }) {
      this.navigateTo(event, VIEWS.COLLECTION, id);
    },
    onOpenTemplate({ event, id }) {
      this.navigateTo(event, VIEWS.TEMPLATE, id);
    },
    navigateTo(e, page, id) {
      if (e.metaKey || e.ctrlKey) {
        const route = this.$router.resolve({ name: page, params: { id } });
        window.open(route.href, "_blank");
        return;
      } else {
        void this.$router.push({ name: page, params: { id } });
      }
    },
    updateSearch() {
      this.updateQueryParam(this.search, this.categories.map((category) => category.id).join(","));
      void this.loadWorkflowsAndCollections(false);
    },
    updateSearchTracking(search2, categories2) {
      if (!search2) {
        return;
      }
      if (this.searchEventToTrack && this.searchEventToTrack.search_string.length > search2.length) {
        return;
      }
      this.searchEventToTrack = {
        search_string: search2,
        workflow_results_count: this.workflows.length,
        collection_results_count: this.collections.length,
        categories_applied: categories2.map(
          (categoryId) => this.templatesStore.getCategoryById(categoryId.toString())
        ),
        wf_template_repo_session_id: this.templatesStore.currentSessionId
      };
    },
    trackSearch() {
      if (this.searchEventToTrack) {
        this.$telemetry.track(
          "User searched workflow templates",
          this.searchEventToTrack
        );
        this.searchEventToTrack = null;
      }
    },
    onSearchInput(search2) {
      this.loadingWorkflows = true;
      this.loadingCollections = true;
      this.search = search2;
      void this.callDebounced(this.updateSearch, {
        debounceTime: 500,
        trailing: true
      });
      if (search2.length === 0) {
        this.trackSearch();
      }
    },
    onCategorySelected(selected) {
      this.categories = this.categories.concat(selected);
      this.updateSearch();
      this.trackCategories();
    },
    onCategoryUnselected(selected) {
      this.categories = this.categories.filter((category) => category.id !== selected.id);
      this.updateSearch();
      this.trackCategories();
    },
    onCategoriesCleared() {
      this.categories = [];
      this.updateSearch();
    },
    trackCategories() {
      if (this.categories.length) {
        this.$telemetry.track("User changed template filters", {
          search_string: this.search,
          categories_applied: this.categories,
          wf_template_repo_session_id: this.templatesStore.currentSessionId
        });
      }
    },
    updateQueryParam(search2, category) {
      const query = Object.assign({}, this.$route.query);
      if (category.length) {
        query.categories = category;
      } else {
        delete query.categories;
      }
      if (search2.length) {
        query.search = search2;
      } else {
        delete query.search;
      }
      void this.$router.replace({ query });
    },
    async onLoadMore() {
      if (this.workflows.length >= this.totalWorkflows) {
        return;
      }
      try {
        this.loadingWorkflows = true;
        await this.templatesStore.getMoreWorkflows({
          categories: this.categories.map((category) => category.name),
          search: this.search
        });
      } catch (e) {
        this.showMessage({
          title: "Error",
          message: "Could not load more workflows",
          type: "error"
        });
      } finally {
        this.loadingWorkflows = false;
      }
    },
    async loadCategories() {
      try {
        await this.templatesStore.getCategories();
      } catch (e) {
      }
      this.loadingCategories = false;
    },
    async loadCollections() {
      try {
        this.loadingCollections = true;
        await this.templatesStore.getCollections({
          categories: this.categories.map((category) => String(category.id)),
          search: this.search
        });
      } catch (e) {
      }
      this.loadingCollections = false;
    },
    async loadWorkflows() {
      try {
        this.loadingWorkflows = true;
        await this.templatesStore.getWorkflows({
          search: this.search,
          categories: this.categories.map((category) => category.name)
        });
        this.errorLoadingWorkflows = false;
      } catch (e) {
        this.errorLoadingWorkflows = true;
      }
      this.loadingWorkflows = false;
    },
    async loadWorkflowsAndCollections(initialLoad) {
      const search2 = this.search;
      const categories2 = [...this.categories];
      await Promise.all([this.loadWorkflows(), this.loadCollections()]);
      if (!initialLoad) {
        this.updateSearchTracking(
          search2,
          categories2.map((category) => category.id)
        );
      }
    },
    scrollTo(position, behavior = "smooth") {
      setTimeout(() => {
        const contentArea = document.getElementById("content");
        if (contentArea) {
          contentArea.scrollTo({
            top: position,
            behavior
          });
        }
      }, 0);
    }
  }
});
const wrapper = "_wrapper_1el39_1";
const contentWrapper = "_contentWrapper_1el39_6";
const filters = "_filters_1el39_16";
const search = "_search_1el39_22";
const header = "_header_1el39_34";
const style0 = {
  wrapper,
  contentWrapper,
  filters,
  search,
  header
};
const _hoisted_1 = ["textContent"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_n8n_heading = resolveComponent("n8n-heading");
  const _component_n8n_button = resolveComponent("n8n-button");
  const _component_TemplateFilters = __unplugin_components_0;
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  const _component_n8n_input = resolveComponent("n8n-input");
  const _component_TemplatesInfoCarousel = __unplugin_components_1;
  const _component_TemplateList = __unplugin_components_2;
  const _component_n8n_text = resolveComponent("n8n-text");
  const _component_TemplatesView = resolveComponent("TemplatesView");
  const _directive_n8n_html = resolveDirective("n8n-html");
  return openBlock(), createBlock(_component_TemplatesView, null, {
    header: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.wrapper)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.title)
        }, [
          createVNode(_component_n8n_heading, {
            tag: "h1",
            size: "2xlarge"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("templates.heading")), 1)
            ]),
            _: 1
          })
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.button)
        }, [
          createVNode(_component_n8n_button, {
            size: "large",
            type: "secondary",
            element: "a",
            href: _ctx.creatorHubUrl,
            label: _ctx.$locale.baseText("templates.shareWorkflow"),
            target: "_blank"
          }, null, 8, ["href", "label"])
        ], 2)
      ], 2)
    ]),
    content: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.contentWrapper)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.filters)
        }, [
          createVNode(_component_TemplateFilters, {
            categories: _ctx.templatesStore.allCategories,
            "sort-on-populate": _ctx.areCategoriesPrepopulated,
            selected: _ctx.categories,
            loading: _ctx.loadingCategories,
            onClear: _ctx.onCategoryUnselected,
            onClearAll: _ctx.onCategoriesCleared,
            onSelect: _ctx.onCategorySelected
          }, null, 8, ["categories", "sort-on-populate", "selected", "loading", "onClear", "onClearAll", "onSelect"])
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.search)
        }, [
          createVNode(_component_n8n_input, {
            "model-value": _ctx.search,
            placeholder: _ctx.$locale.baseText("templates.searchPlaceholder"),
            clearable: "",
            "data-test-id": "template-search-input",
            "onUpdate:modelValue": _ctx.onSearchInput,
            onBlur: _ctx.trackSearch
          }, {
            prefix: withCtx(() => [
              createVNode(_component_font_awesome_icon, { icon: "search" })
            ]),
            _: 1
          }, 8, ["model-value", "placeholder", "onUpdate:modelValue", "onBlur"]),
          withDirectives(createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.carouselContainer)
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.header)
            }, [
              createVNode(_component_n8n_heading, {
                bold: true,
                size: "medium",
                color: "text-light"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("templates.collections")) + " ", 1),
                  !_ctx.loadingCollections ? (openBlock(), createElementBlock("span", {
                    key: 0,
                    "data-test-id": "collection-count-label",
                    textContent: toDisplayString(`(${_ctx.collections.length})`)
                  }, null, 8, _hoisted_1)) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ], 2),
            createVNode(_component_TemplatesInfoCarousel, {
              collections: _ctx.collections,
              loading: _ctx.loadingCollections,
              onOpenCollection: _ctx.onOpenCollection
            }, null, 8, ["collections", "loading", "onOpenCollection"])
          ], 2), [
            [vShow, _ctx.collections.length || _ctx.loadingCollections]
          ]),
          createVNode(_component_TemplateList, {
            "infinite-scroll-enabled": true,
            loading: _ctx.loadingWorkflows,
            workflows: _ctx.workflows,
            "total-count": _ctx.totalWorkflows,
            onLoadMore: _ctx.onLoadMore,
            onOpenTemplate: _ctx.onOpenTemplate
          }, null, 8, ["loading", "workflows", "total-count", "onLoadMore", "onOpenTemplate"]),
          _ctx.endOfSearchMessage ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style.endText)
          }, [
            createVNode(_component_n8n_text, {
              size: "medium",
              color: "text-base"
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("span", null, null, 512), [
                  [_directive_n8n_html, _ctx.endOfSearchMessage]
                ])
              ]),
              _: 1
            })
          ], 2)) : createCommentVNode("", true)
        ], 2)
      ], 2)
    ]),
    _: 1
  });
}
const cssModules = {
  "$style": style0
};
const TemplatesSearchView = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__cssModules", cssModules]]);
export {
  TemplatesSearchView as default
};
