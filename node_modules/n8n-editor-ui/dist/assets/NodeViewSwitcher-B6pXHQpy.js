const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/RunDataTable-CNdHnjmM.js","assets/index-TQ22MZub.js","assets/index-BGyoJ6bM.css","assets/RunDataTable-ZwoYenSI.css","assets/RunDataJson-BR2zl0xs.js","assets/RunDataAi-Dr6ypWYk.js","assets/RunDataAi-x30tU8-0.css","assets/FileSaver.min-BZDLz63C.js","assets/dateFormatter-BgjGibAI.js","assets/useWorkflowActivate-DXNYJQNZ.js","assets/pushConnection.store-DBI9rig9.js","assets/useExecutionDebugging-rQ2a9vrr.js","assets/useBeforeUnload-Db4Xtdlx.js","assets/RunDataJson-Dtc8i0I7.css","assets/RunDataSearch-aEp6SsT6.js","assets/RunDataSearch-BA0wlJtp.css","assets/NodeCreation-CH8QZkmg.js","assets/NodeCreation-30KXmZi2.css","assets/CanvasControls-Bh28om35.js","assets/CanvasControls-Gjw5xMXK.css","assets/SetupWorkflowCredentialsButton-DrA_a2OJ.js"])))=>i.map(i=>d[i]);
import { aI as BaseTransition, aJ as BaseTransitionPropsValidators, aK as Comment, aL as DeprecationTypes, aM as EffectScope, aN as ErrorCodes, aO as ErrorTypeStrings, F as Fragment, aP as KeepAlive, aQ as ReactiveEffect, aR as Static, aS as Suspense, aT as Teleport, aU as Text, aV as TrackOpTypes, aW as Transition$2, aX as TransitionGroup, aY as TriggerOpTypes, aZ as VueElement, a_ as assertNumber, a$ as callWithAsyncErrorHandling, b0 as callWithErrorHandling, b1 as camelize, b2 as capitalize, b3 as cloneVNode, b4 as compatUtils, p as computed, b5 as createApp, e as createBlock, f as createCommentVNode, h as createElementBlock, j as createBaseVNode, b6 as createHydrationRenderer, b7 as createPropsRestProxy, b8 as createRenderer, b9 as createSSRApp, aE as createSlots, ba as createStaticVNode, k as createTextVNode, i as createVNode, bb as customRef, bc as defineAsyncComponent, d as defineComponent, bd as defineCustomElement, be as defineEmits, bf as defineExpose, bg as defineModel, bh as defineOptions, bi as defineProps, bj as defineSSRCustomElement, bk as defineSlots, bl as devtools, bm as effect, bn as effectScope, bo as getCurrentInstance, bp as getCurrentScope, bq as getCurrentWatcher, br as getTransitionRawChildren, bs as guardReactiveProps, bt as h, bu as handleError, bv as hasInjectionContext, bw as hydrate, bx as hydrateOnIdle, by as hydrateOnInteraction, bz as hydrateOnMediaQuery, bA as hydrateOnVisible, bB as initCustomFormatter, bC as initDirectivesForSSR, bD as inject, bE as isMemoSame, bF as isProxy, bG as isReactive, bH as isReadonly, bI as isRef, bJ as isRuntimeOnly, bK as isShallow, bL as isVNode, bM as markRaw, bN as mergeDefaults, bO as mergeModels, bP as mergeProps, C as nextTick, n as normalizeClass, bQ as normalizeProps, B as normalizeStyle, bR as onActivated, ar as onBeforeMount, y as onBeforeUnmount, bS as onBeforeUpdate, bT as onDeactivated, bU as onErrorCaptured, o as onMounted, bV as onRenderTracked, bW as onRenderTriggered, bX as onScopeDispose, bY as onServerPrefetch, bZ as onUnmounted, b_ as onUpdated, b$ as onWatcherCleanup, c as openBlock, c0 as popScopeId, c1 as provide, c2 as proxyRefs, c3 as pushScopeId, c4 as queuePostFlushCb, c5 as reactive, c6 as readonly, r as ref, c7 as registerRuntimeCompiler, c8 as render$5, z as renderList, q as renderSlot, l as resolveComponent, c9 as resolveDirective, ca as resolveDynamicComponent, cb as resolveFilter, cc as resolveTransitionHooks, cd as setBlockTracking, ce as setDevtoolsHook, cf as setTransitionHooks, cg as shallowReactive, ch as shallowReadonly, ci as shallowRef, cj as ssrContextKey, ck as ssrUtils, cl as stop, t as toDisplayString, cm as toHandlerKey, cn as toHandlers, co as toRaw, cp as toRef, cq as toRefs$1, cr as toValue$1, cs as transformVNodeArgs, ct as triggerRef, A as unref, cu as useAttrs, aa as useCssModule, cv as useCssVars, cw as useHost, cx as useId, cy as useModel, cz as useSSRContext, cA as useShadowRoot, cB as useSlots, cC as useTemplateRef, cD as useTransitionState, cE as vModelCheckbox, cF as vModelDynamic, cG as vModelRadio, cH as vModelSelect, cI as vModelText, at as vShow, cJ as version, cK as warn$1, H as watch, cL as watchEffect, cM as watchPostEffect, cN as watchSyncEffect, cO as withAsyncContext, w as withCtx, cP as withDefaults, as as withDirectives, G as withKeys, cQ as withMemo, I as withModifiers, cR as withScopeId, cS as createCompounder, cT as SetCache, cU as arrayIncludes, cV as cacheHas, cW as baseRest, cX as isArrayLikeObject, cY as baseFlatten, K as useUIStore, cZ as useNodeTypesStore, T as useWorkflowsStore, a0 as useSourceControlStore, am as getResourcePermissions, c_ as isPresent, c$ as getMousePosition$1, au as STICKY_NODE_TYPE, d0 as usePinnedData, g as useI18n, d1 as NOT_DUPLICATABLE_NODE_TYPES, E as onClickOutside, d2 as N8nActionDropdown, _ as _export_sfc$1, d3 as _sfc_main$10, ap as useNDVStore, d4 as isCommunityPackageName, d5 as NPM_PACKAGE_DOCS_BASE_URL, d6 as BUILTIN_NODES_DOCS_URL, d7 as COMMUNITY_NODES_INSTALLATION_DOCS_URL, d8 as NodeConnectionType, aF as useExternalHooks, ak as useTelemetry, b as useRouter, d9 as useClipboard, a4 as useWorkflowHelpers, a as useToast, da as OPEN_URL_PANEL_TRIGGER_NODE_TYPES, db as PRODUCTION_ONLY_TRIGGER_NODE_TYPES, dc as FORM_TRIGGER_NODE_TYPE, dd as CHAT_TRIGGER_NODE_TYPE, de as toValue$2, df as toRef$1, dg as tryOnScopeDispose$1, dh as isIOS, di as noop$4, dj as isObject$1, dk as isClient$1, dl as useNodeHelpers, J as useDebounce, dm as TitledList, dn as nodeIssuesToString, dp as getNodeInputs, dq as useRunWorkflow, dr as MANUAL_TRIGGER_NODE_TYPE, ds as WEBHOOK_NODE_TYPE, ac as nodeViewEventBus, al as useMessage, ae as MODAL_CONFIRM, dt as useCredentialsStore, du as useHistoryStore, dv as importCurlEventBus, dw as ndvEventBus, dx as CUSTOM_NODES_DOCS_URL, dy as NodeCredentials, dz as _sfc_main$11, dA as ProjectTypes, dB as getConnectionTypes, dC as isSingleExecution, dD as get$4, dE as getNodeParameters, dF as deepCopy, dG as set$4, dH as unset, dI as SHOULD_CLEAR_NODE_OUTPUTS, dJ as RenameNodeCommand, dK as isINodePropertyCollectionList, dL as isINodePropertiesList, dM as isINodePropertyOptionsList, dN as displayParameter, dO as Draggable, aA as useStorage, dP as LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH, dQ as MAIN_NODE_PANEL_WIDTH, dR as getAugmentedNamespace, dS as commonjsGlobal, dT as getDefaultExportFromCjs, dU as sanitizeHtml_1, dV as sanitizeHtml, dW as jsonParse, dX as __unplugin_components_2$2, dY as useNodeType, dZ as MAX_DISPLAY_DATA_SIZE, d_ as MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW, d$ as MAX_DISPLAY_ITEMS_AUTO_ALL, e0 as mapStores, Z as useRootStore, e1 as DATA_PINNING_DOCS_URL, e2 as DATA_EDITING_DOCS_URL, e3 as HTML_NODE_TYPE, e4 as executionDataToJson, e5 as NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND, e6 as isEmpty, e7 as isEqual, e8 as getNodeOutputs, e9 as getNodeHints, ea as getGenericHints, eb as dataPinningEventBus, ec as clearJsonKey, ed as searchInObject, ee as isObject$2, ef as LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG, eg as LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG, eh as TEST_PIN_DATA, ei as __vitePreload, ej as storeToRefs, ek as waitingNodeTooltip, el as truncate, em as START_NODE_TYPE, en as CRON_NODE_TYPE, eo as INTERVAL_NODE_TYPE, ep as CopyInput, v as createEventBus, eq as isTriggerPanelObject, er as getTriggerNodeServiceName, V as VIEWS, ag as WORKFLOW_SETTINGS_MODAL_KEY, m as useSettingsStore, es as useDeviceSupport, et as APP_MODALS_ELEMENT_ID, eu as EXECUTABLE_TRIGGER_NODE_TYPES, ev as BASE_NODE_SURVEY_URL, a8 as EnterpriseEditionFeature, ew as getAnchorPosition, ex as isValidNodeConnectionType, ey as getEndpointScope, ez as getInputEndpointUUID, eA as getInputEndpointStyle, eB as getScope, eC as getInputNameOverlay, eD as NODE_INSERT_SPACER_BETWEEN_INPUT_GROUPS, eE as NODE_MIN_INPUT_ITEMS_COUNT, eF as getOutputEndpointUUID, eG as getOutputEndpointStyle, eH as getOutputNameOverlay, eI as NO_OP_NODE_TYPE, eJ as NODE_CONNECTION_TYPE_ALLOW_MULTIPLE, eK as GRID_SIZE, eL as isString, eM as isNumber, eN as assert, eO as QUICKSTART_NOTE_NAME, eP as CUSTOM_API_CALL_KEY, eQ as FontAwesomeIcon, eR as _sfc_main$13, eS as xss, eT as WAIT_NODE_TYPE, eU as SEND_AND_WAIT_OPERATION, eV as WAIT_TIME_UNLIMITED, eW as SIMULATE_NODE_TYPE, eX as SIMULATE_TRIGGER_NODE_TYPE, $ as useCanvasStore, eY as getRelativePosition, eZ as v4, e_ as CORE_NODES_CATEGORY, e$ as DEFAULT_SUBCATEGORY, f0 as AI_TRANSFORM_NODE_TYPE, f1 as AI_SUBCATEGORY, f2 as AI_CATEGORY_AGENTS, f3 as sortBy, f4 as i18n, aC as useTemplatesStore, f5 as AI_NODE_CREATOR_VIEW, f6 as AI_OTHERS_NODE_CREATOR_VIEW, f7 as AI_CATEGORY_DOCUMENT_LOADERS, f8 as AI_CATEGORY_LANGUAGE_MODELS, f9 as AI_CATEGORY_MEMORY, fa as AI_CATEGORY_OUTPUTPARSER, fb as AI_CATEGORY_RETRIEVERS, fc as AI_CATEGORY_TEXT_SPLITTERS, fd as AI_CATEGORY_TOOLS, fe as AI_WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE, ff as AI_CODE_TOOL_LANGCHAIN_NODE_TYPE, fg as AI_CATEGORY_EMBEDDING, fh as AI_CATEGORY_VECTOR_STORES, fi as AI_UNCATEGORIZED_CATEGORY, fj as TRIGGER_NODE_CREATOR_VIEW, fk as EMAIL_IMAP_NODE_TYPE, fl as SCHEDULE_TRIGGER_NODE_TYPE, fm as EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE, fn as MANUAL_CHAT_TRIGGER_NODE_TYPE, fo as OTHER_TRIGGER_NODES_SUBCATEGORY, fp as REGULAR_NODE_CREATOR_VIEW, fq as RSS_READ_NODE_TYPE, fr as EMAIL_SEND_NODE_TYPE, fs as TRANSFORM_DATA_SUBCATEGORY, ft as FILTER_NODE_TYPE, fu as REMOVE_DUPLICATES_NODE_TYPE, fv as SPLIT_OUT_NODE_TYPE, fw as LIMIT_NODE_TYPE, fx as SUMMARIZE_NODE_TYPE, fy as AGGREGATE_NODE_TYPE, fz as MERGE_NODE_TYPE, fA as MARKDOWN_NODE_TYPE, fB as XML_NODE_TYPE, fC as CRYPTO_NODE_TYPE, fD as EXTRACT_FROM_FILE_NODE_TYPE, fE as CONVERT_TO_FILE_NODE_TYPE, fF as COMPRESSION_NODE_TYPE, fG as EDIT_IMAGE_NODE_TYPE, fH as FLOWS_CONTROL_SUBCATEGORY, fI as IF_NODE_TYPE, fJ as SPLIT_IN_BATCHES_NODE_TYPE, fK as HELPERS_SUBCATEGORY, fL as HTTP_REQUEST_NODE_TYPE, fM as CODE_NODE_TYPE, fN as AI_CATEGORY_CHAINS, fO as SET_NODE_TYPE, fP as DATETIME_NODE_TYPE, R as defineStore, fQ as AI_CATEGORY_ROOT_NODES, fR as AI_CODE_NODE_TYPE, fS as AI_TRANSFORM_NODE_TYPE$1, fT as isValidCanvasConnectionMode, fU as CanvasConnectionMode, S as STORES, fV as NODE_CREATOR_OPEN_SOURCES, fW as isVueFlowConnection, fX as nodeConnectionTypes, fY as MOUSE_EVENT_BUTTON, fZ as MOUSE_EVENT_BUTTONS, f_ as KeyboardShortcutTooltip, U as useRoute, a3 as useDocumentTitle, a2 as useNpsSurveyStore, a1 as useProjectsStore, aq as useExecutionsStore, f$ as useExternalSecretsStore, g0 as useWorkflowsEEStore, g1 as useEnvironmentsStore, u as useUsersStore, D as useTagsStore, g2 as getBackgroundStyles, g3 as getNodeViewTab, X as PLACEHOLDER_EMPTY_WORKFLOW_ID, ao as MAIN_HEADER_TABS, g4 as ready$1, aw as sourceControlEventBus, g5 as historyBus, g6 as WORKFLOW_LM_CHAT_MODAL_KEY, g7 as generateNodesGraph, g8 as N8nAddInputEndpointType, g9 as getFixedNodesList, ga as tryToParseNumber, gb as MoveNodeCommand, ai as VALID_WORKFLOW_IMPORT_URL_REGEX, gc as UPDATE_WEBHOOK_ID_NODE_TYPES, gd as getNewNodePosition, ge as DRAG_EVENT_DATA_KEY, gf as NODE_SIZE, gg as getConnectorLengths, gh as MAX_X_TO_PUSH_DOWNSTREAM_NODES, gi as PUSH_NODES_OFFSET, gj as generateOffsets, gk as resetConnectionAfterPull, gl as resetConnection, gm as moveBackInputLabelPosition, gn as hideOutputNameLabel, go as addConnectionActionsOverlay, gp as getOverlay, gq as OVERLAY_ENDPOINT_ARROW_ID, gr as getConnectorPaintStyleData, gs as AddConnectionCommand, gt as addConnectionTestData, gu as showOrHideItemsLabel, gv as showOrHideMidpointArrow, gw as isJSPlumbConnection, gx as hideConnectionActions, gy as showConnectionActions, gz as resetInputLabelPosition, gA as getConnectionInfo, gB as showOutputNameLabel, gC as RemoveConnectionCommand, gD as isJSPlumbEndpointElement, gE as isElementIntersection, gF as calculateElementIntersection, gG as showDropConnectionState, gH as showPullConnectionState, gI as EVENT_CONNECTION_ABORT, gJ as INTERCEPT_BEFORE_DROP, gK as EVENT_CONNECTION, gL as EVENT_DRAG_MOVE, gM as EVENT_CONNECTION_MOUSEOVER, gN as EVENT_CONNECTION_MOUSEOUT, gO as EVENT_CONNECTION_MOVED, gP as EVENT_ENDPOINT_MOUSEOVER, gQ as EVENT_ENDPOINT_MOUSEOUT, gR as EVENT_CONNECTION_DETACHED, gS as EVENT_CONNECTION_DRAG, gT as EVENT_PLUS_ENDPOINT_CLICK, gU as EVENT_ADD_INPUT_ENDPOINT_CLICK, gV as N8nPlusEndpointType, gW as usePostHog, gX as CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT, gY as MODAL_CANCEL, gZ as addClassesToOverlays, g_ as getJSPlumbEndpoints, g$ as isSubNodeType, h0 as useDataSchema, h1 as OVERLAY_RUN_ITEMS_ID, h2 as RemoveNodeCommand, h3 as CanvasKey, h4 as CanvasNodeKey, h5 as CanvasNodeRenderType, h6 as N8nTooltip, h7 as CanvasNodeHandleKey, h8 as useActiveElement, h9 as useEventListener$2, ha as onKeyDown, hb as onKeyUp, hc as useDebounceFn, hd as sanitizeHtml$1, he as AddNodeCommand, hf as DEFAULT_NODE_SIZE, hg as CONFIGURATION_NODE_SIZE, hh as CONFIGURABLE_NODE_SIZE, hi as NEW_WORKFLOW_ID, a5 as useLocalStorage, hj as onBeforeRouteLeave } from "./index-TQ22MZub.js";
import { c as capitalize$1, _ as _sfc_main$12, R as RunDataAi } from "./RunDataAi-Dr6ypWYk.js";
import { F as FileSaver_minExports } from "./FileSaver.min-BZDLz63C.js";
import { c as convertToDisplayDateComponents } from "./dateFormatter-BgjGibAI.js";
import { u as useWorkflowActivate } from "./useWorkflowActivate-DXNYJQNZ.js";
import { g as globalLinkActionsEventBus, u as usePushConnectionStore } from "./pushConnection.store-DBI9rig9.js";
import { u as useExecutionDebugging } from "./useExecutionDebugging-rQ2a9vrr.js";
import { u as useBeforeUnload } from "./useBeforeUnload-Db4Xtdlx.js";
/**
* vue v3.5.11
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const compile = () => {
};
const vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition,
  BaseTransitionPropsValidators,
  Comment,
  DeprecationTypes,
  EffectScope,
  ErrorCodes,
  ErrorTypeStrings,
  Fragment,
  KeepAlive,
  ReactiveEffect,
  Static,
  Suspense,
  Teleport,
  Text,
  TrackOpTypes,
  Transition: Transition$2,
  TransitionGroup,
  TriggerOpTypes,
  VueElement,
  assertNumber,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  camelize,
  capitalize,
  cloneVNode,
  compatUtils,
  compile,
  computed,
  createApp,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSSRApp,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  customRef,
  defineAsyncComponent,
  defineComponent,
  defineCustomElement,
  defineEmits,
  defineExpose,
  defineModel,
  defineOptions,
  defineProps,
  defineSSRCustomElement,
  defineSlots,
  devtools,
  effect,
  effectScope,
  getCurrentInstance,
  getCurrentScope,
  getCurrentWatcher,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  hasInjectionContext,
  hydrate,
  hydrateOnIdle,
  hydrateOnInteraction,
  hydrateOnMediaQuery,
  hydrateOnVisible,
  initCustomFormatter,
  initDirectivesForSSR,
  inject,
  isMemoSame,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isRuntimeOnly,
  isShallow,
  isVNode,
  markRaw,
  mergeDefaults,
  mergeModels,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onScopeDispose,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  onWatcherCleanup,
  openBlock,
  popScopeId,
  provide,
  proxyRefs,
  pushScopeId,
  queuePostFlushCb,
  reactive,
  readonly,
  ref,
  registerRuntimeCompiler,
  render: render$5,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  ssrContextKey,
  ssrUtils,
  stop,
  toDisplayString,
  toHandlerKey,
  toHandlers,
  toRaw,
  toRef,
  toRefs: toRefs$1,
  toValue: toValue$1,
  transformVNodeArgs,
  triggerRef,
  unref,
  useAttrs,
  useCssModule,
  useCssVars,
  useHost,
  useId,
  useModel,
  useSSRContext,
  useShadowRoot,
  useSlots,
  useTemplateRef,
  useTransitionState,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  version,
  warn: warn$1,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withKeys,
  withMemo,
  withModifiers,
  withScopeId
}, Symbol.toStringTag, { value: "Module" }));
var camelCase = createCompounder(function(result, word, index) {
  word = word.toLowerCase();
  return result + (index ? capitalize$1(word) : word);
});
var LARGE_ARRAY_SIZE = 200;
function baseDifference(array2, values, iteratee, comparator) {
  var index = -1, includes = arrayIncludes, isCommon = true, length = array2.length, result = [], valuesLength = values.length;
  if (!length) {
    return result;
  }
  if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
    while (++index < length) {
      var value = array2[index], computed2 = value;
      value = value !== 0 ? value : 0;
      if (isCommon && computed2 === computed2) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === computed2) {
            continue outer;
          }
        }
        result.push(value);
      } else if (!includes(values, computed2, comparator)) {
        result.push(value);
      }
    }
  return result;
}
var difference = baseRest(function(array2, values) {
  return isArrayLikeObject(array2) ? baseDifference(array2, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
});
const position = ref([0, 0]);
const isOpen = ref(false);
const target = ref();
const actions = ref([]);
const actionCallback = ref(() => {
});
const useContextMenu = (onAction = () => {
}) => {
  const uiStore = useUIStore();
  const nodeTypesStore = useNodeTypesStore();
  const workflowsStore = useWorkflowsStore();
  const sourceControlStore = useSourceControlStore();
  const i18n2 = useI18n();
  const workflowPermissions = computed(
    () => getResourcePermissions(workflowsStore.workflow.scopes).workflow
  );
  const isReadOnly = computed(
    () => sourceControlStore.preferences.branchReadOnly || uiStore.isReadOnlyView || !workflowPermissions.value.update
  );
  const targetNodeIds = computed(() => {
    if (!isOpen.value || !target.value) return [];
    const currentTarget = target.value;
    return currentTarget.source === "canvas" ? currentTarget.nodeIds : [currentTarget.nodeId];
  });
  const targetNodes = computed(
    () => targetNodeIds.value.map((nodeId) => workflowsStore.getNodeById(nodeId)).filter(isPresent)
  );
  const canAddNodeOfType = (nodeType) => {
    const sameTypeNodes = workflowsStore.allNodes.filter((n) => n.type === nodeType.name);
    return nodeType.maxNodes === void 0 || sameTypeNodes.length < nodeType.maxNodes;
  };
  const canDuplicateNode = (node2) => {
    const nodeType = nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    if (!nodeType) return false;
    if (NOT_DUPLICATABLE_NODE_TYPES.includes(nodeType.name)) return false;
    return canAddNodeOfType(nodeType);
  };
  const hasPinData = (node2) => {
    return !!workflowsStore.pinDataByNodeName(node2.name);
  };
  const close = () => {
    target.value = void 0;
    isOpen.value = false;
    actions.value = [];
    position.value = [0, 0];
  };
  const open = (event, menuTarget) => {
    var _a;
    event.stopPropagation();
    if (isOpen.value && menuTarget.source === ((_a = target.value) == null ? void 0 : _a.source)) {
      close();
      return;
    }
    event.preventDefault();
    actionCallback.value = onAction;
    target.value = menuTarget;
    position.value = getMousePosition$1(event);
    isOpen.value = true;
    const nodes = targetNodes.value;
    const onlyStickies = nodes.every((node2) => node2.type === STICKY_NODE_TYPE);
    const i18nOptions = {
      adjustToNumber: nodes.length,
      interpolate: {
        subject: onlyStickies ? i18n2.baseText("contextMenu.sticky", { adjustToNumber: nodes.length }) : i18n2.baseText("contextMenu.node", { adjustToNumber: nodes.length })
      }
    };
    const selectionActions = [
      {
        id: "select_all",
        divided: true,
        label: i18n2.baseText("contextMenu.selectAll"),
        shortcut: { metaKey: true, keys: ["A"] },
        disabled: nodes.length === workflowsStore.allNodes.length
      },
      {
        id: "deselect_all",
        label: i18n2.baseText("contextMenu.deselectAll"),
        disabled: nodes.length === 0
      }
    ];
    if (nodes.length === 0) {
      actions.value = [
        {
          id: "add_node",
          shortcut: { keys: ["Tab"] },
          label: i18n2.baseText("contextMenu.addNode"),
          disabled: isReadOnly.value
        },
        {
          id: "add_sticky",
          shortcut: { shiftKey: true, keys: ["s"] },
          label: i18n2.baseText("contextMenu.addSticky"),
          disabled: isReadOnly.value
        },
        ...selectionActions
      ];
    } else {
      const menuActions = [
        !onlyStickies && {
          id: "toggle_activation",
          label: nodes.every((node2) => node2.disabled) ? i18n2.baseText("contextMenu.activate", i18nOptions) : i18n2.baseText("contextMenu.deactivate", i18nOptions),
          shortcut: { keys: ["D"] },
          disabled: isReadOnly.value
        },
        !onlyStickies && {
          id: "toggle_pin",
          label: nodes.every((node2) => hasPinData(node2)) ? i18n2.baseText("contextMenu.unpin", i18nOptions) : i18n2.baseText("contextMenu.pin", i18nOptions),
          shortcut: { keys: ["p"] },
          disabled: isReadOnly.value || !nodes.every((n) => usePinnedData(n).canPinNode(true))
        },
        {
          id: "copy",
          label: i18n2.baseText("contextMenu.copy", i18nOptions),
          shortcut: { metaKey: true, keys: ["C"] }
        },
        {
          id: "duplicate",
          label: i18n2.baseText("contextMenu.duplicate", i18nOptions),
          shortcut: { metaKey: true, keys: ["D"] },
          disabled: isReadOnly.value || !nodes.every(canDuplicateNode)
        },
        ...selectionActions,
        {
          id: "delete",
          divided: true,
          label: i18n2.baseText("contextMenu.delete", i18nOptions),
          shortcut: { keys: ["Del"] },
          disabled: isReadOnly.value
        }
      ].filter(Boolean);
      if (nodes.length === 1) {
        const singleNodeActions = onlyStickies ? [
          {
            id: "open",
            label: i18n2.baseText("contextMenu.editSticky"),
            shortcut: { keys: ["↵"] },
            disabled: isReadOnly.value
          },
          {
            id: "change_color",
            label: i18n2.baseText("contextMenu.changeColor"),
            disabled: isReadOnly.value
          }
        ] : [
          {
            id: "open",
            label: i18n2.baseText("contextMenu.open"),
            shortcut: { keys: ["↵"] }
          },
          {
            id: "execute",
            label: i18n2.baseText("contextMenu.test"),
            disabled: isReadOnly.value
          },
          {
            id: "rename",
            label: i18n2.baseText("contextMenu.rename"),
            shortcut: { keys: ["F2"] },
            disabled: isReadOnly.value
          }
        ];
        menuActions.unshift(...singleNodeActions);
      }
      actions.value = menuActions;
    }
  };
  const _dispatchAction = (a) => {
    actionCallback.value(a, targetNodeIds.value);
  };
  watch(
    () => uiStore.nodeViewOffsetPosition,
    () => {
      close();
    }
  );
  return {
    isOpen,
    position,
    target,
    actions,
    targetNodeIds,
    open,
    close,
    _dispatchAction
  };
};
const _sfc_main$$ = /* @__PURE__ */ defineComponent({
  __name: "ContextMenu",
  emits: ["action"],
  setup(__props, { emit: __emit }) {
    const contextMenu2 = useContextMenu();
    const { position: position2, isOpen: isOpen2, actions: actions2, target: target2 } = contextMenu2;
    const dropdown = ref();
    const emit = __emit;
    const container2 = ref();
    watch(
      isOpen2,
      () => {
        var _a, _b;
        if (isOpen2) {
          (_a = dropdown.value) == null ? void 0 : _a.open();
        } else {
          (_b = dropdown.value) == null ? void 0 : _b.close();
        }
      },
      { flush: "post" }
    );
    function onActionSelect(item) {
      const action2 = item;
      contextMenu2._dispatchAction(action2);
      emit("action", action2, contextMenu2.targetNodeIds.value);
    }
    function closeMenu(event) {
      event.preventDefault();
      event.stopPropagation();
      contextMenu2.close();
    }
    function onVisibleChange(open) {
      if (!open) {
        contextMenu2.close();
      }
    }
    onClickOutside(container2, closeMenu);
    return (_ctx, _cache) => {
      var _a;
      return unref(isOpen2) ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: "body"
      }, [
        createBaseVNode("div", {
          ref_key: "container",
          ref: container2,
          class: normalizeClass(_ctx.$style.contextMenu),
          style: normalizeStyle({
            left: `${unref(position2)[0]}px`,
            top: `${unref(position2)[1]}px`
          })
        }, [
          createVNode(unref(N8nActionDropdown), {
            ref_key: "dropdown",
            ref: dropdown,
            items: unref(actions2),
            placement: "bottom-start",
            "data-test-id": "context-menu",
            "hide-arrow": ((_a = unref(target2)) == null ? void 0 : _a.source) !== "node-button",
            teleported: false,
            onSelect: onActionSelect,
            onVisibleChange
          }, {
            activator: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.activator)
              }, null, 2)
            ]),
            _: 1
          }, 8, ["items", "hide-arrow"])
        ], 6)
      ])) : createCommentVNode("", true);
    };
  }
});
const contextMenu = "_contextMenu_1t4kq_1";
const activator = "_activator_1t4kq_5";
const style0$A = {
  contextMenu,
  activator
};
const cssModules$C = {
  "$style": style0$A
};
const ContextMenu = /* @__PURE__ */ _export_sfc$1(_sfc_main$$, [["__cssModules", cssModules$C]]);
const _sfc_main$_ = /* @__PURE__ */ defineComponent({
  __name: "NodeTitle",
  props: {
    modelValue: { default: "" },
    nodeType: { default: void 0 },
    readOnly: { type: Boolean, default: false }
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const editName = ref(false);
    const newName = ref("");
    const input = ref();
    const editable = computed(() => !props.readOnly && window === window.parent);
    async function onEdit() {
      newName.value = props.modelValue;
      editName.value = true;
      await nextTick();
      if (input.value) {
        input.value.focus();
      }
    }
    function onRename() {
      if (newName.value.trim() !== "") {
        emit("update:model-value", newName.value.trim());
      }
      editName.value = false;
    }
    return (_ctx, _cache) => {
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_input = resolveComponent("n8n-input");
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_popover = resolveComponent("n8n-popover");
      return openBlock(), createElementBlock("span", {
        class: normalizeClass(_ctx.$style.container),
        "data-test-id": "node-title-container",
        onClick: onEdit
      }, [
        createBaseVNode("span", {
          class: normalizeClass(_ctx.$style.iconWrapper)
        }, [
          createVNode(_sfc_main$10, {
            "node-type": _ctx.nodeType,
            size: 18
          }, null, 8, ["node-type"])
        ], 2),
        createVNode(_component_n8n_popover, {
          placement: "right",
          width: "200",
          visible: editName.value,
          disabled: !editable.value
        }, {
          reference: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass({ [_ctx.$style.title]: true, [_ctx.$style.hoverable]: editable.value })
            }, [
              createTextVNode(toDisplayString(_ctx.modelValue) + " ", 1),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.editIconContainer)
              }, [
                editable.value ? (openBlock(), createBlock(_component_font_awesome_icon, {
                  key: 0,
                  class: normalizeClass(_ctx.$style.editIcon),
                  icon: "pencil-alt"
                }, null, 8, ["class"])) : createCommentVNode("", true)
              ], 2)
            ], 2)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.editContainer),
              onKeydown: [
                withKeys(onRename, ["enter"]),
                _cache[2] || (_cache[2] = withModifiers(() => {
                }, ["stop"])),
                _cache[3] || (_cache[3] = withKeys(($event) => editName.value = false, ["esc"]))
              ]
            }, [
              createVNode(_component_n8n_text, {
                bold: true,
                color: "text-base",
                tag: "div"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.title.renameNode")), 1)
                ]),
                _: 1
              }),
              createVNode(_component_n8n_input, {
                ref_key: "input",
                ref: input,
                modelValue: newName.value,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => newName.value = $event),
                size: "small",
                "data-test-id": "node-rename-input"
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.editButtons)
              }, [
                createVNode(_component_n8n_button, {
                  type: "secondary",
                  size: "small",
                  label: _ctx.$locale.baseText("ndv.title.cancel"),
                  onClick: _cache[1] || (_cache[1] = ($event) => editName.value = false)
                }, null, 8, ["label"]),
                createVNode(_component_n8n_button, {
                  type: "primary",
                  size: "small",
                  label: _ctx.$locale.baseText("ndv.title.rename"),
                  onClick: onRename
                }, null, 8, ["label"])
              ], 2)
            ], 34)
          ]),
          _: 1
        }, 8, ["visible", "disabled"])
      ], 2);
    };
  }
});
const container$3 = "_container_9bi3m_1";
const title$3 = "_title_9bi3m_11";
const hoverable = "_hoverable_9bi3m_19";
const editIcon = "_editIcon_9bi3m_22";
const iconWrapper = "_iconWrapper_9bi3m_26";
const editIconContainer = "_editIconContainer_9bi3m_39";
const editButtons = "_editButtons_9bi3m_45";
const editContainer = "_editContainer_9bi3m_53";
const style0$z = {
  container: container$3,
  title: title$3,
  hoverable,
  editIcon,
  iconWrapper,
  editIconContainer,
  editButtons,
  editContainer
};
const cssModules$B = {
  "$style": style0$z
};
const NodeTitle = /* @__PURE__ */ _export_sfc$1(_sfc_main$_, [["__cssModules", cssModules$B]]);
const _sfc_main$Z = /* @__PURE__ */ defineComponent({
  __name: "NodeSettingsTabs",
  props: {
    modelValue: { default: "params" },
    nodeType: { default: void 0 },
    pushRef: { default: "" }
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const externalHooks = useExternalHooks();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const i18n2 = useI18n();
    const telemetry = useTelemetry();
    const activeNode = computed(() => ndvStore.activeNode);
    const isCommunityNode = computed(() => {
      const nodeType = props.nodeType;
      if (nodeType) {
        return isCommunityPackageName(nodeType.name);
      }
      return false;
    });
    const packageName = computed(() => {
      var _a;
      return ((_a = props.nodeType) == null ? void 0 : _a.name.split(".")[0]) ?? "";
    });
    const documentationUrl = computed(() => {
      var _a, _b, _c, _d;
      const nodeType = props.nodeType;
      if (!nodeType) {
        return "";
      }
      if (nodeType.documentationUrl && nodeType.documentationUrl.startsWith("http")) {
        return nodeType.documentationUrl;
      }
      const utmParams = new URLSearchParams({
        utm_source: "n8n_app",
        utm_medium: "node_settings_modal-credential_link",
        utm_campaign: nodeType.name
      });
      const primaryDocUrl = (_d = (_c = (_b = (_a = nodeType.codex) == null ? void 0 : _a.resources) == null ? void 0 : _b.primaryDocumentation) == null ? void 0 : _c[0]) == null ? void 0 : _d.url;
      if (primaryDocUrl) {
        return `${primaryDocUrl}?${utmParams.toString()}`;
      }
      if (isCommunityNode.value) {
        return `${NPM_PACKAGE_DOCS_BASE_URL}${packageName.value}`;
      }
      return `${BUILTIN_NODES_DOCS_URL}?${utmParams.toString()}`;
    });
    const options = computed(() => {
      const options2 = [
        {
          label: i18n2.baseText("nodeSettings.parameters"),
          value: "params"
        },
        {
          label: i18n2.baseText("nodeSettings.settings"),
          value: "settings"
        }
      ];
      if (isCommunityNode.value) {
        options2.push({
          icon: "cube",
          value: "communityNode",
          align: "right",
          tooltip: i18n2.baseText("generic.communityNode.tooltip", {
            interpolate: {
              docUrl: COMMUNITY_NODES_INSTALLATION_DOCS_URL,
              packageName: packageName.value
            }
          })
        });
      }
      if (documentationUrl.value) {
        options2.push({
          label: i18n2.baseText("nodeSettings.docs"),
          value: "docs",
          href: documentationUrl.value,
          align: "right"
        });
      }
      return options2;
    });
    function onTabSelect(tab) {
      var _a;
      if (tab === "docs" && props.nodeType) {
        void externalHooks.run("dataDisplay.onDocumentationUrlClick", {
          nodeType: props.nodeType,
          documentationUrl: documentationUrl.value
        });
        telemetry.track("User clicked ndv link", {
          node_type: (_a = activeNode.value) == null ? void 0 : _a.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: props.pushRef,
          pane: NodeConnectionType.Main,
          type: "docs"
        });
      }
      if (tab === "settings" && props.nodeType) {
        telemetry.track("User viewed node settings", {
          node_type: props.nodeType.name,
          workflow_id: workflowsStore.workflowId
        });
      }
      if (tab === "settings" || tab === "params") {
        emit("update:model-value", tab);
      }
    }
    function onTooltipClick(tab, event) {
      if (tab === "communityNode" && event.target.localName === "a") {
        telemetry.track("user clicked cnr docs link", { source: "node details view" });
      }
    }
    return (_ctx, _cache) => {
      const _component_N8nTabs = resolveComponent("N8nTabs");
      return openBlock(), createBlock(_component_N8nTabs, {
        options: options.value,
        "model-value": _ctx.modelValue,
        "onUpdate:modelValue": onTabSelect,
        onTooltipClick
      }, null, 8, ["options", "model-value"]);
    };
  }
});
const _hoisted_1$r = {
  key: 0,
  class: "webhooks"
};
const _hoisted_2$i = ["title"];
const _hoisted_3$f = {
  key: 0,
  class: "node-webhooks"
};
const _hoisted_4$8 = {
  key: 0,
  class: "url-selection"
};
const _hoisted_5$7 = {
  key: 0,
  class: "webhook-wrapper"
};
const _hoisted_6$7 = { class: "http-field" };
const _hoisted_7$5 = { class: "http-method" };
const _hoisted_8$5 = { class: "url-field" };
const _hoisted_9$4 = ["onClick"];
const _hoisted_10$2 = {
  key: 1,
  class: "webhook-wrapper"
};
const _hoisted_11$2 = { class: "url-field-full-width" };
const _hoisted_12$1 = ["onClick"];
const _sfc_main$Y = /* @__PURE__ */ defineComponent({
  __name: "NodeWebhooks",
  props: {
    node: {},
    nodeTypeDescription: {}
  },
  setup(__props) {
    const props = __props;
    const router = useRouter();
    const clipboard = useClipboard();
    const workflowHelpers = useWorkflowHelpers({ router });
    const toast = useToast();
    const i18n2 = useI18n();
    const telemetry = useTelemetry();
    const isMinimized = ref(
      props.nodeTypeDescription && !OPEN_URL_PANEL_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name)
    );
    const showUrlFor = ref("test");
    const isProductionOnly = computed(() => {
      return props.nodeTypeDescription && PRODUCTION_ONLY_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name);
    });
    const urlOptions = computed(() => [
      ...isProductionOnly.value ? [] : [{ label: baseText.value.testUrl, value: "test" }],
      {
        label: baseText.value.productionUrl,
        value: "production"
      }
    ]);
    const visibleWebhookUrls = computed(() => {
      return webhooksNode.value.filter((webhook) => {
        if (typeof webhook.ndvHideUrl === "string") {
          return !workflowHelpers.getWebhookExpressionValue(webhook, "ndvHideUrl");
        }
        return !webhook.ndvHideUrl;
      });
    });
    const webhooksNode = computed(() => {
      var _a;
      if (((_a = props.nodeTypeDescription) == null ? void 0 : _a.webhooks) === void 0) {
        return [];
      }
      return props.nodeTypeDescription.webhooks.filter(
        (webhookData) => webhookData.restartWebhook !== true
      );
    });
    const baseText = computed(() => {
      var _a;
      const nodeType = (_a = props.nodeTypeDescription) == null ? void 0 : _a.name;
      switch (nodeType) {
        case CHAT_TRIGGER_NODE_TYPE:
          return {
            toggleTitle: i18n2.baseText("nodeWebhooks.webhookUrls.chatTrigger"),
            clickToDisplay: i18n2.baseText("nodeWebhooks.clickToDisplayWebhookUrls.formTrigger"),
            clickToHide: i18n2.baseText("nodeWebhooks.clickToHideWebhookUrls.chatTrigger"),
            clickToCopy: i18n2.baseText("nodeWebhooks.clickToCopyWebhookUrls.chatTrigger"),
            testUrl: i18n2.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n2.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n2.baseText("nodeWebhooks.showMessage.title.chatTrigger"),
            copyMessage: i18n2.baseText("nodeWebhooks.showMessage.message.chatTrigger")
          };
        case FORM_TRIGGER_NODE_TYPE:
          return {
            toggleTitle: i18n2.baseText("nodeWebhooks.webhookUrls.formTrigger"),
            clickToDisplay: i18n2.baseText("nodeWebhooks.clickToDisplayWebhookUrls.formTrigger"),
            clickToHide: i18n2.baseText("nodeWebhooks.clickToHideWebhookUrls.formTrigger"),
            clickToCopy: i18n2.baseText("nodeWebhooks.clickToCopyWebhookUrls.formTrigger"),
            testUrl: i18n2.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n2.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n2.baseText("nodeWebhooks.showMessage.title.formTrigger"),
            copyMessage: i18n2.baseText("nodeWebhooks.showMessage.message.formTrigger")
          };
        default:
          return {
            toggleTitle: i18n2.baseText("nodeWebhooks.webhookUrls"),
            clickToDisplay: i18n2.baseText("nodeWebhooks.clickToDisplayWebhookUrls"),
            clickToHide: i18n2.baseText("nodeWebhooks.clickToHideWebhookUrls"),
            clickToCopy: i18n2.baseText("nodeWebhooks.clickToCopyWebhookUrls"),
            testUrl: i18n2.baseText("nodeWebhooks.testUrl"),
            productionUrl: i18n2.baseText("nodeWebhooks.productionUrl"),
            copyTitle: i18n2.baseText("nodeWebhooks.showMessage.title"),
            copyMessage: void 0
          };
      }
    });
    function copyWebhookUrl(webhookData) {
      const webhookUrl = getWebhookUrlDisplay(webhookData);
      void clipboard.copy(webhookUrl);
      toast.showMessage({
        title: baseText.value.copyTitle,
        message: baseText.value.copyMessage,
        type: "success"
      });
      telemetry.track("User copied webhook URL", {
        pane: "parameters",
        type: `${showUrlFor.value} url`
      });
    }
    function getWebhookUrlDisplay(webhookData) {
      if (props.node) {
        return workflowHelpers.getWebhookUrl(
          webhookData,
          props.node,
          isProductionOnly.value ? "production" : showUrlFor.value
        );
      }
      return "";
    }
    function isWebhookMethodVisible(webhook) {
      try {
        const method = workflowHelpers.getWebhookExpressionValue(webhook, "httpMethod", false);
        if (Array.isArray(method) && method.length !== 1) {
          return false;
        }
      } catch (error2) {
      }
      if (typeof webhook.ndvHideMethod === "string") {
        return !workflowHelpers.getWebhookExpressionValue(webhook, "ndvHideMethod");
      }
      return !webhook.ndvHideMethod;
    }
    function getWebhookHttpMethod(webhook) {
      const method = workflowHelpers.getWebhookExpressionValue(webhook, "httpMethod", false);
      if (Array.isArray(method)) {
        return method[0];
      }
      return method;
    }
    watch(
      () => props.node,
      () => {
        isMinimized.value = props.nodeTypeDescription && !OPEN_URL_PANEL_TRIGGER_NODE_TYPES.includes(props.nodeTypeDescription.name);
      }
    );
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_radio_buttons = resolveComponent("n8n-radio-buttons");
      const _component_el_col = resolveComponent("el-col");
      const _component_el_row = resolveComponent("el-row");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _component_el_collapse_transition = resolveComponent("el-collapse-transition");
      return webhooksNode.value.length && visibleWebhookUrls.value.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_1$r, [
        createBaseVNode("div", {
          class: normalizeClass(["clickable headline", { expanded: !isMinimized.value }]),
          title: isMinimized.value ? baseText.value.clickToDisplay : baseText.value.clickToHide,
          onClick: _cache[0] || (_cache[0] = ($event) => isMinimized.value = !isMinimized.value)
        }, [
          createVNode(_component_font_awesome_icon, {
            icon: "angle-right",
            class: "minimize-button minimize-icon"
          }),
          createTextVNode(" " + toDisplayString(baseText.value.toggleTitle), 1)
        ], 10, _hoisted_2$i),
        createVNode(_component_el_collapse_transition, null, {
          default: withCtx(() => [
            !isMinimized.value ? (openBlock(), createElementBlock("div", _hoisted_3$f, [
              !isProductionOnly.value ? (openBlock(), createElementBlock("div", _hoisted_4$8, [
                createVNode(_component_el_row, null, {
                  default: withCtx(() => [
                    createVNode(_component_el_col, { span: 24 }, {
                      default: withCtx(() => [
                        createVNode(_component_n8n_radio_buttons, {
                          modelValue: showUrlFor.value,
                          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => showUrlFor.value = $event),
                          options: urlOptions.value
                        }, null, 8, ["modelValue", "options"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(visibleWebhookUrls.value, (webhook, index) => {
                return openBlock(), createBlock(_component_n8n_tooltip, {
                  key: index,
                  class: "item",
                  content: baseText.value.clickToCopy,
                  placement: "left"
                }, {
                  default: withCtx(() => [
                    isWebhookMethodVisible(webhook) ? (openBlock(), createElementBlock("div", _hoisted_5$7, [
                      createBaseVNode("div", _hoisted_6$7, [
                        createBaseVNode("div", _hoisted_7$5, [
                          createTextVNode(toDisplayString(getWebhookHttpMethod(webhook)), 1),
                          _cache[2] || (_cache[2] = createBaseVNode("br", null, null, -1))
                        ])
                      ]),
                      createBaseVNode("div", _hoisted_8$5, [
                        createBaseVNode("div", {
                          class: "webhook-url left-ellipsis clickable",
                          onClick: ($event) => copyWebhookUrl(webhook)
                        }, [
                          createTextVNode(toDisplayString(getWebhookUrlDisplay(webhook)), 1),
                          _cache[3] || (_cache[3] = createBaseVNode("br", null, null, -1))
                        ], 8, _hoisted_9$4)
                      ])
                    ])) : (openBlock(), createElementBlock("div", _hoisted_10$2, [
                      createBaseVNode("div", _hoisted_11$2, [
                        createBaseVNode("div", {
                          class: "webhook-url left-ellipsis clickable",
                          onClick: ($event) => copyWebhookUrl(webhook)
                        }, [
                          createTextVNode(toDisplayString(getWebhookUrlDisplay(webhook)), 1),
                          _cache[4] || (_cache[4] = createBaseVNode("br", null, null, -1))
                        ], 8, _hoisted_12$1)
                      ])
                    ]))
                  ]),
                  _: 2
                }, 1032, ["content"]);
              }), 128))
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ])) : createCommentVNode("", true);
    };
  }
});
const NodeWebhooks = /* @__PURE__ */ _export_sfc$1(_sfc_main$Y, [["__scopeId", "data-v-b6179980"]]);
const OnClickOutside = /* @__PURE__ */ defineComponent({
  name: "OnClickOutside",
  props: ["as", "options"],
  emits: ["trigger"],
  setup(props, { slots, emit }) {
    const target2 = ref();
    onClickOutside(target2, (e) => {
      emit("trigger", e);
    }, props.options);
    return () => {
      if (slots.default)
        return h(props.as || "div", { ref: target2 }, slots.default());
    };
  }
});
function unrefElement$1(elRef) {
  var _a;
  const plain = toValue$2(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow$1 = isClient$1 ? window : void 0;
function useEventListener$1(...args) {
  let target2;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target2 = defaultWindow$1;
  } else {
    [target2, events, listeners, options] = args;
  }
  if (!target2)
    return noop$4;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement$1(target2), toValue$2(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject$1(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(stop2);
  return stop2;
}
function resolveElement(el) {
  if (typeof Window !== "undefined" && el instanceof Window)
    return el.document.documentElement;
  if (typeof Document !== "undefined" && el instanceof Document)
    return el.documentElement;
  return el;
}
function checkOverflowScroll(ele) {
  const style = window.getComputedStyle(ele);
  if (style.overflowX === "scroll" || style.overflowY === "scroll" || style.overflowX === "auto" && ele.clientWidth < ele.scrollWidth || style.overflowY === "auto" && ele.clientHeight < ele.scrollHeight) {
    return true;
  } else {
    const parent = ele.parentNode;
    if (!parent || parent.tagName === "BODY")
      return false;
    return checkOverflowScroll(parent);
  }
}
function preventDefault(rawEvent) {
  const e = rawEvent || window.event;
  const _target = e.target;
  if (checkOverflowScroll(_target))
    return false;
  if (e.touches.length > 1)
    return true;
  if (e.preventDefault)
    e.preventDefault();
  return false;
}
const elInitialOverflow = /* @__PURE__ */ new WeakMap();
function useScrollLock(element, initialState = false) {
  const isLocked = ref(initialState);
  let stopTouchMoveListener = null;
  let initialOverflow = "";
  watch(toRef$1(element), (el) => {
    const target2 = resolveElement(toValue$2(el));
    if (target2) {
      const ele = target2;
      if (!elInitialOverflow.get(ele))
        elInitialOverflow.set(ele, ele.style.overflow);
      if (ele.style.overflow !== "hidden")
        initialOverflow = ele.style.overflow;
      if (ele.style.overflow === "hidden")
        return isLocked.value = true;
      if (isLocked.value)
        return ele.style.overflow = "hidden";
    }
  }, {
    immediate: true
  });
  const lock = () => {
    const el = resolveElement(toValue$2(element));
    if (!el || isLocked.value)
      return;
    if (isIOS) {
      stopTouchMoveListener = useEventListener$1(
        el,
        "touchmove",
        (e) => {
          preventDefault(e);
        },
        { passive: false }
      );
    }
    el.style.overflow = "hidden";
    isLocked.value = true;
  };
  const unlock = () => {
    const el = resolveElement(toValue$2(element));
    if (!el || !isLocked.value)
      return;
    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());
    el.style.overflow = initialOverflow;
    elInitialOverflow.delete(el);
    isLocked.value = false;
  };
  tryOnScopeDispose$1(unlock);
  return computed({
    get() {
      return isLocked.value;
    },
    set(v) {
      if (v)
        lock();
      else unlock();
    }
  });
}
function onScrollLock() {
  let isMounted = false;
  const state2 = ref(false);
  return (el, binding) => {
    state2.value = binding.value;
    if (isMounted)
      return;
    isMounted = true;
    const isLocked = useScrollLock(el, binding.value);
    watch(state2, (v) => isLocked.value = v);
  };
}
onScrollLock();
const _hoisted_1$q = ["data-test-id"];
const _hoisted_2$h = ["textContent"];
const _hoisted_3$e = ["onClick"];
const _hoisted_4$7 = ["onClick"];
const _hoisted_5$6 = ["data-node-name"];
const _hoisted_6$6 = ["onClick"];
const _sfc_main$X = /* @__PURE__ */ defineComponent({
  __name: "NDVSubConnections",
  props: {
    rootNode: {}
  },
  emits: ["switchSelectedNode", "openConnectionNodeCreator"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const nodeHelpers = useNodeHelpers();
    const { debounce } = useDebounce();
    const emit = __emit;
    const possibleConnections = ref([]);
    const expandedGroups = ref([]);
    const shouldShowNodeInputIssues = ref(false);
    const nodeType = computed(
      () => nodeTypesStore.getNodeType(props.rootNode.type, props.rootNode.typeVersion)
    );
    const nodeData = computed(() => workflowsStore.getNodeByName(props.rootNode.name));
    const workflow = computed(() => workflowsStore.getCurrentWorkflow());
    const nodeInputIssues = computed(() => {
      const issues2 = nodeHelpers.getNodeIssues(nodeType.value, props.rootNode, workflow.value, [
        "typeUnknown",
        "parameters",
        "credentials",
        "execution"
      ]);
      return (issues2 == null ? void 0 : issues2.input) ?? {};
    });
    const connectedNodes2 = computed(() => {
      return possibleConnections.value.reduce(
        (acc, connection) => {
          const nodes = getINodesFromNames(
            workflow.value.getParentNodes(props.rootNode.name, connection.type)
          );
          return { ...acc, [connection.type]: nodes };
        },
        {}
      );
    });
    function getConnectionConfig(connectionType2) {
      return possibleConnections.value.find((c) => c.type === connectionType2);
    }
    function isMultiConnection(connectionType2) {
      const connectionConfig = getConnectionConfig(connectionType2);
      return (connectionConfig == null ? void 0 : connectionConfig.maxConnections) !== 1;
    }
    function shouldShowConnectionTooltip(connectionType2) {
      return isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2);
    }
    function expandConnectionGroup(connectionType2, isExpanded) {
      if (!isMultiConnection(connectionType2)) {
        return;
      }
      if (isExpanded) {
        expandedGroups.value = [...expandedGroups.value, connectionType2];
      } else {
        expandedGroups.value = expandedGroups.value.filter((g) => g !== connectionType2);
      }
    }
    function getINodesFromNames(names) {
      return names.map((name) => {
        const node2 = workflowsStore.getNodeByName(name);
        if (node2) {
          const matchedNodeType = nodeTypesStore.getNodeType(node2.type);
          if (matchedNodeType) {
            const issues2 = nodeHelpers.getNodeIssues(matchedNodeType, node2, workflow.value);
            const stringifiedIssues = issues2 ? nodeIssuesToString(issues2, node2) : "";
            return { node: node2, nodeType: matchedNodeType, issues: stringifiedIssues };
          }
        }
        return null;
      }).filter((n) => n !== null);
    }
    function hasInputIssues(connectionType2) {
      return shouldShowNodeInputIssues.value && (nodeInputIssues.value[connectionType2] ?? []).length > 0;
    }
    function isNodeInputConfiguration(connectionConfig) {
      if (typeof connectionConfig === "string") return false;
      return "type" in connectionConfig;
    }
    function getPossibleSubInputConnections() {
      if (!nodeType.value || !props.rootNode) return [];
      const inputs2 = getNodeInputs(workflow.value, props.rootNode, nodeType.value);
      const nonMainInputs = inputs2.filter((input) => {
        if (!isNodeInputConfiguration(input)) return false;
        return input.type !== "main";
      });
      return nonMainInputs;
    }
    function onNodeClick(nodeName, connectionType2) {
      if (isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2)) {
        expandConnectionGroup(connectionType2, true);
        return;
      }
      emit("switchSelectedNode", nodeName);
    }
    function onPlusClick(connectionType2) {
      const connectionNodes = connectedNodes2.value[connectionType2];
      if (isMultiConnection(connectionType2) && !expandedGroups.value.includes(connectionType2) && connectionNodes.length >= 1) {
        expandConnectionGroup(connectionType2, true);
        return;
      }
      emit("openConnectionNodeCreator", props.rootNode.name, connectionType2);
    }
    function showNodeInputsIssues() {
      shouldShowNodeInputIssues.value = false;
      setTimeout(() => {
        shouldShowNodeInputIssues.value = true;
      }, 0);
    }
    watch(
      nodeData,
      debounce(
        () => setTimeout(() => {
          expandedGroups.value = [];
          possibleConnections.value = getPossibleSubInputConnections();
        }, 0),
        { debounceTime: 1e3 }
      ),
      { immediate: true }
    );
    __expose({
      showNodeInputsIssues
    });
    return (_ctx, _cache) => {
      const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(_ctx.$style.container)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.connections),
          style: normalizeStyle(`--possible-connections: ${possibleConnections.value.length}`)
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(possibleConnections.value, (connection) => {
            return openBlock(), createElementBlock("div", {
              key: connection.type,
              "data-test-id": `subnode-connection-group-${connection.type}`
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.connectionType)
              }, [
                createBaseVNode("span", {
                  class: normalizeClass({
                    [_ctx.$style.connectionLabel]: true,
                    [_ctx.$style.hasIssues]: hasInputIssues(connection.type)
                  }),
                  textContent: toDisplayString(`${connection.displayName}${connection.required ? " *" : ""}`)
                }, null, 10, _hoisted_2$h),
                createVNode(unref(OnClickOutside), {
                  onTrigger: ($event) => expandConnectionGroup(connection.type, false)
                }, {
                  default: withCtx(() => [
                    createBaseVNode("div", {
                      ref_for: true,
                      ref: "connectedNodesWrapper",
                      class: normalizeClass({
                        [_ctx.$style.connectedNodesWrapper]: true,
                        [_ctx.$style.connectedNodesWrapperExpanded]: expandedGroups.value.includes(connection.type)
                      }),
                      style: normalizeStyle(`--nodes-length: ${connectedNodes2.value[connection.type].length}`),
                      onClick: ($event) => expandConnectionGroup(connection.type, true)
                    }, [
                      (connectedNodes2.value[connection.type].length >= 1 ? connection.maxConnections !== 1 : true) ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: normalizeClass({
                          [_ctx.$style.plusButton]: true,
                          [_ctx.$style.hasIssues]: hasInputIssues(connection.type)
                        }),
                        onClick: ($event) => onPlusClick(connection.type)
                      }, [
                        createVNode(_component_n8n_tooltip, {
                          placement: "top",
                          teleported: true,
                          offset: 10,
                          "show-after": 300,
                          disabled: shouldShowConnectionTooltip(connection.type) && connectedNodes2.value[connection.type].length >= 1
                        }, {
                          content: withCtx(() => [
                            createTextVNode(" Add " + toDisplayString(connection.displayName) + " ", 1),
                            hasInputIssues(connection.type) ? (openBlock(), createBlock(TitledList, {
                              key: 0,
                              title: `${_ctx.$locale.baseText("node.issues")}:`,
                              items: nodeInputIssues.value[connection.type]
                            }, null, 8, ["title", "items"])) : createCommentVNode("", true)
                          ]),
                          default: withCtx(() => [
                            createVNode(_component_n8n_icon_button, {
                              size: "medium",
                              icon: "plus",
                              type: "tertiary",
                              "data-test-id": `add-subnode-${connection.type}`
                            }, null, 8, ["data-test-id"])
                          ]),
                          _: 2
                        }, 1032, ["disabled"])
                      ], 10, _hoisted_4$7)) : createCommentVNode("", true),
                      connectedNodes2.value[connection.type].length > 0 ? (openBlock(), createElementBlock("div", {
                        key: 1,
                        class: normalizeClass({
                          [_ctx.$style.connectedNodes]: true,
                          [_ctx.$style.connectedNodesMultiple]: connectedNodes2.value[connection.type].length > 1
                        })
                      }, [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(connectedNodes2.value[connection.type], (node2, index) => {
                          return openBlock(), createElementBlock("div", {
                            key: node2.node.name,
                            class: normalizeClass({ [_ctx.$style.nodeWrapper]: true, [_ctx.$style.hasIssues]: node2.issues }),
                            "data-test-id": "floating-subnode",
                            "data-node-name": node2.node.name,
                            style: normalizeStyle(`--node-index: ${index}`)
                          }, [
                            (openBlock(), createBlock(_component_n8n_tooltip, {
                              key: node2.node.name,
                              placement: "top",
                              teleported: true,
                              offset: 10,
                              "show-after": 300,
                              disabled: shouldShowConnectionTooltip(connection.type)
                            }, {
                              content: withCtx(() => [
                                createTextVNode(toDisplayString(node2.node.name) + " ", 1),
                                node2.issues ? (openBlock(), createBlock(TitledList, {
                                  key: 0,
                                  title: `${_ctx.$locale.baseText("node.issues")}:`,
                                  items: node2.issues
                                }, null, 8, ["title", "items"])) : createCommentVNode("", true)
                              ]),
                              default: withCtx(() => [
                                createBaseVNode("div", {
                                  class: normalizeClass(_ctx.$style.connectedNode),
                                  onClick: ($event) => onNodeClick(node2.node.name, connection.type)
                                }, [
                                  createVNode(_sfc_main$10, {
                                    "node-type": node2.nodeType,
                                    "node-name": node2.node.name,
                                    "tooltip-position": "top",
                                    size: 20,
                                    circle: ""
                                  }, null, 8, ["node-type", "node-name"])
                                ], 10, _hoisted_6$6)
                              ]),
                              _: 2
                            }, 1032, ["disabled"]))
                          ], 14, _hoisted_5$6);
                        }), 128))
                      ], 2)) : createCommentVNode("", true)
                    ], 14, _hoisted_3$e)
                  ]),
                  _: 2
                }, 1032, ["onTrigger"])
              ], 2)
            ], 8, _hoisted_1$q);
          }), 128))
        ], 6)
      ], 2);
    };
  }
});
const container$2 = "_container_tfxh3_18";
const connections = "_connections_tfxh3_26";
const connectionType = "_connectionType_tfxh3_38";
const connectionLabel = "_connectionLabel_tfxh3_45";
const hasIssues = "_hasIssues_tfxh3_51";
const connectedNodesWrapper = "_connectedNodesWrapper_tfxh3_55";
const plusButton = "_plusButton_tfxh3_63";
const connectedNodesWrapperExpanded = "_connectedNodesWrapperExpanded_tfxh3_81";
const connectedNodesMultiple = "_connectedNodesMultiple_tfxh3_87";
const connectedNode$1 = "_connectedNode_tfxh3_55";
const connectedNodes = "_connectedNodes_tfxh3_55";
const nodeWrapper = "_nodeWrapper_tfxh3_125";
const style0$y = {
  container: container$2,
  connections,
  connectionType,
  connectionLabel,
  hasIssues,
  connectedNodesWrapper,
  plusButton,
  "horizontal-shake": "_horizontal-shake_tfxh3_1",
  connectedNodesWrapperExpanded,
  connectedNodesMultiple,
  connectedNode: connectedNode$1,
  connectedNodes,
  nodeWrapper
};
const cssModules$A = {
  "$style": style0$y
};
const NDVSubConnections = /* @__PURE__ */ _export_sfc$1(_sfc_main$X, [["__cssModules", cssModules$A]]);
const NODE_TEST_STEP_POPUP_COUNT_KEY = "N8N_NODE_TEST_STEP_POPUP_COUNT";
const MAX_POPUP_COUNT = 10;
const POPUP_UPDATE_DELAY = 3e3;
const _sfc_main$W = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "NodeExecuteButton",
  props: {
    nodeName: {},
    telemetrySource: {},
    disabled: { type: Boolean, default: false },
    label: {},
    type: {},
    size: {},
    transparent: { type: Boolean, default: false },
    hideIcon: { type: Boolean },
    tooltip: {}
  },
  emits: ["stopExecution", "execute"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const lastPopupCountUpdate = ref(0);
    const router = useRouter();
    const { runWorkflow, runWorkflowResolvePending, stopCurrentExecution } = useRunWorkflow({ router });
    const workflowsStore = useWorkflowsStore();
    const externalHooks = useExternalHooks();
    const toast = useToast();
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const i18n2 = useI18n();
    const message = useMessage();
    const telemetry = useTelemetry();
    const node2 = computed(() => workflowsStore.getNodeByName(props.nodeName));
    const pinnedData2 = usePinnedData(node2);
    const nodeType = computed(() => {
      return node2.value ? nodeTypesStore.getNodeType(node2.value.type, node2.value.typeVersion) : null;
    });
    const isNodeRunning = computed(() => {
      var _a, _b;
      if (!uiStore.isActionActive["workflowRunning"]) return false;
      const triggeredNode = workflowsStore.executedNode;
      return workflowsStore.isNodeExecuting(((_a = node2.value) == null ? void 0 : _a.name) ?? "") || triggeredNode === ((_b = node2.value) == null ? void 0 : _b.name);
    });
    const isTriggerNode = computed(() => {
      return node2.value ? nodeTypesStore.isTriggerNode(node2.value.type) : false;
    });
    const isWorkflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const isManualTriggerNode = computed(
      () => nodeType.value ? nodeType.value.name === MANUAL_TRIGGER_NODE_TYPE : false
    );
    const isChatNode = computed(
      () => nodeType.value ? nodeType.value.name === CHAT_TRIGGER_NODE_TYPE : false
    );
    const isChatChild = computed(() => workflowsStore.checkIfNodeHasChatParent(props.nodeName));
    const isFormTriggerNode = computed(
      () => nodeType.value ? nodeType.value.name === FORM_TRIGGER_NODE_TYPE : false
    );
    const isPollingTypeNode = computed(() => {
      var _a;
      return !!((_a = nodeType.value) == null ? void 0 : _a.polling);
    });
    const isScheduleTrigger = computed(() => {
      var _a;
      return !!((_a = nodeType.value) == null ? void 0 : _a.group.includes("schedule"));
    });
    const isWebhookNode = computed(
      () => nodeType.value ? nodeType.value.name === WEBHOOK_NODE_TYPE : false
    );
    const isListeningForEvents = computed(() => {
      const waitingOnWebhook = workflowsStore.executionWaitingForWebhook;
      const executedNode = workflowsStore.executedNode;
      return !!node2.value && !node2.value.disabled && isTriggerNode.value && waitingOnWebhook && (!executedNode || executedNode === props.nodeName);
    });
    const isListeningForWorkflowEvents = computed(() => {
      return isNodeRunning.value && isTriggerNode.value && !isScheduleTrigger.value && !isManualTriggerNode.value;
    });
    const hasIssues2 = computed(
      () => {
        var _a;
        return Boolean(((_a = node2.value) == null ? void 0 : _a.issues) && (node2.value.issues.parameters || node2.value.issues.credentials));
      }
    );
    const disabledHint = computed(() => {
      var _a;
      if (isListeningForEvents.value) {
        return "";
      }
      if (isTriggerNode.value && ((_a = node2 == null ? void 0 : node2.value) == null ? void 0 : _a.disabled)) {
        return i18n2.baseText("ndv.execute.nodeIsDisabled");
      }
      if (isTriggerNode.value && hasIssues2.value) {
        const activeNode = ndvStore.activeNode;
        if (activeNode && activeNode.name !== props.nodeName) {
          return i18n2.baseText("ndv.execute.fixPrevious");
        }
        return i18n2.baseText("ndv.execute.requiredFieldsMissing");
      }
      if (isWorkflowRunning.value && !isNodeRunning.value) {
        return i18n2.baseText("ndv.execute.workflowAlreadyRunning");
      }
      return "";
    });
    const tooltipText = computed(() => {
      if (disabledHint.value) return disabledHint.value;
      if (props.tooltip && !isLoading.value && testStepButtonPopupCount() < MAX_POPUP_COUNT) {
        return props.tooltip;
      }
      return "";
    });
    const buttonLabel = computed(() => {
      var _a;
      if (isListeningForEvents.value || isListeningForWorkflowEvents.value) {
        return i18n2.baseText("ndv.execute.stopListening");
      }
      if (props.label) {
        return props.label;
      }
      if (isChatNode.value) {
        return i18n2.baseText("ndv.execute.testChat");
      }
      if (isWebhookNode.value) {
        return i18n2.baseText("ndv.execute.listenForTestEvent");
      }
      if (isFormTriggerNode.value) {
        return i18n2.baseText("ndv.execute.testStep");
      }
      if (isPollingTypeNode.value || ((_a = nodeType.value) == null ? void 0 : _a.mockManualExecution)) {
        return i18n2.baseText("ndv.execute.fetchEvent");
      }
      return i18n2.baseText("ndv.execute.testNode");
    });
    const isLoading = computed(
      () => isNodeRunning.value && !isListeningForEvents.value && !isListeningForWorkflowEvents.value
    );
    async function stopWaitingForWebhook() {
      try {
        await workflowsStore.removeTestWebhook(workflowsStore.workflowId);
      } catch (error2) {
        toast.showError(error2, "Error stopping webhook");
      }
    }
    function testStepButtonPopupCount() {
      return Number(localStorage.getItem(NODE_TEST_STEP_POPUP_COUNT_KEY));
    }
    function onMouseOver() {
      const count2 = testStepButtonPopupCount();
      if (count2 < MAX_POPUP_COUNT && !disabledHint.value && tooltipText.value) {
        const now2 = Date.now();
        if (!lastPopupCountUpdate.value || now2 - lastPopupCountUpdate.value >= POPUP_UPDATE_DELAY) {
          localStorage.setItem(NODE_TEST_STEP_POPUP_COUNT_KEY, `${count2 + 1}`);
          lastPopupCountUpdate.value = now2;
        }
      }
    }
    async function onClick() {
      if (isChatNode.value || isChatChild.value && ndvStore.isNDVDataEmpty("input")) {
        ndvStore.setActiveNodeName(null);
        nodeViewEventBus.emit("openChat");
      } else if (isListeningForEvents.value) {
        await stopWaitingForWebhook();
      } else if (isListeningForWorkflowEvents.value) {
        await stopCurrentExecution();
        emit("stopExecution");
      } else {
        let shouldUnpinAndExecute = false;
        if (pinnedData2.hasData.value) {
          const confirmResult = await message.confirm(
            i18n2.baseText("ndv.pinData.unpinAndExecute.description"),
            i18n2.baseText("ndv.pinData.unpinAndExecute.title"),
            {
              confirmButtonText: i18n2.baseText("ndv.pinData.unpinAndExecute.confirm"),
              cancelButtonText: i18n2.baseText("ndv.pinData.unpinAndExecute.cancel")
            }
          );
          shouldUnpinAndExecute = confirmResult === MODAL_CONFIRM;
          if (shouldUnpinAndExecute && node2.value) {
            pinnedData2.unsetData("unpin-and-execute-modal");
          }
        }
        if (!pinnedData2.hasData.value || shouldUnpinAndExecute) {
          const telemetryPayload = {
            node_type: nodeType.value ? nodeType.value.name : null,
            workflow_id: workflowsStore.workflowId,
            source: props.telemetrySource,
            push_ref: ndvStore.pushRef
          };
          telemetry.track("User clicked execute node button", telemetryPayload);
          await externalHooks.run("nodeExecuteButton.onClick", telemetryPayload);
          if (workflowsStore.isWaitingExecution) {
            await runWorkflowResolvePending({
              destinationNode: props.nodeName,
              source: "RunData.ExecuteNodeButton"
            });
          } else {
            await runWorkflow({
              destinationNode: props.nodeName,
              source: "RunData.ExecuteNodeButton"
            });
          }
          emit("execute");
        }
      }
    }
    return (_ctx, _cache) => {
      const _component_n8n_button = resolveComponent("n8n-button");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("div", null, [
        createVNode(_component_n8n_tooltip, {
          placement: "right",
          disabled: !tooltipText.value
        }, {
          content: withCtx(() => [
            createBaseVNode("div", null, toDisplayString(tooltipText.value), 1)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(_component_n8n_button, mergeProps(_ctx.$attrs, {
                loading: isLoading.value,
                disabled: _ctx.disabled || !!disabledHint.value,
                label: buttonLabel.value,
                type: _ctx.type,
                size: _ctx.size,
                icon: !isListeningForEvents.value && !_ctx.hideIcon ? "flask" : void 0,
                "transparent-background": _ctx.transparent,
                title: !isTriggerNode.value && !tooltipText.value ? unref(i18n2).baseText("ndv.execute.testNode.description") : "",
                onMouseover: onMouseOver,
                onClick
              }), null, 16, ["loading", "disabled", "label", "type", "size", "icon", "transparent-background", "title"])
            ])
          ]),
          _: 1
        }, 8, ["disabled"])
      ]);
    };
  }
});
const _hoisted_1$p = { class: "header-side-menu" };
const _hoisted_2$g = { key: 1 };
const _hoisted_3$d = {
  key: 0,
  class: "node-is-not-valid"
};
const _hoisted_4$6 = { class: "missingNodeTitleContainer mt-s mb-xs" };
const _hoisted_5$5 = { class: "mb-l" };
const _hoisted_6$5 = ["href"];
const _hoisted_7$4 = ["href", "textContent"];
const _hoisted_8$4 = {
  key: 1,
  class: "node-parameters-wrapper",
  "data-test-id": "node-parameters"
};
const _hoisted_9$3 = {
  key: 1,
  class: "no-parameters"
};
const _hoisted_10$1 = {
  key: 2,
  class: "parameter-item parameter-notice",
  "data-test-id": "node-parameters-http-notice"
};
const _hoisted_11$1 = {
  class: "node-version",
  "data-test-id": "node-version"
};
const _sfc_main$V = /* @__PURE__ */ defineComponent({
  __name: "NodeSettings",
  props: {
    eventBus: {},
    dragging: { type: Boolean },
    pushRef: {},
    nodeType: {},
    readOnly: { type: Boolean, default: false },
    foreignCredentials: { default: () => [] },
    blockUI: { type: Boolean, default: false },
    executable: { type: Boolean, default: true },
    inputSize: { default: 0 }
  },
  emits: ["stopExecution", "redrawRequired", "valueChanged", "switchSelectedNode", "openConnectionNodeCreator", "activate", "execute"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const workflowsStore = useWorkflowsStore();
    const credentialsStore = useCredentialsStore();
    const historyStore = useHistoryStore();
    const telemetry = useTelemetry();
    const nodeHelpers = useNodeHelpers();
    const externalHooks = useExternalHooks();
    const i18n2 = useI18n();
    const { showMessage } = useToast();
    const nodeValid = ref(true);
    const openPanel = ref("params");
    const nodeValues = ref({
      color: "#ff0000",
      alwaysOutputData: false,
      executeOnce: false,
      notesInFlow: false,
      onError: "stopWorkflow",
      retryOnFail: false,
      maxTries: 3,
      waitBetweenTries: 1e3,
      notes: "",
      parameters: {}
    });
    const nodeValuesInitialized = ref(false);
    const hiddenIssuesInputs = ref([]);
    const nodeSettings = ref([]);
    const subConnections = ref(null);
    const currentWorkflowInstance = computed(() => workflowsStore.getCurrentWorkflow());
    const currentWorkflow = computed(
      () => workflowsStore.getWorkflowById(currentWorkflowInstance.value.id)
    );
    const hasForeignCredential = computed(() => props.foreignCredentials.length > 0);
    const isHomeProjectTeam = computed(
      () => {
        var _a;
        return ((_a = currentWorkflow.value.homeProject) == null ? void 0 : _a.type) === ProjectTypes.Team;
      }
    );
    const isReadOnly = computed(
      () => props.readOnly || hasForeignCredential.value && !isHomeProjectTeam.value
    );
    const node2 = computed(() => ndvStore.activeNode);
    const isTriggerNode = computed(() => !!node2.value && nodeTypesStore.isTriggerNode(node2.value.type));
    const isExecutable = computed(() => {
      if (props.nodeType && node2.value) {
        const workflowNode = currentWorkflowInstance.value.getNode(node2.value.name);
        const inputs2 = getNodeInputs(
          currentWorkflowInstance.value,
          workflowNode,
          props.nodeType
        );
        const inputNames = getConnectionTypes(inputs2);
        if (!inputNames.includes(NodeConnectionType.Main) && !isTriggerNode.value) {
          return false;
        }
      }
      return props.executable || props.foreignCredentials.length > 0;
    });
    const nodeTypeVersions = computed(() => {
      if (!node2.value) return [];
      return nodeTypesStore.getNodeVersions(node2.value.type);
    });
    const latestVersion = computed(() => Math.max(...nodeTypeVersions.value));
    const isLatestNodeVersion = computed(
      () => {
        var _a;
        return !((_a = node2.value) == null ? void 0 : _a.typeVersion) || latestVersion.value === node2.value.typeVersion;
      }
    );
    const executeButtonTooltip = computed(() => {
      if (node2.value && isLatestNodeVersion.value && props.inputSize > 1 && !isSingleExecution(node2.value.type, node2.value.parameters)) {
        return i18n2.baseText("nodeSettings.executeButtonTooltip.times", {
          interpolate: { inputSize: props.inputSize }
        });
      }
      return "";
    });
    const nodeVersionTag = computed(() => {
      if (!props.nodeType || props.nodeType.hidden) {
        return i18n2.baseText("nodeSettings.deprecated");
      }
      if (isLatestNodeVersion.value) {
        return i18n2.baseText("nodeSettings.latest");
      }
      return i18n2.baseText("nodeSettings.latestVersion", {
        interpolate: { version: latestVersion.value.toString() }
      });
    });
    const parameters = computed(() => {
      var _a;
      if (props.nodeType === null) {
        return [];
      }
      return ((_a = props.nodeType) == null ? void 0 : _a.properties) ?? [];
    });
    const parametersSetting = computed(() => parameters.value.filter((item) => item.isNodeSetting));
    const parametersNoneSetting = computed(
      () => parameters.value.filter((item) => !item.isNodeSetting)
    );
    const outputPanelEditMode = computed(() => ndvStore.outputPanelEditMode);
    const isCommunityNode = computed(() => !!node2.value && isCommunityPackageName(node2.value.type));
    const usedCredentials = computed(
      () => Object.values(workflowsStore.usedCredentials).filter(
        (credential) => {
          var _a;
          return Object.values(((_a = node2.value) == null ? void 0 : _a.credentials) || []).find(
            (nodeCredential) => nodeCredential.id === credential.id
          );
        }
      )
    );
    const credentialOwnerName = computed(() => {
      const credential = usedCredentials.value ? Object.values(usedCredentials.value).find(
        (credential2) => credential2.id === props.foreignCredentials[0]
      ) : void 0;
      return credentialsStore.getCredentialOwnerName(credential);
    });
    const setValue = (name, value) => {
      const nameParts = name.split(".");
      let lastNamePart = nameParts.pop();
      let isArray = false;
      if (lastNamePart !== void 0 && lastNamePart.includes("[")) {
        const lastNameParts = lastNamePart.match(/(.*)\[(\d+)\]$/);
        if (lastNameParts) {
          nameParts.push(lastNameParts[1]);
          lastNamePart = lastNameParts[2];
          isArray = true;
        }
      }
      if (nameParts.length === 0) {
        if (value === null) {
          if (lastNamePart) {
            const { [lastNamePart]: removedNodeValue, ...remainingNodeValues } = nodeValues.value;
            nodeValues.value = remainingNodeValues;
          }
        } else {
          nodeValues.value = {
            ...nodeValues.value,
            [lastNamePart]: value
          };
        }
      } else {
        if (value === null) {
          let tempValue = get$4(nodeValues.value, nameParts.join("."));
          if (lastNamePart && !Array.isArray(tempValue)) {
            const { [lastNamePart]: removedNodeValue, ...remainingNodeValues } = tempValue;
            tempValue = remainingNodeValues;
          }
          if (isArray && Array.isArray(tempValue) && tempValue.length === 0) {
            lastNamePart = nameParts.pop();
            tempValue = get$4(nodeValues.value, nameParts.join("."));
            if (lastNamePart) {
              const { [lastNamePart]: removedArrayNodeValue, ...remainingArrayNodeValues } = tempValue;
              tempValue = remainingArrayNodeValues;
            }
          }
        } else {
          if (typeof value === "object") {
            set$4(
              get$4(nodeValues.value, nameParts.join(".")),
              lastNamePart,
              deepCopy(value)
            );
          } else {
            set$4(
              get$4(nodeValues.value, nameParts.join(".")),
              lastNamePart,
              value
            );
          }
        }
      }
      nodeValues.value = { ...nodeValues.value };
    };
    const removeMismatchedOptionValues = (nodeType, nodeParameterValues, updatedParameter) => {
      nodeType.properties.forEach((prop) => {
        var _a, _b;
        const displayOptions = prop.displayOptions;
        if (!(nodeParameterValues == null ? void 0 : nodeParameterValues.hasOwnProperty(prop.name)) || !displayOptions || !prop.options) {
          return;
        }
        const showCondition = (_a = displayOptions.show) == null ? void 0 : _a[updatedParameter.name];
        const hideCondition = (_b = displayOptions.hide) == null ? void 0 : _b[updatedParameter.name];
        if (showCondition === void 0 && hideCondition === void 0) {
          return;
        }
        let hasValidOptions = true;
        if (isINodePropertyCollectionList(prop.options) || isINodePropertiesList(prop.options)) {
          hasValidOptions = Object.keys(nodeParameterValues).every(
            (key) => (prop.options ?? []).find((option2) => option2.name === key) !== void 0
          );
        } else if (isINodePropertyOptionsList(prop.options)) {
          hasValidOptions = !!prop.options.find(
            (option2) => option2.value === nodeParameterValues[prop.name]
          );
        }
        if (!hasValidOptions && displayParameter(nodeParameterValues, prop, node2.value)) {
          unset(nodeParameterValues, prop.name);
        }
      });
    };
    const valueChanged = (parameterData) => {
      var _a, _b, _c;
      let newValue;
      if (parameterData.hasOwnProperty("value")) {
        newValue = parameterData.value;
      } else {
        newValue = get$4(nodeValues.value, parameterData.name);
      }
      const nodeNameBefore = parameterData.node || ((_a = node2.value) == null ? void 0 : _a.name);
      if (!nodeNameBefore) {
        return;
      }
      const _node = workflowsStore.getNodeByName(nodeNameBefore);
      if (_node === null) {
        return;
      }
      if (parameterData.name === "onError") {
        emit("redrawRequired");
      }
      if (parameterData.name === "name") {
        const sendData = {
          value: newValue,
          oldValue: nodeNameBefore,
          name: parameterData.name
        };
        emit("valueChanged", sendData);
      } else if (parameterData.name === "parameters") {
        const nodeType = nodeTypesStore.getNodeType(_node.type, _node.typeVersion);
        if (!nodeType) {
          return;
        }
        let nodeParameters = getNodeParameters(
          nodeType.properties,
          _node.parameters,
          false,
          false,
          _node
        );
        const oldNodeParameters = Object.assign({}, nodeParameters);
        nodeParameters = deepCopy(nodeParameters);
        if (parameterData.value && typeof parameterData.value === "object") {
          for (const parameterName of Object.keys(parameterData.value)) {
            newValue = parameterData.value[parameterName];
            const parameterPath = parameterName.split(".").slice(1).join(".");
            const parameterPathArray = parameterPath.match(/(.*)\[(\d+)\]$/);
            if (parameterData[parameterName] === void 0 && parameterPathArray !== null) {
              const path = parameterPathArray[1];
              const index = parameterPathArray[2];
              const data = get$4(nodeParameters, path);
              if (Array.isArray(data)) {
                data.splice(parseInt(index, 10), 1);
                set$4(nodeParameters, path, data);
              }
            } else {
              if (newValue === void 0) {
                unset(nodeParameters, parameterPath);
              } else {
                set$4(nodeParameters, parameterPath, newValue);
              }
            }
            void externalHooks.run("nodeSettings.valueChanged", {
              parameterPath,
              newValue,
              parameters: parameters.value,
              oldNodeParameters
            });
          }
        }
        nodeParameters = getNodeParameters(
          nodeType.properties,
          nodeParameters,
          true,
          false,
          _node
        );
        for (const key of Object.keys(nodeParameters)) {
          if (nodeParameters && nodeParameters[key] !== null && nodeParameters[key] !== void 0) {
            setValue(`parameters.${key}`, nodeParameters[key]);
          }
        }
        if (nodeParameters) {
          const updateInformation = {
            name: _node.name,
            value: nodeParameters
          };
          workflowsStore.setNodeParameters(updateInformation);
          nodeHelpers.updateNodeParameterIssuesByName(_node.name);
          nodeHelpers.updateNodeCredentialIssuesByName(_node.name);
        }
      } else if (parameterData.name.startsWith("parameters.")) {
        const nodeType = nodeTypesStore.getNodeType(_node.type, _node.typeVersion);
        if (!nodeType) {
          return;
        }
        if (parameterData.type && workflowsStore.nodeHasOutputConnection(_node.name) && ((_b = SHOULD_CLEAR_NODE_OUTPUTS[nodeType.name]) == null ? void 0 : _b.eventTypes.includes(parameterData.type)) && ((_c = SHOULD_CLEAR_NODE_OUTPUTS[nodeType.name]) == null ? void 0 : _c.parameterPaths.includes(parameterData.name))) {
          workflowsStore.removeAllNodeConnection(_node, { preserveInputConnections: true });
          showMessage({
            type: "warning",
            title: i18n2.baseText("nodeSettings.outputCleared.title"),
            message: i18n2.baseText("nodeSettings.outputCleared.message")
          });
        }
        let nodeParameters = getNodeParameters(
          nodeType.properties,
          _node.parameters,
          false,
          false,
          _node
        );
        const oldNodeParameters = Object.assign({}, nodeParameters);
        nodeParameters = deepCopy(nodeParameters);
        const parameterPath = parameterData.name.split(".").slice(1).join(".");
        const parameterPathArray = parameterPath.match(/(.*)\[(\d+)\]$/);
        if (parameterData.value === void 0 && parameterPathArray !== null) {
          const path = parameterPathArray[1];
          const index = parameterPathArray[2];
          const data = get$4(nodeParameters, path);
          if (Array.isArray(data)) {
            data.splice(parseInt(index, 10), 1);
            set$4(nodeParameters, path, data);
          }
        } else {
          if (newValue === void 0) {
            unset(nodeParameters, parameterPath);
          } else {
            set$4(nodeParameters, parameterPath, newValue);
          }
          removeMismatchedOptionValues(nodeType, nodeParameters, {
            name: parameterPath,
            value: newValue
          });
        }
        nodeParameters = getNodeParameters(
          nodeType.properties,
          nodeParameters,
          true,
          false,
          _node
        );
        for (const key of Object.keys(nodeParameters)) {
          if (nodeParameters && nodeParameters[key] !== null && nodeParameters[key] !== void 0) {
            setValue(`parameters.${key}`, nodeParameters[key]);
          }
        }
        const updateInformation = {
          name: _node.name,
          value: nodeParameters
        };
        workflowsStore.setNodeParameters(updateInformation);
        void externalHooks.run("nodeSettings.valueChanged", {
          parameterPath,
          newValue,
          parameters: parameters.value,
          oldNodeParameters
        });
        nodeHelpers.updateNodeParameterIssuesByName(_node.name);
        nodeHelpers.updateNodeCredentialIssuesByName(_node.name);
        telemetry.trackNodeParametersValuesChange(nodeType.name, parameterData);
      } else {
        nodeValues.value = {
          ...nodeValues.value,
          [parameterData.name]: newValue
        };
        const updateInformation = {
          name: _node.name,
          key: parameterData.name,
          value: newValue
        };
        workflowsStore.setNodeValue(updateInformation);
      }
    };
    const setHttpNodeParameters = (parameters2) => {
      var _a;
      try {
        valueChanged({
          node: (_a = node2.value) == null ? void 0 : _a.name,
          name: "parameters",
          value: parameters2
        });
      } catch {
      }
    };
    const onSwitchSelectedNode = (node22) => {
      emit("switchSelectedNode", node22);
    };
    const onOpenConnectionNodeCreator = (nodeName, connectionType2) => {
      emit("openConnectionNodeCreator", nodeName, connectionType2);
    };
    const populateHiddenIssuesSet = () => {
      if (!node2.value || !workflowsStore.isNodePristine(node2.value.name)) return;
      hiddenIssuesInputs.value.push("credentials");
      parametersNoneSetting.value.forEach((parameter) => {
        hiddenIssuesInputs.value.push(parameter.name);
      });
      workflowsStore.setNodePristine(node2.value.name, false);
    };
    const populateSettings = () => {
      if (isExecutable.value && !isTriggerNode.value) {
        nodeSettings.value.push(
          ...[
            {
              displayName: i18n2.baseText("nodeSettings.alwaysOutputData.displayName"),
              name: "alwaysOutputData",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n2.baseText("nodeSettings.alwaysOutputData.description")
            },
            {
              displayName: i18n2.baseText("nodeSettings.executeOnce.displayName"),
              name: "executeOnce",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n2.baseText("nodeSettings.executeOnce.description")
            },
            {
              displayName: i18n2.baseText("nodeSettings.retryOnFail.displayName"),
              name: "retryOnFail",
              type: "boolean",
              default: false,
              noDataExpression: true,
              description: i18n2.baseText("nodeSettings.retryOnFail.description")
            },
            {
              displayName: i18n2.baseText("nodeSettings.maxTries.displayName"),
              name: "maxTries",
              type: "number",
              typeOptions: {
                minValue: 2,
                maxValue: 5
              },
              default: 3,
              displayOptions: {
                show: {
                  retryOnFail: [true]
                }
              },
              noDataExpression: true,
              description: i18n2.baseText("nodeSettings.maxTries.description")
            },
            {
              displayName: i18n2.baseText("nodeSettings.waitBetweenTries.displayName"),
              name: "waitBetweenTries",
              type: "number",
              typeOptions: {
                minValue: 0,
                maxValue: 5e3
              },
              default: 1e3,
              displayOptions: {
                show: {
                  retryOnFail: [true]
                }
              },
              noDataExpression: true,
              description: i18n2.baseText("nodeSettings.waitBetweenTries.description")
            },
            {
              displayName: i18n2.baseText("nodeSettings.onError.displayName"),
              name: "onError",
              type: "options",
              options: [
                {
                  name: i18n2.baseText("nodeSettings.onError.options.stopWorkflow.displayName"),
                  value: "stopWorkflow",
                  description: i18n2.baseText("nodeSettings.onError.options.stopWorkflow.description")
                },
                {
                  name: i18n2.baseText("nodeSettings.onError.options.continueRegularOutput.displayName"),
                  value: "continueRegularOutput",
                  description: i18n2.baseText(
                    "nodeSettings.onError.options.continueRegularOutput.description"
                  )
                },
                {
                  name: i18n2.baseText("nodeSettings.onError.options.continueErrorOutput.displayName"),
                  value: "continueErrorOutput",
                  description: i18n2.baseText(
                    "nodeSettings.onError.options.continueErrorOutput.description"
                  )
                }
              ],
              default: "stopWorkflow",
              noDataExpression: i18n2.baseText("nodeSettings.onError.description")
            }
          ]
        );
      }
      nodeSettings.value.push(
        ...[
          {
            displayName: i18n2.baseText("nodeSettings.notes.displayName"),
            name: "notes",
            type: "string",
            typeOptions: {
              rows: 5
            },
            default: "",
            noDataExpression: true,
            description: i18n2.baseText("nodeSettings.notes.description")
          },
          {
            displayName: i18n2.baseText("nodeSettings.notesInFlow.displayName"),
            name: "notesInFlow",
            type: "boolean",
            default: false,
            noDataExpression: true,
            description: i18n2.baseText("nodeSettings.notesInFlow.description")
          }
        ]
      );
    };
    const onParameterBlur = (parameterName) => {
      hiddenIssuesInputs.value = hiddenIssuesInputs.value.filter((name) => name !== parameterName);
    };
    const onWorkflowActivate = () => {
      hiddenIssuesInputs.value = [];
      emit("activate");
    };
    const onNodeExecute = () => {
      var _a;
      hiddenIssuesInputs.value = [];
      (_a = subConnections.value) == null ? void 0 : _a.showNodeInputsIssues();
      emit("execute");
    };
    const credentialSelected = (updateInformation) => {
      workflowsStore.updateNodeProperties(updateInformation);
      const node22 = workflowsStore.getNodeByName(updateInformation.name);
      if (node22) {
        nodeHelpers.updateNodeCredentialIssues(node22);
      }
      void externalHooks.run("nodeSettings.credentialSelected", { updateInformation });
    };
    const nameChanged = (name) => {
      if (node2.value) {
        historyStore.pushCommandToUndo(new RenameNodeCommand(node2.value.name, name));
      }
      valueChanged({
        value: name,
        name: "name"
      });
    };
    const setNodeValues = () => {
      if (!node2.value) {
        nodeValuesInitialized.value = true;
        return;
      }
      if (props.nodeType !== null) {
        nodeValid.value = true;
        const foundNodeSettings = [];
        if (node2.value.color) {
          foundNodeSettings.push("color");
          nodeValues.value = {
            ...nodeValues.value,
            color: node2.value.color
          };
        }
        if (node2.value.notes) {
          foundNodeSettings.push("notes");
          nodeValues.value = {
            ...nodeValues.value,
            notes: node2.value.notes
          };
        }
        if (node2.value.alwaysOutputData) {
          foundNodeSettings.push("alwaysOutputData");
          nodeValues.value = {
            ...nodeValues.value,
            alwaysOutputData: node2.value.alwaysOutputData
          };
        }
        if (node2.value.executeOnce) {
          foundNodeSettings.push("executeOnce");
          nodeValues.value = {
            ...nodeValues.value,
            executeOnce: node2.value.executeOnce
          };
        }
        if (node2.value.continueOnFail) {
          foundNodeSettings.push("onError");
          nodeValues.value = {
            ...nodeValues.value,
            onError: "continueRegularOutput"
          };
        }
        if (node2.value.onError) {
          foundNodeSettings.push("onError");
          nodeValues.value = {
            ...nodeValues.value,
            onError: node2.value.onError
          };
        }
        if (node2.value.notesInFlow) {
          foundNodeSettings.push("notesInFlow");
          nodeValues.value = {
            ...nodeValues.value,
            notesInFlow: node2.value.notesInFlow
          };
        }
        if (node2.value.retryOnFail) {
          foundNodeSettings.push("retryOnFail");
          nodeValues.value = {
            ...nodeValues.value,
            retryOnFail: node2.value.retryOnFail
          };
        }
        if (node2.value.maxTries) {
          foundNodeSettings.push("maxTries");
          nodeValues.value = {
            ...nodeValues.value,
            maxTries: node2.value.maxTries
          };
        }
        if (node2.value.waitBetweenTries) {
          foundNodeSettings.push("waitBetweenTries");
          nodeValues.value = {
            ...nodeValues.value,
            waitBetweenTries: node2.value.waitBetweenTries
          };
        }
        for (const nodeSetting of nodeSettings.value) {
          if (!foundNodeSettings.includes(nodeSetting.name)) {
            nodeValues.value = {
              ...nodeValues.value,
              [nodeSetting.name]: nodeSetting.default
            };
          }
        }
        nodeValues.value = {
          ...nodeValues.value,
          parameters: deepCopy(node2.value.parameters)
        };
      } else {
        nodeValid.value = false;
      }
      nodeValuesInitialized.value = true;
    };
    const onMissingNodeTextClick = (event) => {
      if (event.target.localName === "a") {
        telemetry.track("user clicked cnr browse button", {
          source: "cnr missing node modal"
        });
      }
    };
    const onMissingNodeLearnMoreLinkClick = () => {
      var _a, _b;
      telemetry.track("user clicked cnr docs link", {
        source: "missing node modal source",
        package_name: (_a = node2.value) == null ? void 0 : _a.type.split(".")[0],
        node_type: (_b = node2.value) == null ? void 0 : _b.type
      });
    };
    const onStopExecution = () => {
      emit("stopExecution");
    };
    const openSettings = () => {
      openPanel.value = "settings";
    };
    const onTabSelect = (tab) => {
      openPanel.value = tab;
    };
    watch(node2, () => {
      setNodeValues();
    });
    onMounted(() => {
      var _a;
      populateHiddenIssuesSet();
      populateSettings();
      setNodeValues();
      (_a = props.eventBus) == null ? void 0 : _a.on("openSettings", openSettings);
      nodeHelpers.updateNodeParameterIssues(node2.value, props.nodeType);
      importCurlEventBus.on("setHttpNodeParameters", setHttpNodeParameters);
      ndvEventBus.on("updateParameterValue", valueChanged);
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = props.eventBus) == null ? void 0 : _a.off("openSettings", openSettings);
      importCurlEventBus.off("setHttpNodeParameters", setHttpNodeParameters);
      ndvEventBus.off("updateParameterValue", valueChanged);
    });
    return (_ctx, _cache) => {
      var _a, _b;
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_i18n_t = resolveComponent("i18n-t");
      const _component_n8n_link = resolveComponent("n8n-link");
      const _component_n8n_notice = resolveComponent("n8n-notice");
      const _component_n8n_block_ui = resolveComponent("n8n-block-ui");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({
          "node-settings": true,
          dragging: _ctx.dragging
        }),
        onKeydown: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"]))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.header)
        }, [
          createBaseVNode("div", _hoisted_1$p, [
            node2.value ? (openBlock(), createBlock(NodeTitle, {
              key: 0,
              class: "node-name",
              "model-value": node2.value.name,
              "node-type": _ctx.nodeType,
              "read-only": isReadOnly.value,
              "onUpdate:modelValue": nameChanged
            }, null, 8, ["model-value", "node-type", "read-only"])) : createCommentVNode("", true),
            isExecutable.value ? (openBlock(), createElementBlock("div", _hoisted_2$g, [
              !_ctx.blockUI && node2.value && nodeValid.value ? (openBlock(), createBlock(_sfc_main$W, {
                key: 0,
                "data-test-id": "node-execute-button",
                "node-name": node2.value.name,
                disabled: outputPanelEditMode.value.enabled && !isTriggerNode.value,
                tooltip: executeButtonTooltip.value,
                size: "small",
                "telemetry-source": "parameters",
                onExecute: onNodeExecute,
                onStopExecution
              }, null, 8, ["node-name", "disabled", "tooltip"])) : createCommentVNode("", true)
            ])) : createCommentVNode("", true)
          ]),
          node2.value && nodeValid.value ? (openBlock(), createBlock(_sfc_main$Z, {
            key: 0,
            "model-value": openPanel.value,
            "node-type": _ctx.nodeType,
            "push-ref": _ctx.pushRef,
            "onUpdate:modelValue": onTabSelect
          }, null, 8, ["model-value", "node-type", "push-ref"])) : createCommentVNode("", true)
        ], 2),
        node2.value && !nodeValid.value ? (openBlock(), createElementBlock("div", _hoisted_3$d, [
          createBaseVNode("p", {
            class: normalizeClass(_ctx.$style.warningIcon)
          }, [
            createVNode(_component_font_awesome_icon, { icon: "exclamation-triangle" })
          ], 2),
          createBaseVNode("div", _hoisted_4$6, [
            createVNode(_component_n8n_text, {
              size: "large",
              color: "text-dark",
              bold: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeSettings.communityNodeUnknown.title")), 1)
              ]),
              _: 1
            })
          ]),
          isCommunityNode.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.$style.descriptionContainer)
          }, [
            createBaseVNode("div", _hoisted_5$5, [
              createVNode(_component_i18n_t, {
                keypath: "nodeSettings.communityNodeUnknown.description",
                tag: "span",
                onClick: onMissingNodeTextClick
              }, {
                action: withCtx(() => [
                  createBaseVNode("a", {
                    href: `https://www.npmjs.com/package/${node2.value.type.split(".")[0]}`,
                    target: "_blank"
                  }, toDisplayString(node2.value.type.split(".")[0]), 9, _hoisted_6$5)
                ]),
                _: 1
              })
            ]),
            createVNode(_component_n8n_link, {
              to: unref(COMMUNITY_NODES_INSTALLATION_DOCS_URL),
              onClick: onMissingNodeLearnMoreLinkClick
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeSettings.communityNodeUnknown.installLink.text")), 1)
              ]),
              _: 1
            }, 8, ["to"])
          ], 2)) : (openBlock(), createBlock(_component_i18n_t, {
            key: 1,
            keypath: "nodeSettings.nodeTypeUnknown.description",
            tag: "span"
          }, {
            action: withCtx(() => [
              createBaseVNode("a", {
                href: unref(CUSTOM_NODES_DOCS_URL),
                target: "_blank",
                textContent: toDisplayString(_ctx.$locale.baseText("nodeSettings.nodeTypeUnknown.description.customNode"))
              }, null, 8, _hoisted_7$4)
            ]),
            _: 1
          }))
        ])) : createCommentVNode("", true),
        node2.value && nodeValid.value ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
          hasForeignCredential.value && !isHomeProjectTeam.value ? (openBlock(), createBlock(_component_n8n_notice, {
            key: 0,
            content: _ctx.$locale.baseText("nodeSettings.hasForeignCredential", {
              interpolate: { owner: credentialOwnerName.value }
            })
          }, null, 8, ["content"])) : createCommentVNode("", true),
          withDirectives(createBaseVNode("div", null, [
            createVNode(NodeWebhooks, {
              node: node2.value,
              "node-type-description": _ctx.nodeType
            }, null, 8, ["node", "node-type-description"]),
            nodeValuesInitialized.value ? (openBlock(), createBlock(_sfc_main$11, {
              key: 0,
              parameters: parametersNoneSetting.value,
              "hide-delete": true,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "parameters",
              onValueChanged: valueChanged,
              onActivate: onWorkflowActivate,
              onParameterBlur
            }, {
              default: withCtx(() => [
                createVNode(NodeCredentials, {
                  node: node2.value,
                  readonly: isReadOnly.value,
                  "show-all": true,
                  "hide-issues": hiddenIssuesInputs.value.includes("credentials"),
                  onCredentialSelected: credentialSelected,
                  onValueChanged: valueChanged,
                  onBlur: onParameterBlur
                }, null, 8, ["node", "readonly", "hide-issues"])
              ]),
              _: 1
            }, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"])) : createCommentVNode("", true),
            parametersNoneSetting.value.length === 0 ? (openBlock(), createElementBlock("div", _hoisted_9$3, [
              createVNode(_component_n8n_text, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeSettings.thisNodeDoesNotHaveAnyParameters")), 1)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            unref(nodeHelpers).isCustomApiCallSelected(nodeValues.value) ? (openBlock(), createElementBlock("div", _hoisted_10$1, [
              createVNode(_component_n8n_notice, {
                content: _ctx.$locale.baseText("nodeSettings.useTheHttpRequestNode", {
                  interpolate: { nodeTypeDisplayName: ((_a = _ctx.nodeType) == null ? void 0 : _a.displayName) ?? "" }
                })
              }, null, 8, ["content"])
            ])) : createCommentVNode("", true)
          ], 512), [
            [vShow, openPanel.value === "params"]
          ]),
          withDirectives(createBaseVNode("div", null, [
            createVNode(_sfc_main$11, {
              parameters: parametersSetting.value,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hide-delete": true,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "parameters",
              onValueChanged: valueChanged,
              onParameterBlur
            }, null, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"]),
            createVNode(_sfc_main$11, {
              parameters: nodeSettings.value,
              "hide-delete": true,
              "node-values": nodeValues.value,
              "is-read-only": isReadOnly.value,
              "hidden-issues-inputs": hiddenIssuesInputs.value,
              path: "",
              onValueChanged: valueChanged,
              onParameterBlur
            }, null, 8, ["parameters", "node-values", "is-read-only", "hidden-issues-inputs"]),
            createBaseVNode("div", _hoisted_11$1, [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeSettings.nodeVersion", {
                interpolate: {
                  node: (_b = _ctx.nodeType) == null ? void 0 : _b.displayName,
                  version: (node2.value.typeVersion ?? latestVersion.value).toString()
                }
              })) + " ", 1),
              createBaseVNode("span", null, "(" + toDisplayString(nodeVersionTag.value) + ")", 1)
            ])
          ], 512), [
            [vShow, openPanel.value === "settings"]
          ])
        ])) : createCommentVNode("", true),
        node2.value ? (openBlock(), createBlock(NDVSubConnections, {
          key: 2,
          ref_key: "subConnections",
          ref: subConnections,
          "root-node": node2.value,
          onSwitchSelectedNode,
          onOpenConnectionNodeCreator
        }, null, 8, ["root-node"])) : createCommentVNode("", true),
        createVNode(_component_n8n_block_ui, { show: _ctx.blockUI }, null, 8, ["show"])
      ], 34);
    };
  }
});
const header$2 = "_header_1pn0y_1";
const warningIcon = "_warningIcon_1pn0y_5";
const descriptionContainer = "_descriptionContainer_1pn0y_10";
const style0$x = {
  header: header$2,
  warningIcon,
  descriptionContainer
};
const cssModules$z = {
  "$style": style0$x
};
const NodeSettings = /* @__PURE__ */ _export_sfc$1(_sfc_main$V, [["__cssModules", cssModules$z], ["__scopeId", "data-v-08ca8efa"]]);
const _sfc_main$U = defineComponent({
  components: {
    Draggable
  },
  props: {
    canMoveRight: {
      type: Boolean
    },
    canMoveLeft: {
      type: Boolean
    }
  },
  methods: {
    onDrag(e) {
      this.$emit("drag", e);
    },
    onDragStart() {
      this.$emit("dragstart");
    },
    onDragEnd() {
      this.$emit("dragend");
    }
  }
});
const dragContainer = "_dragContainer_1fum9_1";
const dragButton = "_dragButton_1fum9_5";
const leftArrow = "_leftArrow_1fum9_19 _arrow_1fum9_28";
const rightArrow = "_rightArrow_1fum9_20 _arrow_1fum9_28";
const visible$1 = "_visible_1fum9_24";
const arrow = "_arrow_1fum9_28";
const grid = "_grid_1fum9_46";
const style0$w = {
  dragContainer,
  dragButton,
  leftArrow,
  rightArrow,
  visible: visible$1,
  arrow,
  grid
};
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
  const _component_Draggable = Draggable;
  return openBlock(), createBlock(_component_Draggable, {
    type: "panel-resize",
    class: normalizeClass(_ctx.$style.dragContainer),
    onDrag: _ctx.onDrag,
    onDragstart: _ctx.onDragStart,
    onDragend: _ctx.onDragEnd
  }, {
    default: withCtx(({ isDragging }) => [
      createBaseVNode("div", {
        class: normalizeClass({ [_ctx.$style.dragButton]: true })
      }, [
        _ctx.canMoveLeft ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass({ [_ctx.$style.leftArrow]: true, [_ctx.$style.visible]: isDragging })
        }, [
          createVNode(_component_font_awesome_icon, { icon: "arrow-left" })
        ], 2)) : createCommentVNode("", true),
        _ctx.canMoveRight ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: normalizeClass({ [_ctx.$style.rightArrow]: true, [_ctx.$style.visible]: isDragging })
        }, [
          createVNode(_component_font_awesome_icon, { icon: "arrow-right" })
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.grid)
        }, _cache[0] || (_cache[0] = [
          createBaseVNode("div", null, [
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div")
          ], -1),
          createBaseVNode("div", null, [
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div"),
            createBaseVNode("div")
          ], -1)
        ]), 2)
      ], 2)
    ]),
    _: 1
  }, 8, ["class", "onDrag", "onDragstart", "onDragend"]);
}
const cssModules$y = {
  "$style": style0$w
};
const PanelDragButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$U, [["render", _sfc_render$8], ["__cssModules", cssModules$y]]);
const _hoisted_1$o = ["data-node-name", "data-node-placement", "onClick"];
const _sfc_main$T = /* @__PURE__ */ defineComponent({
  __name: "NDVFloatingNodes",
  props: {
    rootNode: {}
  },
  emits: ["switchSelectedNode"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const workflow = workflowsStore.getCurrentWorkflow();
    const emit = __emit;
    function moveNodeDirection(direction) {
      const matchedDirectionNode = connectedNodes2.value[direction][0];
      if (matchedDirectionNode) {
        emit("switchSelectedNode", matchedDirectionNode.node.name);
      }
    }
    function onKeyDown2(e) {
      if (e.shiftKey && e.altKey && (e.ctrlKey || e.metaKey)) {
        const mapper = {
          ArrowUp: "outputSub",
          ArrowRight: "outputMain",
          ArrowLeft: "inputMain"
          /* left */
        };
        const matchingDirection = mapper[e.key] || null;
        if (matchingDirection) {
          moveNodeDirection(matchingDirection);
        }
      }
    }
    function getINodesFromNames(names) {
      return names.map((name) => {
        const node2 = workflowsStore.getNodeByName(name);
        if (node2) {
          const nodeType = nodeTypesStore.getNodeType(node2.type);
          if (nodeType) {
            return { node: node2, nodeType };
          }
        }
        return null;
      }).filter((n) => n !== null);
    }
    const connectedNodes2 = computed(() => {
      const rootName = props.rootNode.name;
      return {
        [
          "outputSub"
          /* top */
        ]: getINodesFromNames(
          workflow.getChildNodes(rootName, "ALL_NON_MAIN")
        ),
        [
          "outputMain"
          /* right */
        ]: getINodesFromNames(
          workflow.getChildNodes(rootName, NodeConnectionType.Main, 1)
        ),
        [
          "inputMain"
          /* left */
        ]: getINodesFromNames(
          workflow.getParentNodes(rootName, NodeConnectionType.Main, 1)
        )
      };
    });
    const connectionGroups = [
      "outputSub",
      "outputMain",
      "inputMain"
      /* left */
    ];
    const tooltipPositionMapper = {
      [
        "outputSub"
        /* top */
      ]: "bottom",
      [
        "outputMain"
        /* right */
      ]: "left",
      [
        "inputMain"
        /* left */
      ]: "right"
    };
    onMounted(() => {
      document.addEventListener("keydown", onKeyDown2, true);
    });
    onBeforeUnmount(() => {
      document.removeEventListener("keydown", onKeyDown2, true);
    });
    __expose({
      moveNodeDirection
    });
    return (_ctx, _cache) => {
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("aside", {
        class: normalizeClass(_ctx.$style.floatingNodes)
      }, [
        (openBlock(), createElementBlock(Fragment, null, renderList(connectionGroups, (connectionGroup) => {
          return createBaseVNode("ul", {
            key: connectionGroup,
            class: normalizeClass([_ctx.$style.nodesList, _ctx.$style[connectionGroup]])
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(connectedNodes2.value[connectionGroup], ({ node: node2, nodeType }) => {
              return openBlock(), createElementBlock(Fragment, null, [
                node2 && nodeType ? (openBlock(), createBlock(_component_n8n_tooltip, {
                  key: node2.name,
                  placement: tooltipPositionMapper[connectionGroup],
                  teleported: false,
                  offset: 60
                }, {
                  content: withCtx(() => [
                    createTextVNode(toDisplayString(node2.name), 1)
                  ]),
                  default: withCtx(() => [
                    createBaseVNode("li", {
                      class: normalizeClass(_ctx.$style.connectedNode),
                      "data-test-id": "floating-node",
                      "data-node-name": node2.name,
                      "data-node-placement": connectionGroup,
                      onClick: ($event) => emit("switchSelectedNode", node2.name)
                    }, [
                      createVNode(_sfc_main$10, {
                        "node-type": nodeType,
                        "node-name": node2.name,
                        "tooltip-position": tooltipPositionMapper[connectionGroup],
                        size: 35,
                        circle: ""
                      }, null, 8, ["node-type", "node-name", "tooltip-position"])
                    ], 10, _hoisted_1$o)
                  ]),
                  _: 2
                }, 1032, ["placement"])) : createCommentVNode("", true)
              ], 64);
            }), 256))
          ], 2);
        }), 64))
      ], 2);
    };
  }
});
const floatingNodes = "_floatingNodes_468qc_1";
const nodesList = "_nodesList_468qc_15";
const inputSub = "_inputSub_468qc_29";
const outputSub = "_outputSub_468qc_29";
const outputMain = "_outputMain_468qc_40";
const inputMain = "_inputMain_468qc_40";
const connectedNode = "_connectedNode_468qc_63";
const style0$v = {
  floatingNodes,
  nodesList,
  inputSub,
  outputSub,
  outputMain,
  inputMain,
  connectedNode
};
const cssModules$x = {
  "$style": style0$v
};
const NDVFloatingNodes = /* @__PURE__ */ _export_sfc$1(_sfc_main$T, [["__cssModules", cssModules$x]]);
const SIDE_MARGIN = 24;
const SIDE_PANELS_MARGIN = 80;
const MIN_PANEL_WIDTH = 310;
const PANEL_WIDTH = 350;
const PANEL_WIDTH_LARGE = 420;
const _sfc_main$S = /* @__PURE__ */ defineComponent({
  __name: "NDVDraggablePanels",
  props: {
    isDraggable: { type: Boolean },
    hideInputAndOutput: { type: Boolean },
    nodeType: {}
  },
  emits: ["init", "dragstart", "dragend", "switchSelectedNode", "close"],
  setup(__props, { emit: __emit }) {
    const MIN_WINDOW_WIDTH = 2 * (SIDE_MARGIN + SIDE_PANELS_MARGIN) + MIN_PANEL_WIDTH;
    const initialMainPanelWidth = {
      regular: MAIN_NODE_PANEL_WIDTH,
      dragless: MAIN_NODE_PANEL_WIDTH,
      unknown: MAIN_NODE_PANEL_WIDTH,
      inputless: MAIN_NODE_PANEL_WIDTH,
      wide: MAIN_NODE_PANEL_WIDTH * 2
    };
    const { callDebounced } = useDebounce();
    const ndvStore = useNDVStore();
    const uiStore = useUIStore();
    const props = __props;
    const isDragging = ref(false);
    const initialized = ref(false);
    const emit = __emit;
    const slots = useSlots();
    onMounted(() => {
      if (mainPanelDimensions.value.relativeLeft === 1 && mainPanelDimensions.value.relativeRight === 1) {
        setMainPanelWidth();
        setPositions(getInitialLeftPosition(mainPanelDimensions.value.relativeWidth));
        restorePositionData();
      }
      emit("init", { position: mainPanelDimensions.value.relativeLeft });
      setTimeout(() => {
        initialized.value = true;
      }, 0);
      ndvEventBus.on("setPositionByName", setPositionByName);
    });
    onBeforeUnmount(() => {
      ndvEventBus.off("setPositionByName", setPositionByName);
    });
    const containerWidth = computed(() => uiStore.appGridWidth);
    watch(containerWidth, (width) => {
      const minRelativeWidth = pxToRelativeWidth(MIN_PANEL_WIDTH);
      const isBelowMinWidthMainPanel = mainPanelDimensions.value.relativeWidth < minRelativeWidth;
      if (isBelowMinWidthMainPanel) {
        setMainPanelWidth(minRelativeWidth);
      }
      const isBelowMinLeft = minimumLeftPosition.value > mainPanelDimensions.value.relativeLeft;
      const isMaxRight = maximumRightPosition.value > mainPanelDimensions.value.relativeRight;
      if (width > MIN_WINDOW_WIDTH && isBelowMinLeft && isMaxRight) {
        setMainPanelWidth(minRelativeWidth);
        setPositions(getInitialLeftPosition(mainPanelDimensions.value.relativeWidth));
      }
      setPositions(mainPanelDimensions.value.relativeLeft);
    });
    const currentNodePaneType = computed(() => {
      if (!hasInputSlot.value) return "inputless";
      if (!props.isDraggable) return "dragless";
      if (props.nodeType === null) return "unknown";
      return props.nodeType.parameterPane ?? "regular";
    });
    const mainPanelDimensions = computed(
      () => {
        return ndvStore.getMainPanelDimensions(currentNodePaneType.value);
      }
    );
    const calculatedPositions = computed(
      () => {
        const hasInput = slots.input !== void 0;
        const outputPanelRelativeLeft = mainPanelDimensions.value.relativeLeft + mainPanelDimensions.value.relativeWidth;
        const inputPanelRelativeRight = hasInput ? 1 - outputPanelRelativeLeft + mainPanelDimensions.value.relativeWidth : 1 - pxToRelativeWidth(SIDE_MARGIN);
        return {
          inputPanelRelativeRight,
          outputPanelRelativeLeft
        };
      }
    );
    const outputPanelRelativeTranslate = computed(() => {
      const panelMinLeft = 1 - pxToRelativeWidth(MIN_PANEL_WIDTH + SIDE_MARGIN);
      const currentRelativeLeftDelta = calculatedPositions.value.outputPanelRelativeLeft - panelMinLeft;
      return currentRelativeLeftDelta > 0 ? currentRelativeLeftDelta : 0;
    });
    const supportedResizeDirections = computed(() => {
      const supportedDirections = ["right"];
      if (props.isDraggable) supportedDirections.push("left");
      return supportedDirections;
    });
    const hasInputSlot = computed(() => {
      return slots.input !== void 0;
    });
    const inputPanelMargin = computed(() => pxToRelativeWidth(SIDE_PANELS_MARGIN));
    const minimumLeftPosition = computed(() => {
      if (containerWidth.value < MIN_WINDOW_WIDTH) return pxToRelativeWidth(1);
      if (!hasInputSlot.value) return pxToRelativeWidth(SIDE_MARGIN);
      return pxToRelativeWidth(SIDE_MARGIN + 20) + inputPanelMargin.value;
    });
    const maximumRightPosition = computed(() => {
      if (containerWidth.value < MIN_WINDOW_WIDTH) return pxToRelativeWidth(1);
      return pxToRelativeWidth(SIDE_MARGIN + 20) + inputPanelMargin.value;
    });
    const canMoveLeft = computed(() => {
      return mainPanelDimensions.value.relativeLeft > minimumLeftPosition.value;
    });
    const canMoveRight = computed(() => {
      return mainPanelDimensions.value.relativeRight > maximumRightPosition.value;
    });
    const mainPanelStyles = computed(() => {
      return {
        left: `${relativeWidthToPx(mainPanelDimensions.value.relativeLeft)}px`,
        right: `${relativeWidthToPx(mainPanelDimensions.value.relativeRight)}px`
      };
    });
    const inputPanelStyles = computed(() => {
      return {
        right: `${relativeWidthToPx(calculatedPositions.value.inputPanelRelativeRight)}px`
      };
    });
    const outputPanelStyles = computed(() => {
      return {
        left: `${relativeWidthToPx(calculatedPositions.value.outputPanelRelativeLeft)}px`,
        transform: `translateX(-${relativeWidthToPx(outputPanelRelativeTranslate.value)}px)`
      };
    });
    const hasDoubleWidth = computed(() => {
      var _a;
      return ((_a = props.nodeType) == null ? void 0 : _a.parameterPane) === "wide";
    });
    const fixedPanelWidth = computed(() => {
      const multiplier = hasDoubleWidth.value ? 2 : 1;
      if (containerWidth.value > 1700) {
        return PANEL_WIDTH_LARGE * multiplier;
      }
      return PANEL_WIDTH * multiplier;
    });
    const onSwitchSelectedNode = (node2) => emit("switchSelectedNode", node2);
    function getInitialLeftPosition(width) {
      if (currentNodePaneType.value === "dragless")
        return pxToRelativeWidth(SIDE_MARGIN + 1 + fixedPanelWidth.value);
      return hasInputSlot.value ? 0.5 - width / 2 : minimumLeftPosition.value;
    }
    function setMainPanelWidth(relativeWidth) {
      const mainPanelRelativeWidth = relativeWidth || pxToRelativeWidth(initialMainPanelWidth[currentNodePaneType.value]);
      ndvStore.setMainPanelDimensions({
        panelType: currentNodePaneType.value,
        dimensions: {
          relativeWidth: mainPanelRelativeWidth
        }
      });
    }
    function setPositions(relativeLeft) {
      const mainPanelRelativeLeft = relativeLeft || 1 - calculatedPositions.value.inputPanelRelativeRight;
      const mainPanelRelativeRight = 1 - mainPanelRelativeLeft - mainPanelDimensions.value.relativeWidth;
      const isMaxRight = maximumRightPosition.value > mainPanelRelativeRight;
      const isMinLeft = minimumLeftPosition.value > mainPanelRelativeLeft;
      const isInputless = currentNodePaneType.value === "inputless";
      if (isMinLeft) {
        ndvStore.setMainPanelDimensions({
          panelType: currentNodePaneType.value,
          dimensions: {
            relativeLeft: minimumLeftPosition.value,
            relativeRight: 1 - mainPanelDimensions.value.relativeWidth - minimumLeftPosition.value
          }
        });
        return;
      }
      if (isMaxRight) {
        ndvStore.setMainPanelDimensions({
          panelType: currentNodePaneType.value,
          dimensions: {
            relativeLeft: 1 - mainPanelDimensions.value.relativeWidth - maximumRightPosition.value,
            relativeRight: maximumRightPosition.value
          }
        });
        return;
      }
      ndvStore.setMainPanelDimensions({
        panelType: currentNodePaneType.value,
        dimensions: {
          relativeLeft: isInputless ? minimumLeftPosition.value : mainPanelRelativeLeft,
          relativeRight: mainPanelRelativeRight
        }
      });
    }
    function setPositionByName(position2) {
      const positionByName = {
        minLeft: minimumLeftPosition.value,
        maxRight: maximumRightPosition.value,
        initial: getInitialLeftPosition(mainPanelDimensions.value.relativeWidth)
      };
      setPositions(positionByName[position2]);
    }
    function pxToRelativeWidth(px) {
      return px / containerWidth.value;
    }
    function relativeWidthToPx(relativeWidth) {
      return relativeWidth * containerWidth.value;
    }
    function onResizeEnd() {
      storePositionData();
    }
    function onResizeDebounced(data) {
      if (initialized.value) {
        void callDebounced(onResize, { debounceTime: 10, trailing: true }, data);
      }
    }
    function onResize({ direction, x, width }) {
      const relativeDistance = pxToRelativeWidth(x);
      const relativeWidth = pxToRelativeWidth(width);
      if (direction === "left" && relativeDistance <= minimumLeftPosition.value) return;
      if (direction === "right" && 1 - relativeDistance <= maximumRightPosition.value) return;
      if (width <= MIN_PANEL_WIDTH) return;
      setMainPanelWidth(relativeWidth);
      setPositions(direction === "left" ? relativeDistance : mainPanelDimensions.value.relativeLeft);
    }
    function restorePositionData() {
      const storedPanelWidthData = useStorage(
        `${LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH}_${currentNodePaneType.value}`
      ).value;
      if (storedPanelWidthData) {
        const parsedWidth = parseFloat(storedPanelWidthData);
        setMainPanelWidth(parsedWidth);
        const initialPosition = getInitialLeftPosition(parsedWidth);
        setPositions(initialPosition);
        return true;
      }
      return false;
    }
    function storePositionData() {
      useStorage(`${LOCAL_STORAGE_MAIN_PANEL_RELATIVE_WIDTH}_${currentNodePaneType.value}`).value = mainPanelDimensions.value.relativeWidth.toString();
    }
    function onDragStart() {
      isDragging.value = true;
      emit("dragstart", { position: mainPanelDimensions.value.relativeLeft });
    }
    function onDrag(position2) {
      const relativeLeft = pxToRelativeWidth(position2[0]) - mainPanelDimensions.value.relativeWidth / 2;
      setPositions(relativeLeft);
    }
    function onDragEnd() {
      setTimeout(() => {
        isDragging.value = false;
        emit("dragend", {
          windowWidth: containerWidth.value,
          position: mainPanelDimensions.value.relativeLeft
        });
      }, 0);
      storePositionData();
    }
    return (_ctx, _cache) => {
      const _component_n8n_resize_wrapper = resolveComponent("n8n-resize-wrapper");
      return openBlock(), createElementBlock("div", null, [
        unref(ndvStore).activeNode ? (openBlock(), createBlock(NDVFloatingNodes, {
          key: 0,
          "root-node": unref(ndvStore).activeNode,
          onSwitchSelectedNode
        }, null, 8, ["root-node"])) : createCommentVNode("", true),
        !_ctx.hideInputAndOutput ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.$style.inputPanel),
          style: normalizeStyle(inputPanelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "input")
        ], 6)) : createCommentVNode("", true),
        !_ctx.hideInputAndOutput ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass(_ctx.$style.outputPanel),
          style: normalizeStyle(outputPanelStyles.value)
        }, [
          renderSlot(_ctx.$slots, "output")
        ], 6)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.mainPanel),
          style: normalizeStyle(mainPanelStyles.value)
        }, [
          createVNode(_component_n8n_resize_wrapper, {
            "is-resizing-enabled": currentNodePaneType.value !== "unknown",
            width: relativeWidthToPx(mainPanelDimensions.value.relativeWidth),
            "min-width": MIN_PANEL_WIDTH,
            "grid-size": 20,
            "supported-directions": supportedResizeDirections.value,
            onResize: onResizeDebounced,
            onResizeend: onResizeEnd
          }, {
            default: withCtx(() => [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.dragButtonContainer)
              }, [
                !_ctx.hideInputAndOutput && _ctx.isDraggable ? (openBlock(), createBlock(PanelDragButton, {
                  key: 0,
                  class: normalizeClass({ [_ctx.$style.draggable]: true, [_ctx.$style.visible]: isDragging.value }),
                  "can-move-left": canMoveLeft.value,
                  "can-move-right": canMoveRight.value,
                  onDragstart: onDragStart,
                  onDrag,
                  onDragend: onDragEnd
                }, null, 8, ["class", "can-move-left", "can-move-right"])) : createCommentVNode("", true)
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass({ [_ctx.$style.mainPanelInner]: true, [_ctx.$style.dragging]: isDragging.value })
              }, [
                renderSlot(_ctx.$slots, "main")
              ], 2)
            ]),
            _: 3
          }, 8, ["is-resizing-enabled", "width", "supported-directions"])
        ], 6)
      ]);
    };
  }
});
const dataPanel = "_dataPanel_a6j4o_1";
const inputPanel = "_inputPanel_a6j4o_10 _dataPanel_a6j4o_1";
const outputPanel = "_outputPanel_a6j4o_18 _dataPanel_a6j4o_1";
const mainPanel = "_mainPanel_a6j4o_26";
const draggable$1 = "_draggable_a6j4o_30";
const mainPanelInner = "_mainPanelInner_a6j4o_34";
const dragging = "_dragging_a6j4o_41";
const dragButtonContainer = "_dragButtonContainer_a6j4o_54";
const visible = "_visible_a6j4o_70";
const style0$u = {
  dataPanel,
  inputPanel,
  outputPanel,
  mainPanel,
  draggable: draggable$1,
  mainPanelInner,
  dragging,
  "double-width": "_double-width_a6j4o_50",
  dragButtonContainer,
  visible
};
const cssModules$w = {
  "$style": style0$u
};
const NDVDraggablePanels = /* @__PURE__ */ _export_sfc$1(_sfc_main$S, [["__cssModules", cssModules$w]]);
const _hoisted_1$n = { key: 0 };
const _hoisted_2$f = { key: 1 };
const _hoisted_3$c = { key: 2 };
const _sfc_main$R = /* @__PURE__ */ defineComponent({
  __name: "RunDataPinButton",
  props: {
    tooltipContentsVisibility: {},
    dataPinningDocsUrl: {},
    pinnedData: {},
    disabled: { type: Boolean }
  },
  emits: ["togglePinData"],
  setup(__props, { emit: __emit }) {
    const locale = useI18n();
    const props = __props;
    const emit = __emit;
    const visible2 = computed(
      () => props.tooltipContentsVisibility.pinDataDiscoveryTooltipContent ? true : void 0
    );
    return (_ctx, _cache) => {
      const _component_n8n_link = resolveComponent("n8n-link");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createBlock(_component_n8n_tooltip, {
        placement: "bottom-end",
        visible: visible2.value
      }, {
        content: withCtx(() => [
          props.tooltipContentsVisibility.binaryDataTooltipContent ? (openBlock(), createElementBlock("div", _hoisted_1$n, toDisplayString(unref(locale).baseText("ndv.pinData.pin.binary")), 1)) : props.tooltipContentsVisibility.pinDataDiscoveryTooltipContent ? (openBlock(), createElementBlock("div", _hoisted_2$f, toDisplayString(unref(locale).baseText("node.discovery.pinData.ndv")), 1)) : (openBlock(), createElementBlock("div", _hoisted_3$c, [
            createBaseVNode("strong", null, toDisplayString(unref(locale).baseText("ndv.pinData.pin.title")), 1),
            createVNode(_component_n8n_text, {
              size: "small",
              tag: "p"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(locale).baseText("ndv.pinData.pin.description")) + " ", 1),
                createVNode(_component_n8n_link, {
                  to: props.dataPinningDocsUrl,
                  size: "small"
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(unref(locale).baseText("ndv.pinData.pin.link")), 1)
                  ]),
                  _: 1
                }, 8, ["to"])
              ]),
              _: 1
            })
          ]))
        ]),
        default: withCtx(() => [
          createVNode(_component_n8n_icon_button, {
            class: normalizeClass(_ctx.$style.pinDataButton),
            type: "tertiary",
            active: props.pinnedData.hasData.value,
            icon: "thumbtack",
            disabled: props.disabled,
            "data-test-id": "ndv-pin-data",
            onClick: _cache[0] || (_cache[0] = ($event) => emit("togglePinData"))
          }, null, 8, ["class", "active", "disabled"])
        ]),
        _: 1
      }, 8, ["visible"]);
    };
  }
});
const pinDataButton = "_pinDataButton_9p8um_1";
const style0$t = {
  pinDataButton
};
const cssModules$v = {
  "$style": style0$t
};
const __unplugin_components_1$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$R, [["__cssModules", cssModules$v]]);
var vueJsonPretty = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
(function(module, exports) {
  !function(e, t) {
    module.exports = t(require$$0);
  }(commonjsGlobal, function(e) {
    return function() {
      var t = { 789: function(t2) {
        t2.exports = e;
      } }, n = {};
      function o(e2) {
        var r2 = n[e2];
        if (void 0 !== r2) return r2.exports;
        var l = n[e2] = { exports: {} };
        return t[e2](l, l.exports, o), l.exports;
      }
      o.d = function(e2, t2) {
        for (var n2 in t2) o.o(t2, n2) && !o.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t2[n2] });
      }, o.o = function(e2, t2) {
        return Object.prototype.hasOwnProperty.call(e2, t2);
      }, o.r = function(e2) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      };
      var r = {};
      return function() {
        function e2(e3, t3) {
          (null == t3 || t3 > e3.length) && (t3 = e3.length);
          for (var n3 = 0, o2 = new Array(t3); n3 < t3; n3++) o2[n3] = e3[n3];
          return o2;
        }
        function t2(t3, n3) {
          if (t3) {
            if ("string" == typeof t3) return e2(t3, n3);
            var o2 = Object.prototype.toString.call(t3).slice(8, -1);
            return "Object" === o2 && t3.constructor && (o2 = t3.constructor.name), "Map" === o2 || "Set" === o2 ? Array.from(t3) : "Arguments" === o2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o2) ? e2(t3, n3) : void 0;
          }
        }
        function n2(n3) {
          return function(t3) {
            if (Array.isArray(t3)) return e2(t3);
          }(n3) || function(e3) {
            if ("undefined" != typeof Symbol && null != e3[Symbol.iterator] || null != e3["@@iterator"]) return Array.from(e3);
          }(n3) || t2(n3) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function l(e3, t3, n3) {
          return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
        }
        o.r(r), o.d(r, { default: function() {
          return k;
        } });
        var a = o(789), c = (0, a.defineComponent)({ props: { data: { required: true, type: String }, onClick: Function }, render: function() {
          var e3 = this.data, t3 = this.onClick;
          return (0, a.createVNode)("span", { class: "vjs-tree-brackets", onClick: t3 }, [e3]);
        } }), i = (0, a.defineComponent)({ emits: ["change", "update:modelValue"], props: { checked: { type: Boolean, default: false }, isMultiple: Boolean, onChange: Function }, setup: function(e3, t3) {
          var n3 = t3.emit;
          return { uiType: (0, a.computed)(function() {
            return e3.isMultiple ? "checkbox" : "radio";
          }), model: (0, a.computed)({ get: function() {
            return e3.checked;
          }, set: function(e4) {
            return n3("update:modelValue", e4);
          } }) };
        }, render: function() {
          var e3 = this.uiType, t3 = this.model, n3 = this.$emit;
          return (0, a.createVNode)("label", { class: ["vjs-check-controller", t3 ? "is-checked" : ""], onClick: function(e4) {
            return e4.stopPropagation();
          } }, [(0, a.createVNode)("span", { class: "vjs-check-controller-inner is-".concat(e3) }, null), (0, a.createVNode)("input", { checked: t3, class: "vjs-check-controller-original is-".concat(e3), type: e3, onChange: function() {
            return n3("change", t3);
          } }, null)]);
        } }), u = (0, a.defineComponent)({ props: { nodeType: { required: true, type: String }, onClick: Function }, render: function() {
          var e3 = this.nodeType, t3 = this.onClick, n3 = "objectStart" === e3 || "arrayStart" === e3;
          return n3 || "objectCollapsed" === e3 || "arrayCollapsed" === e3 ? (0, a.createVNode)("span", { class: "vjs-carets vjs-carets-".concat(n3 ? "open" : "close"), onClick: t3 }, [(0, a.createVNode)("svg", { viewBox: "0 0 1024 1024", focusable: "false", "data-icon": "caret-down", width: "1em", height: "1em", fill: "currentColor", "aria-hidden": "true" }, [(0, a.createVNode)("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }, null)])]) : null;
        } });
        function d(e3) {
          return d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
            return typeof e4;
          } : function(e4) {
            return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
          }, d(e3);
        }
        function s(e3) {
          return Object.prototype.toString.call(e3).slice(8, -1).toLowerCase();
        }
        function p(e3) {
          var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "root", n3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o2 = arguments.length > 3 ? arguments[3] : void 0, r2 = o2 || {}, l2 = r2.key, a2 = r2.index, c2 = r2.type, i2 = void 0 === c2 ? "content" : c2, u2 = r2.showComma, d2 = void 0 !== u2 && u2, f2 = r2.length, y2 = void 0 === f2 ? 1 : f2, v2 = s(e3);
          if ("array" === v2) {
            var b2 = h2(e3.map(function(e4, o3, r3) {
              return p(e4, "".concat(t3, "[").concat(o3, "]"), n3 + 1, { index: o3, showComma: o3 !== r3.length - 1, length: y2, type: i2 });
            }));
            return [p("[", t3, n3, { showComma: false, key: l2, length: e3.length, type: "arrayStart" })[0]].concat(b2, p("]", t3, n3, { showComma: d2, length: e3.length, type: "arrayEnd" })[0]);
          }
          if ("object" === v2) {
            var g2 = Object.keys(e3), m2 = h2(g2.map(function(o3, r3, l3) {
              return p(e3[o3], /^[a-zA-Z_]\w*$/.test(o3) ? "".concat(t3, ".").concat(o3) : "".concat(t3, '["').concat(o3, '"]'), n3 + 1, { key: o3, showComma: r3 !== l3.length - 1, length: y2, type: i2 });
            }));
            return [p("{", t3, n3, { showComma: false, key: l2, index: a2, length: g2.length, type: "objectStart" })[0]].concat(m2, p("}", t3, n3, { showComma: d2, length: g2.length, type: "objectEnd" })[0]);
          }
          return [{ content: e3, level: n3, key: l2, index: a2, path: t3, showComma: d2, length: y2, type: i2 }];
        }
        function h2(e3) {
          if ("function" == typeof Array.prototype.flat) return e3.flat();
          for (var t3 = n2(e3), o2 = []; t3.length; ) {
            var r2 = t3.shift();
            Array.isArray(r2) ? t3.unshift.apply(t3, n2(r2)) : o2.push(r2);
          }
          return o2;
        }
        function f(e3) {
          var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
          if (null == e3) return e3;
          if (e3 instanceof Date) return new Date(e3);
          if (e3 instanceof RegExp) return new RegExp(e3);
          if ("object" !== d(e3)) return e3;
          if (t3.get(e3)) return t3.get(e3);
          if (Array.isArray(e3)) {
            var n3 = e3.map(function(e4) {
              return f(e4, t3);
            });
            return t3.set(e3, n3), n3;
          }
          var o2 = {};
          for (var r2 in e3) o2[r2] = f(e3[r2], t3);
          return t3.set(e3, o2), o2;
        }
        function y(e3, t3) {
          var n3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var o2 = Object.getOwnPropertySymbols(e3);
            t3 && (o2 = o2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n3.push.apply(n3, o2);
          }
          return n3;
        }
        function v(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? y(Object(n3), true).forEach(function(t4) {
              l(e3, t4, n3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : y(Object(n3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
            });
          }
          return e3;
        }
        var b = { showLength: { type: Boolean, default: false }, showDoubleQuotes: { type: Boolean, default: true }, renderNodeKey: Function, renderNodeValue: Function, selectableType: String, showSelectController: { type: Boolean, default: false }, showLine: { type: Boolean, default: true }, showLineNumber: { type: Boolean, default: false }, selectOnClickNode: { type: Boolean, default: true }, nodeSelectable: { type: Function, default: function() {
          return true;
        } }, highlightSelectedNode: { type: Boolean, default: true }, showIcon: { type: Boolean, default: false }, showKeyValueSpace: { type: Boolean, default: true }, editable: { type: Boolean, default: false }, editableTrigger: { type: String, default: "click" }, onNodeClick: { type: Function }, onBracketsClick: { type: Function }, onIconClick: { type: Function }, onValueChange: { type: Function } }, g = (0, a.defineComponent)({ name: "TreeNode", props: v(v({}, b), {}, { node: { type: Object, required: true }, collapsed: Boolean, checked: Boolean, style: Object, onSelectedChange: { type: Function } }), emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "valueChange"], setup: function(e3, t3) {
          var n3 = t3.emit, o2 = (0, a.computed)(function() {
            return s(e3.node.content);
          }), r2 = (0, a.computed)(function() {
            return "vjs-value vjs-value-".concat(o2.value);
          }), l2 = (0, a.computed)(function() {
            return e3.showDoubleQuotes ? '"'.concat(e3.node.key, '"') : e3.node.key;
          }), d2 = (0, a.computed)(function() {
            return "multiple" === e3.selectableType;
          }), p2 = (0, a.computed)(function() {
            return "single" === e3.selectableType;
          }), h3 = (0, a.computed)(function() {
            return e3.nodeSelectable(e3.node) && (d2.value || p2.value);
          }), f2 = (0, a.reactive)({ editing: false }), y2 = function(t4) {
            var o3, r3, l3 = "null" === (r3 = null === (o3 = t4.target) || void 0 === o3 ? void 0 : o3.value) ? null : "undefined" === r3 ? void 0 : "true" === r3 || "false" !== r3 && (r3[0] + r3[r3.length - 1] === '""' || r3[0] + r3[r3.length - 1] === "''" ? r3.slice(1, -1) : "number" == typeof Number(r3) && !isNaN(Number(r3)) || "NaN" === r3 ? Number(r3) : r3);
            n3("valueChange", l3, e3.node.path);
          }, v2 = (0, a.computed)(function() {
            var t4, n4 = null === (t4 = e3.node) || void 0 === t4 ? void 0 : t4.content;
            return null === n4 ? n4 = "null" : void 0 === n4 && (n4 = "undefined"), "string" === o2.value ? '"'.concat(n4, '"') : n4 + "";
          }), b2 = function() {
            var t4 = e3.renderNodeValue;
            return t4 ? t4({ node: e3.node, defaultValue: v2.value }) : v2.value;
          }, g2 = function() {
            n3("bracketsClick", !e3.collapsed, e3.node.path);
          }, m2 = function() {
            n3("iconClick", !e3.collapsed, e3.node.path);
          }, C2 = function() {
            n3("selectedChange", e3.node);
          }, k2 = function() {
            n3("nodeClick", e3.node), h3.value && e3.selectOnClickNode && n3("selectedChange", e3.node);
          }, w = function(t4) {
            if (e3.editable && !f2.editing) {
              f2.editing = true;
              var n4 = function e4(n5) {
                var o3;
                n5.target !== t4.target && (null === (o3 = n5.target) || void 0 === o3 ? void 0 : o3.parentElement) !== t4.target && (f2.editing = false, document.removeEventListener("click", e4));
              };
              document.removeEventListener("click", n4), document.addEventListener("click", n4);
            }
          };
          return function() {
            var t4, n4 = e3.node;
            return (0, a.createVNode)("div", { class: { "vjs-tree-node": true, "has-selector": e3.showSelectController, "has-carets": e3.showIcon, "is-highlight": e3.highlightSelectedNode && e3.checked }, onClick: k2, style: e3.style }, [e3.showLineNumber && (0, a.createVNode)("span", { class: "vjs-node-index" }, [n4.id + 1]), e3.showSelectController && h3.value && "objectEnd" !== n4.type && "arrayEnd" !== n4.type && (0, a.createVNode)(i, { isMultiple: d2.value, checked: e3.checked, onChange: C2 }, null), (0, a.createVNode)("div", { class: "vjs-indent" }, [Array.from(Array(n4.level)).map(function(t5, n5) {
              return (0, a.createVNode)("div", { key: n5, class: { "vjs-indent-unit": true, "has-line": e3.showLine } }, null);
            }), e3.showIcon && (0, a.createVNode)(u, { nodeType: n4.type, onClick: m2 }, null)]), n4.key && (0, a.createVNode)("span", { class: "vjs-key" }, [(t4 = e3.renderNodeKey, t4 ? t4({ node: e3.node, defaultKey: l2.value || "" }) : l2.value), (0, a.createVNode)("span", { class: "vjs-colon" }, [":".concat(e3.showKeyValueSpace ? " " : "")])]), (0, a.createVNode)("span", null, ["content" !== n4.type && n4.content ? (0, a.createVNode)(c, { data: n4.content.toString(), onClick: g2 }, null) : (0, a.createVNode)("span", { class: r2.value, onClick: !e3.editable || e3.editableTrigger && "click" !== e3.editableTrigger ? void 0 : w, onDblclick: e3.editable && "dblclick" === e3.editableTrigger ? w : void 0 }, [e3.editable && f2.editing ? (0, a.createVNode)("input", { value: v2.value, onChange: y2, style: { padding: "3px 8px", border: "1px solid #eee", boxShadow: "none", boxSizing: "border-box", borderRadius: 5, fontFamily: "inherit" } }, null) : b2()]), n4.showComma && (0, a.createVNode)("span", null, [","]), e3.showLength && e3.collapsed && (0, a.createVNode)("span", { class: "vjs-comment" }, [(0, a.createTextVNode)(" // "), n4.length, (0, a.createTextVNode)(" items ")])])]);
          };
        } });
        function m(e3, t3) {
          var n3 = Object.keys(e3);
          if (Object.getOwnPropertySymbols) {
            var o2 = Object.getOwnPropertySymbols(e3);
            t3 && (o2 = o2.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
            })), n3.push.apply(n3, o2);
          }
          return n3;
        }
        function C(e3) {
          for (var t3 = 1; t3 < arguments.length; t3++) {
            var n3 = null != arguments[t3] ? arguments[t3] : {};
            t3 % 2 ? m(Object(n3), true).forEach(function(t4) {
              l(e3, t4, n3[t4]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : m(Object(n3)).forEach(function(t4) {
              Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
            });
          }
          return e3;
        }
        var k = (0, a.defineComponent)({ name: "Tree", props: C(C({}, b), {}, { data: { type: [String, Number, Boolean, Array, Object], default: null }, deep: { type: Number, default: 1 / 0 }, pathCollapsible: { type: Function, default: function() {
          return false;
        } }, rootPath: { type: String, default: "root" }, virtual: { type: Boolean, default: false }, height: { type: Number, default: 400 }, itemHeight: { type: Number, default: 20 }, selectedValue: { type: [String, Array], default: function() {
          return "";
        } }, collapsedOnClickBrackets: { type: Boolean, default: true }, style: Object, onSelectedChange: { type: Function } }), slots: ["renderNodeKey", "renderNodeValue"], emits: ["nodeClick", "bracketsClick", "iconClick", "selectedChange", "update:selectedValue", "update:data"], setup: function(e3, o2) {
          var r2 = o2.emit, c2 = o2.slots, i2 = (0, a.ref)(), u2 = (0, a.computed)(function() {
            return p(e3.data, e3.rootPath);
          }), d2 = function(t3) {
            return u2.value.reduce(function(n3, o3) {
              var r3, a2 = o3.level >= t3, c3 = null === (r3 = e3.pathCollapsible) || void 0 === r3 ? void 0 : r3.call(e3, o3);
              return "objectStart" !== o3.type && "arrayStart" !== o3.type || !a2 && !c3 ? n3 : C(C({}, n3), {}, l({}, o3.path, 1));
            }, {});
          }, s2 = (0, a.reactive)({ translateY: 0, visibleData: null, hiddenPaths: d2(e3.deep) }), h3 = (0, a.computed)(function() {
            for (var e4 = null, t3 = [], n3 = u2.value.length, o3 = 0; o3 < n3; o3++) {
              var r3 = C(C({}, u2.value[o3]), {}, { id: o3 }), l2 = s2.hiddenPaths[r3.path];
              if (e4 && e4.path === r3.path) {
                var a2 = "objectStart" === e4.type, c3 = C(C(C({}, r3), e4), {}, { showComma: r3.showComma, content: a2 ? "{...}" : "[...]", type: a2 ? "objectCollapsed" : "arrayCollapsed" });
                e4 = null, t3.push(c3);
              } else {
                if (l2 && !e4) {
                  e4 = r3;
                  continue;
                }
                if (e4) continue;
                t3.push(r3);
              }
            }
            return t3;
          }), y2 = (0, a.computed)(function() {
            var t3 = e3.selectedValue;
            return t3 && "multiple" === e3.selectableType && Array.isArray(t3) ? t3 : [t3];
          }), v2 = (0, a.computed)(function() {
            return !e3.selectableType || e3.selectOnClickNode || e3.showSelectController ? "" : "When selectableType is not null, selectOnClickNode and showSelectController cannot be false at the same time, because this will cause the selection to fail.";
          }), b2 = function() {
            var t3 = h3.value;
            if (e3.virtual) {
              var n3, o3 = e3.height / e3.itemHeight, r3 = (null === (n3 = i2.value) || void 0 === n3 ? void 0 : n3.scrollTop) || 0, l2 = Math.floor(r3 / e3.itemHeight), a2 = l2 < 0 ? 0 : l2 + o3 > t3.length ? t3.length - o3 : l2;
              a2 < 0 && (a2 = 0);
              var c3 = a2 + o3;
              s2.translateY = a2 * e3.itemHeight, s2.visibleData = t3.filter(function(e4, t4) {
                return t4 >= a2 && t4 < c3;
              });
            } else s2.visibleData = t3;
          }, m2 = function() {
            b2();
          }, k2 = function(o3) {
            var l2, a2, c3 = o3.path, i3 = e3.selectableType;
            if ("multiple" === i3) {
              var u3 = y2.value.findIndex(function(e4) {
                return e4 === c3;
              }), d3 = n2(y2.value);
              -1 !== u3 ? d3.splice(u3, 1) : d3.push(c3), r2("update:selectedValue", d3), r2("selectedChange", d3, n2(y2.value));
            } else if ("single" === i3 && y2.value[0] !== c3) {
              var s3 = (l2 = y2.value, a2 = 1, function(e4) {
                if (Array.isArray(e4)) return e4;
              }(l2) || function(e4, t3) {
                var n3 = null == e4 ? null : "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
                if (null != n3) {
                  var o4, r3, l3 = [], a3 = true, c4 = false;
                  try {
                    for (n3 = n3.call(e4); !(a3 = (o4 = n3.next()).done) && (l3.push(o4.value), !t3 || l3.length !== t3); a3 = true) ;
                  } catch (e5) {
                    c4 = true, r3 = e5;
                  } finally {
                    try {
                      a3 || null == n3.return || n3.return();
                    } finally {
                      if (c4) throw r3;
                    }
                  }
                  return l3;
                }
              }(l2, a2) || t2(l2, a2) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
              }())[0], p2 = c3;
              r2("update:selectedValue", p2), r2("selectedChange", p2, s3);
            }
          }, w = function(e4) {
            r2("nodeClick", e4);
          }, N = function(e4, t3) {
            if (e4) s2.hiddenPaths = C(C({}, s2.hiddenPaths), {}, l({}, t3, 1));
            else {
              var n3 = C({}, s2.hiddenPaths);
              delete n3[t3], s2.hiddenPaths = n3;
            }
          }, j = function(t3, n3) {
            e3.collapsedOnClickBrackets && N(t3, n3), r2("bracketsClick", t3);
          }, S = function(e4, t3) {
            N(e4, t3), r2("iconClick", e4);
          }, O = function(t3, n3) {
            var o3 = f(e3.data), l2 = e3.rootPath;
            new Function("data", "val", "data".concat(n3.slice(l2.length), "=val"))(o3, t3), r2("update:data", o3);
          };
          return (0, a.watchEffect)(function() {
            v2.value && function(e4) {
              throw new Error("[VueJSONPretty] ".concat(e4));
            }(v2.value);
          }), (0, a.watchEffect)(function() {
            h3.value && b2();
          }), (0, a.watch)(function() {
            return e3.deep;
          }, function(e4) {
            e4 && (s2.hiddenPaths = d2(e4));
          }), function() {
            var t3, n3, o3 = null !== (t3 = e3.renderNodeKey) && void 0 !== t3 ? t3 : c2.renderNodeKey, r3 = null !== (n3 = e3.renderNodeValue) && void 0 !== n3 ? n3 : c2.renderNodeValue, l2 = s2.visibleData && s2.visibleData.map(function(t4) {
              return (0, a.createVNode)(g, { key: t4.id, node: t4, collapsed: !!s2.hiddenPaths[t4.path], showDoubleQuotes: e3.showDoubleQuotes, showLength: e3.showLength, checked: y2.value.includes(t4.path), selectableType: e3.selectableType, showLine: e3.showLine, showLineNumber: e3.showLineNumber, showSelectController: e3.showSelectController, selectOnClickNode: e3.selectOnClickNode, nodeSelectable: e3.nodeSelectable, highlightSelectedNode: e3.highlightSelectedNode, editable: e3.editable, editableTrigger: e3.editableTrigger, showIcon: e3.showIcon, showKeyValueSpace: e3.showKeyValueSpace, renderNodeKey: o3, renderNodeValue: r3, onNodeClick: w, onBracketsClick: j, onIconClick: S, onSelectedChange: k2, onValueChange: O, style: e3.itemHeight && 20 !== e3.itemHeight ? { lineHeight: "".concat(e3.itemHeight, "px") } : {} }, null);
            });
            return (0, a.createVNode)("div", { ref: i2, class: { "vjs-tree": true, "is-virtual": e3.virtual }, onScroll: e3.virtual ? m2 : void 0, style: e3.showLineNumber ? C({ paddingLeft: "".concat(12 * Number(u2.value.length.toString().length), "px") }, e3.style) : e3.style }, [e3.virtual ? (0, a.createVNode)("div", { class: "vjs-tree-list", style: { height: "".concat(e3.height, "px") } }, [(0, a.createVNode)("div", { class: "vjs-tree-list-holder", style: { height: "".concat(h3.value.length * e3.itemHeight, "px") } }, [(0, a.createVNode)("div", { class: "vjs-tree-list-holder-inner", style: { transform: "translateY(".concat(s2.translateY, "px)") } }, [l2])])]) : l2]);
          };
        } });
      }(), r;
    }();
  });
})(vueJsonPretty);
var vueJsonPrettyExports = vueJsonPretty.exports;
const VueJsonPretty = /* @__PURE__ */ getDefaultExportFromCjs(vueJsonPrettyExports);
const sanitizeOptions = {
  allowVulnerableTags: false,
  enforceHtmlBoundary: false,
  disallowedTagsMode: "discard",
  allowedTags: [...sanitizeHtml_1.defaults.allowedTags, "style", "img", "title"],
  allowedAttributes: {
    ...sanitizeHtml_1.defaults.allowedAttributes,
    "*": ["class", "style"]
  },
  transformTags: {
    head: ""
  }
};
const _sfc_main$Q = {
  name: "RunDataHtml",
  props: {
    inputHtml: {
      type: String,
      required: true
    }
  },
  computed: {
    sanitizedHtml() {
      return sanitizeHtml(this.inputHtml, sanitizeOptions);
    }
  }
};
const _hoisted_1$m = ["srcdoc"];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("iframe", {
    class: "__html-display",
    srcdoc: $options.sanitizedHtml
  }, null, 8, _hoisted_1$m);
}
const RunDataHtml = /* @__PURE__ */ _export_sfc$1(_sfc_main$Q, [["render", _sfc_render$7]]);
const RunDataHtml$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: RunDataHtml
}, Symbol.toStringTag, { value: "Module" }));
const _hoisted_1$l = { key: 0 };
const _hoisted_2$e = { key: 1 };
const _hoisted_3$b = { key: 2 };
const _hoisted_4$5 = {
  key: 0,
  controls: "",
  autoplay: ""
};
const _hoisted_5$4 = ["src", "type"];
const _hoisted_6$4 = {
  key: 1,
  controls: "",
  autoplay: ""
};
const _hoisted_7$3 = ["src", "type"];
const _hoisted_8$3 = ["src"];
const _hoisted_9$2 = ["src"];
const _sfc_main$P = /* @__PURE__ */ defineComponent({
  __name: "BinaryDataDisplayEmbed",
  props: {
    binaryData: {}
  },
  setup(__props) {
    const props = __props;
    const isLoading = ref(true);
    const embedSource = ref("");
    const error2 = ref(false);
    const data = ref("");
    const workflowsStore = useWorkflowsStore();
    const embedClass = computed(() => {
      return [props.binaryData.fileType ?? "other"];
    });
    onMounted(async () => {
      const { id: id2, data: binaryData, fileName, fileType, mimeType } = props.binaryData;
      const isJSONData = fileType === "json";
      const isHTMLData = fileType === "html";
      if (!id2) {
        if (isJSONData || isHTMLData) {
          data.value = jsonParse(atob(binaryData));
        } else {
          embedSource.value = "data:" + mimeType + ";base64," + binaryData;
        }
      } else {
        try {
          const binaryUrl = workflowsStore.getBinaryUrl(id2, "view", fileName ?? "", mimeType);
          if (isJSONData || isHTMLData) {
            const fetchedData = await fetch(binaryUrl, { credentials: "include" });
            data.value = await (isJSONData ? fetchedData.json() : fetchedData.text());
          } else {
            embedSource.value = binaryUrl;
          }
        } catch (e) {
          error2.value = true;
        }
      }
      isLoading.value = false;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", null, [
        isLoading.value ? (openBlock(), createElementBlock("div", _hoisted_1$l, "Loading binary data...")) : error2.value ? (openBlock(), createElementBlock("div", _hoisted_2$e, "Error loading binary data")) : (openBlock(), createElementBlock("span", _hoisted_3$b, [
          _ctx.binaryData.fileType === "video" ? (openBlock(), createElementBlock("video", _hoisted_4$5, [
            createBaseVNode("source", {
              src: embedSource.value,
              type: _ctx.binaryData.mimeType
            }, null, 8, _hoisted_5$4),
            createTextVNode(" " + toDisplayString(_ctx.$locale.baseText("binaryDataDisplay.yourBrowserDoesNotSupport")), 1)
          ])) : _ctx.binaryData.fileType === "audio" ? (openBlock(), createElementBlock("audio", _hoisted_6$4, [
            createBaseVNode("source", {
              src: embedSource.value,
              type: _ctx.binaryData.mimeType
            }, null, 8, _hoisted_7$3),
            createTextVNode(" " + toDisplayString(_ctx.$locale.baseText("binaryDataDisplay.yourBrowserDoesNotSupport")), 1)
          ])) : _ctx.binaryData.fileType === "image" ? (openBlock(), createElementBlock("img", {
            key: 2,
            src: embedSource.value
          }, null, 8, _hoisted_8$3)) : _ctx.binaryData.fileType === "json" ? (openBlock(), createBlock(unref(VueJsonPretty), {
            key: 3,
            data: data.value,
            deep: 3,
            "show-length": true
          }, null, 8, ["data"])) : _ctx.binaryData.fileType === "html" ? (openBlock(), createBlock(RunDataHtml, {
            key: 4,
            "input-html": data.value
          }, null, 8, ["input-html"])) : (openBlock(), createElementBlock("embed", {
            key: 5,
            src: embedSource.value,
            class: normalizeClass(["binary-data", embedClass.value])
          }, null, 10, _hoisted_9$2))
        ]))
      ]);
    };
  }
});
const _hoisted_1$k = { class: "binary-data-window-wrapper" };
const _hoisted_2$d = { key: 0 };
const _sfc_main$O = /* @__PURE__ */ defineComponent({
  __name: "BinaryDataDisplay",
  props: {
    displayData: {},
    windowVisible: { type: Boolean }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const nodeHelpers = useNodeHelpers();
    const workflowsStore = useWorkflowsStore();
    const workflowRunData = computed(() => {
      const workflowExecution = workflowsStore.getWorkflowExecution;
      if (workflowExecution === null) {
        return null;
      }
      const executionData = workflowExecution.data;
      return executionData ? executionData.resultData.runData : null;
    });
    const binaryData = computed(() => {
      if (typeof props.displayData.node !== "string" || typeof props.displayData.key !== "string" || typeof props.displayData.runIndex !== "number" || typeof props.displayData.index !== "number" || typeof props.displayData.outputIndex !== "number") {
        return null;
      }
      const binaryDataLocal = nodeHelpers.getBinaryData(
        workflowRunData.value,
        props.displayData.node,
        props.displayData.runIndex,
        props.displayData.outputIndex
      );
      if (binaryDataLocal.length === 0) {
        return null;
      }
      if (props.displayData.index >= binaryDataLocal.length || binaryDataLocal[props.displayData.index][props.displayData.key] === void 0) {
        return null;
      }
      const binaryDataItem = binaryDataLocal[props.displayData.index][props.displayData.key];
      return binaryDataItem;
    });
    function closeWindow() {
      emit("close");
      return false;
    }
    return (_ctx, _cache) => {
      var _a;
      const _component_n8n_button = resolveComponent("n8n-button");
      return _ctx.windowVisible ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["binary-data-window", (_a = binaryData.value) == null ? void 0 : _a.fileType])
      }, [
        createVNode(_component_n8n_button, {
          size: "small",
          class: "binary-data-window-back",
          title: _ctx.$locale.baseText("binaryDataDisplay.backToOverviewPage"),
          icon: "arrow-left",
          label: _ctx.$locale.baseText("binaryDataDisplay.backToList"),
          onClick: withModifiers(closeWindow, ["stop"])
        }, null, 8, ["title", "label"]),
        createBaseVNode("div", _hoisted_1$k, [
          !binaryData.value ? (openBlock(), createElementBlock("div", _hoisted_2$d, toDisplayString(_ctx.$locale.baseText("binaryDataDisplay.noDataFoundToDisplay")), 1)) : (openBlock(), createBlock(_sfc_main$P, {
            key: 1,
            "binary-data": binaryData.value
          }, null, 8, ["binary-data"]))
        ])
      ], 2)) : createCommentVNode("", true);
    };
  }
});
const LazyRunDataTable = defineAsyncComponent(
  async () => await __vitePreload(() => import("./RunDataTable-CNdHnjmM.js"), true ? __vite__mapDeps([0,1,2,3]) : void 0)
);
const LazyRunDataJson = defineAsyncComponent(
  async () => await __vitePreload(() => import("./RunDataJson-BR2zl0xs.js"), true ? __vite__mapDeps([4,1,2,5,6,7,8,9,10,11,12,13]) : void 0)
);
const LazyRunDataSchema = defineAsyncComponent(
  async () => await __vitePreload(() => import("./index-TQ22MZub.js").then((n) => n.jr), true ? __vite__mapDeps([1,2]) : void 0)
);
const LazyRunDataHtml = defineAsyncComponent(
  async () => await __vitePreload(() => Promise.resolve().then(() => RunDataHtml$1), true ? void 0 : void 0)
);
const LazyRunDataSearch = defineAsyncComponent(
  async () => await __vitePreload(() => import("./RunDataSearch-aEp6SsT6.js"), true ? __vite__mapDeps([14,1,2,15]) : void 0)
);
const _sfc_main$N = defineComponent({
  name: "RunData",
  components: {
    BinaryDataDisplay: _sfc_main$O,
    NodeErrorView: _sfc_main$12,
    JsonEditor: __unplugin_components_2$2,
    LazyRunDataTable,
    LazyRunDataJson,
    LazyRunDataSchema,
    LazyRunDataHtml,
    LazyRunDataSearch,
    RunDataPinButton: __unplugin_components_1$1
  },
  props: {
    node: {
      type: Object,
      default: null
    },
    nodes: {
      type: Array,
      default: () => []
    },
    workflow: {
      type: Object,
      required: true
    },
    runIndex: {
      type: Number,
      required: true
    },
    linkedRuns: {
      type: Boolean
    },
    canLinkRuns: {
      type: Boolean
    },
    tooMuchDataTitle: {
      type: String
    },
    noDataInBranchMessage: {
      type: String
    },
    isExecuting: {
      type: Boolean
    },
    executingMessage: {
      type: String
    },
    pushRef: {
      type: String
    },
    paneType: {
      type: String,
      required: true
    },
    overrideOutputs: {
      type: Array
    },
    mappingEnabled: {
      type: Boolean
    },
    distanceFromActive: {
      type: Number,
      default: 0
    },
    blockUI: {
      type: Boolean,
      default: false
    },
    isProductionExecutionPreview: {
      type: Boolean,
      default: false
    },
    isPaneActive: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const ndvStore = useNDVStore();
    const nodeHelpers = useNodeHelpers();
    const externalHooks = useExternalHooks();
    const node2 = toRef(props, "node");
    const pinnedData2 = usePinnedData(node2, {
      runIndex: props.runIndex,
      displayMode: ndvStore.getPanelDisplayMode(props.paneType)
    });
    const { isSubNodeType: isSubNodeType2 } = useNodeType({
      node: node2
    });
    return {
      ...useToast(),
      externalHooks,
      nodeHelpers,
      pinnedData: pinnedData2,
      isSubNodeType: isSubNodeType2
    };
  },
  data() {
    return {
      connectionType: NodeConnectionType.Main,
      binaryDataPreviewActive: false,
      dataSize: 0,
      showData: false,
      userEnabledShowData: false,
      outputIndex: 0,
      binaryDataDisplayVisible: false,
      binaryDataDisplayData: null,
      MAX_DISPLAY_DATA_SIZE,
      MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW,
      MAX_DISPLAY_ITEMS_AUTO_ALL,
      currentPage: 1,
      pageSize: 10,
      pageSizes: [1, 10, 25, 50, 100],
      pinDataDiscoveryTooltipVisible: false,
      isControlledPinDataTooltip: false,
      search: ""
    };
  },
  computed: {
    ...mapStores(
      useNodeTypesStore,
      useNDVStore,
      useWorkflowsStore,
      useSourceControlStore,
      useRootStore
    ),
    isReadOnlyRoute() {
      var _a, _b;
      return ((_b = (_a = this.$route) == null ? void 0 : _a.meta) == null ? void 0 : _b.readOnlyCanvas) === true;
    },
    isWaitNodeWaiting() {
      var _a, _b, _c, _d, _e, _f;
      return ((_a = this.workflowExecution) == null ? void 0 : _a.status) === "waiting" && ((_b = this.workflowExecution.data) == null ? void 0 : _b.waitTill) && ((_e = (_d = (_c = this.workflowExecution) == null ? void 0 : _c.data) == null ? void 0 : _d.resultData) == null ? void 0 : _e.lastNodeExecuted) === ((_f = this.node) == null ? void 0 : _f.name);
    },
    activeNode() {
      return this.ndvStore.activeNode;
    },
    dataPinningDocsUrl() {
      return DATA_PINNING_DOCS_URL;
    },
    dataEditingDocsUrl() {
      return DATA_EDITING_DOCS_URL;
    },
    displayMode() {
      return this.ndvStore.getPanelDisplayMode(this.paneType);
    },
    nodeType() {
      if (this.node) {
        return this.nodeTypesStore.getNodeType(this.node.type, this.node.typeVersion);
      }
      return null;
    },
    isSchemaView() {
      return this.displayMode === "schema";
    },
    displaysMultipleNodes() {
      return this.isSchemaView && this.paneType === "input" && this.nodes.length > 0;
    },
    isTriggerNode() {
      if (this.node === null) {
        return false;
      }
      return this.nodeTypesStore.isTriggerNode(this.node.type);
    },
    canPinData() {
      if (this.node === null) {
        return false;
      }
      const canPinNode = usePinnedData(this.node).canPinNode(false);
      return canPinNode && !this.isPaneTypeInput && this.pinnedData.isValidNodeType.value && !(this.binaryData && this.binaryData.length > 0);
    },
    displayModes() {
      var _a;
      const defaults = [
        { label: this.$locale.baseText("runData.table"), value: "table" },
        { label: this.$locale.baseText("runData.json"), value: "json" }
      ];
      if (this.binaryData.length) {
        defaults.push({ label: this.$locale.baseText("runData.binary"), value: "binary" });
      }
      const schemaView = { label: this.$locale.baseText("runData.schema"), value: "schema" };
      if (this.isPaneTypeInput) {
        defaults.unshift(schemaView);
      } else {
        defaults.push(schemaView);
      }
      if (this.isPaneTypeOutput && ((_a = this.activeNode) == null ? void 0 : _a.type) === HTML_NODE_TYPE && this.activeNode.parameters.operation === "generateHtmlTemplate") {
        defaults.unshift({ label: "HTML", value: "html" });
      }
      return defaults;
    },
    hasNodeRun() {
      return Boolean(
        !this.isExecuting && this.node && (this.workflowRunData && this.workflowRunData.hasOwnProperty(this.node.name) || this.pinnedData.hasData.value)
      );
    },
    isArtificialRecoveredEventItem() {
      var _a, _b, _c;
      return !!((_c = (_b = (_a = this.rawInputData) == null ? void 0 : _a[0]) == null ? void 0 : _b.json) == null ? void 0 : _c.isArtificialRecoveredEventItem);
    },
    subworkflowExecutionError() {
      var _a;
      return {
        node: this.node,
        messages: [((_a = this.workflowsStore.subWorkflowExecutionError) == null ? void 0 : _a.message) ?? ""]
      };
    },
    hasSubworkflowExecutionError() {
      return Boolean(this.workflowsStore.subWorkflowExecutionError);
    },
    workflowRunErrorAsNodeError() {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!this.node) {
        return null;
      }
      if (this.isSubNodeType && this.paneType === "input") {
        const parentNode = this.workflow.getChildNodes(((_a = this.node) == null ? void 0 : _a.name) ?? "", "ALL_NON_MAIN")[0];
        return (_d = (_c = (_b = this.workflowRunData) == null ? void 0 : _b[parentNode]) == null ? void 0 : _c[this.runIndex]) == null ? void 0 : _d.error;
      }
      return (_h = (_g = (_f = this.workflowRunData) == null ? void 0 : _f[(_e = this.node) == null ? void 0 : _e.name]) == null ? void 0 : _g[this.runIndex]) == null ? void 0 : _h.error;
    },
    hasRunError() {
      return Boolean(this.node && this.workflowRunErrorAsNodeError);
    },
    executionHints() {
      var _a, _b, _c;
      if (this.hasNodeRun) {
        const hints = this.node && ((_c = (_b = (_a = this.workflowRunData) == null ? void 0 : _a[this.node.name]) == null ? void 0 : _b[this.runIndex]) == null ? void 0 : _c.hints);
        if (hints) return hints;
      }
      return [];
    },
    workflowExecution() {
      return this.workflowsStore.getWorkflowExecution;
    },
    workflowRunData() {
      if (this.workflowExecution === null) {
        return null;
      }
      const executionData = this.workflowExecution.data;
      if (executionData == null ? void 0 : executionData.resultData) {
        return executionData.resultData.runData;
      }
      return null;
    },
    dataCount() {
      return this.getDataCount(this.runIndex, this.currentOutputIndex);
    },
    unfilteredDataCount() {
      return this.pinnedData.data.value ? this.pinnedData.data.value.length : this.rawInputData.length;
    },
    dataSizeInMB() {
      return (this.dataSize / (1024 * 1024)).toFixed(1);
    },
    maxOutputIndex() {
      if (this.node === null || this.runIndex === void 0) {
        return 0;
      }
      const runData2 = this.workflowRunData;
      if (runData2 === null || !runData2.hasOwnProperty(this.node.name)) {
        return 0;
      }
      if (runData2[this.node.name].length < this.runIndex) {
        return 0;
      }
      if (runData2[this.node.name][this.runIndex]) {
        const taskData = runData2[this.node.name][this.runIndex].data;
        if (taskData == null ? void 0 : taskData.main) {
          return taskData.main.length - 1;
        }
      }
      return 0;
    },
    currentPageOffset() {
      return this.pageSize * (this.currentPage - 1);
    },
    maxRunIndex() {
      if (this.node === null) {
        return 0;
      }
      const runData2 = this.workflowRunData;
      if (runData2 === null || !runData2.hasOwnProperty(this.node.name)) {
        return 0;
      }
      if (runData2[this.node.name].length) {
        return runData2[this.node.name].length - 1;
      }
      return 0;
    },
    rawInputData() {
      return this.getRawInputData(this.runIndex, this.currentOutputIndex, this.connectionType);
    },
    unfilteredInputData() {
      return this.getPinDataOrLiveData(this.rawInputData);
    },
    inputData() {
      return this.getFilteredData(this.unfilteredInputData);
    },
    inputDataPage() {
      const offset = this.pageSize * (this.currentPage - 1);
      return this.inputData.slice(offset, offset + this.pageSize);
    },
    jsonData() {
      return executionDataToJson(this.inputData);
    },
    binaryData() {
      if (!this.node) {
        return [];
      }
      const binaryData = this.nodeHelpers.getBinaryData(
        this.workflowRunData,
        this.node.name,
        this.runIndex,
        this.currentOutputIndex
      );
      return binaryData.filter((data) => Boolean(data && Object.keys(data).length));
    },
    inputHtml() {
      var _a, _b;
      return String(((_b = (_a = this.inputData[0]) == null ? void 0 : _a.json) == null ? void 0 : _b.html) ?? "");
    },
    currentOutputIndex() {
      var _a;
      if (((_a = this.overrideOutputs) == null ? void 0 : _a.length) && !this.overrideOutputs.includes(this.outputIndex)) {
        return this.overrideOutputs[0];
      }
      return this.outputIndex;
    },
    branches() {
      var _a;
      const capitalize2 = (name) => name.charAt(0).toLocaleUpperCase() + name.slice(1);
      const branches = [];
      for (let i = 0; i <= this.maxOutputIndex; i++) {
        if (this.overrideOutputs && !this.overrideOutputs.includes(i)) {
          continue;
        }
        const totalItemsCount = this.getRawInputData(this.runIndex, i).length;
        const itemsCount2 = this.getDataCount(this.runIndex, i);
        const items = this.search ? this.$locale.baseText("ndv.search.items", {
          adjustToNumber: totalItemsCount,
          interpolate: { matched: itemsCount2, total: totalItemsCount }
        }) : this.$locale.baseText("ndv.output.items", {
          adjustToNumber: itemsCount2,
          interpolate: { count: itemsCount2 }
        });
        let outputName = this.getOutputName(i);
        if (`${outputName}` === `${i}`) {
          outputName = `${this.$locale.baseText("ndv.output")} ${outputName}`;
        } else {
          const appendBranchWord = NODE_TYPES_EXCLUDED_FROM_OUTPUT_NAME_APPEND.includes(
            ((_a = this.node) == null ? void 0 : _a.type) ?? ""
          ) ? "" : ` ${this.$locale.baseText("ndv.output.branch")}`;
          outputName = capitalize2(`${this.getOutputName(i)}${appendBranchWord}`);
        }
        branches.push({
          label: this.search && itemsCount2 || totalItemsCount ? `${outputName} (${items})` : outputName,
          value: i
        });
      }
      return branches;
    },
    editMode() {
      return this.isPaneTypeInput ? { enabled: false, value: "" } : this.ndvStore.outputPanelEditMode;
    },
    isPaneTypeInput() {
      return this.paneType === "input";
    },
    isPaneTypeOutput() {
      return this.paneType === "output";
    },
    readOnlyEnv() {
      return this.sourceControlStore.preferences.branchReadOnly;
    },
    showIOSearch() {
      return this.hasNodeRun && !this.hasRunError && this.unfilteredInputData.length > 0;
    },
    inputSelectLocation() {
      if (this.isSchemaView) return "none";
      if (!this.hasNodeRun) return "header";
      if (this.maxRunIndex > 0) return "runs";
      if (this.maxOutputIndex > 0 && this.branches.length > 1) {
        return "outputs";
      }
      return "items";
    },
    showIoSearchNoMatchContent() {
      return this.hasNodeRun && !this.inputData.length && !!this.search;
    },
    parentNodeOutputData() {
      var _a;
      const parentNode = this.workflow.getParentNodesByDepth(((_a = this.node) == null ? void 0 : _a.name) ?? "")[0];
      let parentNodeData = [];
      if (parentNode == null ? void 0 : parentNode.name) {
        parentNodeData = this.nodeHelpers.getNodeInputData(
          this.workflow.getNode(parentNode == null ? void 0 : parentNode.name),
          this.runIndex,
          this.outputIndex,
          "input",
          this.connectionType
        );
      }
      return parentNodeData;
    },
    parentNodePinnedData() {
      var _a, _b;
      const parentNode = this.workflow.getParentNodesByDepth(((_a = this.node) == null ? void 0 : _a.name) ?? "")[0];
      return ((_b = this.workflow.pinData) == null ? void 0 : _b[(parentNode == null ? void 0 : parentNode.name) || ""]) || [];
    }
  },
  watch: {
    node(newNode, prevNode) {
      if ((newNode == null ? void 0 : newNode.id) === (prevNode == null ? void 0 : prevNode.id)) return;
      this.init();
    },
    hasNodeRun() {
      if (this.paneType === "output") this.setDisplayMode();
    },
    inputDataPage: {
      handler(data) {
        if (this.paneType && data) {
          this.ndvStore.setNDVPanelDataIsEmpty({
            panel: this.paneType,
            isEmpty: data.every((item) => isEmpty(item.json))
          });
        }
      },
      immediate: true,
      deep: true
    },
    jsonData(data, prevData) {
      if (isEqual(data, prevData)) return;
      this.refreshDataSize();
      if (this.dataCount) {
        this.resetCurrentPageIfTooFar();
      }
      this.showPinDataDiscoveryTooltip(data);
    },
    binaryData(newData, prevData) {
      if (newData.length && !prevData.length && this.displayMode !== "binary") {
        this.switchToBinary();
      } else if (!newData.length && this.displayMode === "binary") {
        this.onDisplayModeChange("table");
      }
    },
    currentOutputIndex(branchIndex) {
      this.ndvStore.setNDVBranchIndex({
        pane: this.paneType,
        branchIndex
      });
    },
    search(newSearch) {
      this.$emit("search", newSearch);
    }
  },
  mounted() {
    var _a, _b, _c;
    this.init();
    if (!this.isPaneTypeInput) {
      this.showPinDataDiscoveryTooltip(this.jsonData);
    }
    this.ndvStore.setNDVBranchIndex({
      pane: this.paneType,
      branchIndex: this.currentOutputIndex
    });
    if (this.paneType === "output") {
      this.setDisplayMode();
      this.activatePane();
    }
    if (this.hasRunError && this.node) {
      const error2 = (_c = (_b = (_a = this.workflowRunData) == null ? void 0 : _a[this.node.name]) == null ? void 0 : _b[this.runIndex]) == null ? void 0 : _c.error;
      const errorsToTrack = ["unknown error"];
      if (error2 && errorsToTrack.some((e) => {
        var _a2;
        return (_a2 = error2.message) == null ? void 0 : _a2.toLowerCase().includes(e);
      })) {
        this.$telemetry.track(
          "User encountered an error",
          {
            node: this.node.type,
            errorMessage: error2.message,
            nodeVersion: this.node.typeVersion,
            n8nVersion: this.rootStore.versionCli
          },
          {
            withPostHog: true
          }
        );
      }
    }
  },
  beforeUnmount() {
    this.hidePinDataDiscoveryTooltip();
  },
  methods: {
    getResolvedNodeOutputs() {
      if (this.node && this.nodeType) {
        const workflowNode = this.workflow.getNode(this.node.name);
        if (workflowNode) {
          const outputs2 = getNodeOutputs(this.workflow, workflowNode, this.nodeType);
          return outputs2;
        }
      }
      return [];
    },
    shouldHintBeDisplayed(hint) {
      const { location, whenToDisplay } = hint;
      if (location) {
        if (location === "ndv" && !["input", "output"].includes(this.paneType)) {
          return false;
        }
        if (location === "inputPane" && this.paneType !== "input") {
          return false;
        }
        if (location === "outputPane" && this.paneType !== "output") {
          return false;
        }
      }
      if (whenToDisplay === "afterExecution" && !this.hasNodeRun) {
        return false;
      }
      if (whenToDisplay === "beforeExecution" && this.hasNodeRun) {
        return false;
      }
      return true;
    },
    getNodeHints() {
      var _a, _b, _c, _d, _e, _f;
      try {
        if (this.node && this.nodeType) {
          const workflowNode = this.workflow.getNode(this.node.name);
          if (workflowNode) {
            const executionHints = this.executionHints;
            const nodeHints = getNodeHints(this.workflow, workflowNode, this.nodeType, {
              runExecutionData: ((_a = this.workflowExecution) == null ? void 0 : _a.data) ?? null,
              runIndex: this.runIndex,
              connectionInputData: this.parentNodeOutputData
            });
            const hasMultipleInputItems = this.parentNodeOutputData.length > 1 || this.parentNodePinnedData.length > 1;
            const nodeOutputData = ((_f = (_e = (_d = (_c = (_b = this.workflowRunData) == null ? void 0 : _b[this.node.name]) == null ? void 0 : _c[this.runIndex]) == null ? void 0 : _d.data) == null ? void 0 : _e.main) == null ? void 0 : _f[0]) || [];
            const genericHints = getGenericHints({
              workflowNode,
              node: this.node,
              nodeType: this.nodeType,
              nodeOutputData,
              workflow: this.workflow,
              hasNodeRun: this.hasNodeRun,
              hasMultipleInputItems
            });
            return executionHints.concat(nodeHints, genericHints).filter(this.shouldHintBeDisplayed);
          }
        }
      } catch (error2) {
        console.error("Error while getting node hints", error2);
      }
      return [];
    },
    onItemHover(itemIndex) {
      if (itemIndex === null) {
        this.$emit("itemHover", null);
        return;
      }
      this.$emit("itemHover", {
        outputIndex: this.currentOutputIndex,
        itemIndex
      });
    },
    onClickDataPinningDocsLink() {
      var _a;
      this.$telemetry.track("User clicked ndv link", {
        workflow_id: this.workflowsStore.workflowId,
        push_ref: this.pushRef,
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        pane: "output",
        type: "data-pinning-docs"
      });
    },
    showPinDataDiscoveryTooltip(value) {
      if (!this.isTriggerNode) {
        return;
      }
      const pinDataDiscoveryFlag = useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG).value;
      if (value && value.length > 0 && !this.isReadOnlyRoute && !pinDataDiscoveryFlag) {
        this.pinDataDiscoveryComplete();
        setTimeout(() => {
          this.isControlledPinDataTooltip = true;
          this.pinDataDiscoveryTooltipVisible = true;
          dataPinningEventBus.emit("data-pinning-discovery", { isTooltipVisible: true });
        }, 500);
      }
    },
    hidePinDataDiscoveryTooltip() {
      if (this.pinDataDiscoveryTooltipVisible) {
        this.isControlledPinDataTooltip = false;
        this.pinDataDiscoveryTooltipVisible = false;
        dataPinningEventBus.emit("data-pinning-discovery", { isTooltipVisible: false });
      }
    },
    pinDataDiscoveryComplete() {
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_NDV_FLAG).value = "true";
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG).value = "true";
    },
    enterEditMode({ origin }) {
      var _a;
      const inputData = this.pinnedData.data.value ? clearJsonKey(this.pinnedData.data.value) : executionDataToJson(this.rawInputData);
      const inputDataLength = Array.isArray(inputData) ? inputData.length : Object.keys(inputData ?? {}).length;
      const data = inputDataLength > 0 ? inputData : TEST_PIN_DATA;
      this.ndvStore.setOutputPanelEditModeEnabled(true);
      this.ndvStore.setOutputPanelEditModeValue(JSON.stringify(data, null, 2));
      this.$telemetry.track("User opened ndv edit state", {
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        click_type: origin === "editIconButton" ? "button" : "link",
        push_ref: this.pushRef,
        run_index: this.runIndex,
        is_output_present: this.hasNodeRun || this.pinnedData.hasData.value,
        view: !this.hasNodeRun && !this.pinnedData.hasData.value ? "undefined" : this.displayMode,
        is_data_pinned: this.pinnedData.hasData.value
      });
    },
    onClickCancelEdit() {
      this.ndvStore.setOutputPanelEditModeEnabled(false);
      this.ndvStore.setOutputPanelEditModeValue("");
      this.onExitEditMode({ type: "cancel" });
    },
    onClickSaveEdit() {
      if (!this.node) {
        return;
      }
      const { value } = this.editMode;
      this.clearAllStickyNotifications();
      try {
        const clearedValue = clearJsonKey(value);
        try {
          this.pinnedData.setData(clearedValue, "save-edit");
        } catch (error2) {
          return;
        }
      } catch (error2) {
        this.showError(error2, this.$locale.baseText("ndv.pinData.error.syntaxError.title"));
        return;
      }
      this.ndvStore.setOutputPanelEditModeEnabled(false);
      this.onExitEditMode({ type: "save" });
    },
    onExitEditMode({ type }) {
      var _a;
      this.$telemetry.track("User closed ndv edit state", {
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        push_ref: this.pushRef,
        run_index: this.runIndex,
        view: this.displayMode,
        type
      });
    },
    async onTogglePinData({ source }) {
      var _a;
      if (!this.node) {
        return;
      }
      if (source === "pin-icon-click") {
        const telemetryPayload = {
          node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
          push_ref: this.pushRef,
          run_index: this.runIndex,
          view: !this.hasNodeRun && !this.pinnedData.hasData.value ? "none" : this.displayMode
        };
        void this.externalHooks.run("runData.onTogglePinData", telemetryPayload);
        this.$telemetry.track("User clicked pin data icon", telemetryPayload);
      }
      this.nodeHelpers.updateNodeParameterIssues(this.node);
      if (this.pinnedData.hasData.value) {
        this.pinnedData.unsetData(source);
        return;
      }
      try {
        this.pinnedData.setData(this.rawInputData, "pin-icon-click");
      } catch (error2) {
        console.error(error2);
        return;
      }
      if (this.maxRunIndex > 0) {
        this.showToast({
          title: this.$locale.baseText("ndv.pinData.pin.multipleRuns.title", {
            interpolate: {
              index: `${this.runIndex}`
            }
          }),
          message: this.$locale.baseText("ndv.pinData.pin.multipleRuns.description"),
          type: "success",
          duration: 2e3
        });
      }
      this.hidePinDataDiscoveryTooltip();
      this.pinDataDiscoveryComplete();
    },
    switchToBinary() {
      this.onDisplayModeChange("binary");
    },
    onBranchChange(value) {
      var _a;
      this.outputIndex = value;
      this.$telemetry.track("User changed ndv branch", {
        push_ref: this.pushRef,
        branch_index: value,
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        node_type_input_selection: this.nodeType ? this.nodeType.name : "",
        pane: this.paneType
      });
    },
    showTooMuchData() {
      var _a;
      this.showData = true;
      this.userEnabledShowData = true;
      this.$telemetry.track("User clicked ndv button", {
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        workflow_id: this.workflowsStore.workflowId,
        push_ref: this.pushRef,
        pane: this.paneType,
        type: "showTooMuchData"
      });
    },
    toggleLinkRuns() {
      this.linkedRuns ? this.unlinkRun() : this.linkRun();
    },
    linkRun() {
      this.$emit("linkRun");
    },
    unlinkRun() {
      this.$emit("unlinkRun");
    },
    onCurrentPageChange(value) {
      var _a;
      this.currentPage = value;
      this.$telemetry.track("User changed ndv page", {
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        workflow_id: this.workflowsStore.workflowId,
        push_ref: this.pushRef,
        pane: this.paneType,
        page_selected: this.currentPage,
        page_size: this.pageSize,
        items_total: this.dataCount
      });
    },
    resetCurrentPageIfTooFar() {
      const maxPage = Math.ceil(this.dataCount / this.pageSize);
      if (maxPage < this.currentPage) {
        this.currentPage = maxPage;
      }
    },
    onPageSizeChange(pageSize) {
      var _a;
      this.pageSize = pageSize;
      this.resetCurrentPageIfTooFar();
      this.$telemetry.track("User changed ndv page size", {
        node_type: (_a = this.activeNode) == null ? void 0 : _a.type,
        workflow_id: this.workflowsStore.workflowId,
        push_ref: this.pushRef,
        pane: this.paneType,
        page_selected: this.currentPage,
        page_size: this.pageSize,
        items_total: this.dataCount
      });
    },
    onDisplayModeChange(displayMode) {
      const previous = this.displayMode;
      this.ndvStore.setPanelDisplayMode({ pane: this.paneType, mode: displayMode });
      if (!this.userEnabledShowData) this.updateShowData();
      const dataContainerRef = this.$refs.dataContainer;
      if (dataContainerRef) {
        const dataDisplay2 = dataContainerRef.children[0];
        if (dataDisplay2) {
          dataDisplay2.scrollTo(0, 0);
        }
      }
      this.closeBinaryDataDisplay();
      void this.externalHooks.run("runData.displayModeChanged", {
        newValue: displayMode,
        oldValue: previous
      });
      if (this.activeNode) {
        this.$telemetry.track("User changed ndv item view", {
          previous_view: previous,
          new_view: displayMode,
          node_type: this.activeNode.type,
          workflow_id: this.workflowsStore.workflowId,
          push_ref: this.pushRef,
          pane: this.paneType
        });
      }
    },
    getRunLabel(option2) {
      let itemsCount2 = 0;
      for (let i = 0; i <= this.maxOutputIndex; i++) {
        itemsCount2 += this.getPinDataOrLiveData(this.getRawInputData(option2 - 1, i)).length;
      }
      const items = this.$locale.baseText("ndv.output.items", {
        adjustToNumber: itemsCount2,
        interpolate: { count: itemsCount2 }
      });
      const itemsLabel = itemsCount2 > 0 ? ` (${items})` : "";
      return option2 + this.$locale.baseText("ndv.output.of") + (this.maxRunIndex + 1) + itemsLabel;
    },
    getRawInputData(runIndex, outputIndex, connectionType2 = NodeConnectionType.Main) {
      let inputData = [];
      if (this.node) {
        inputData = this.nodeHelpers.getNodeInputData(
          this.node,
          runIndex,
          outputIndex,
          this.paneType,
          connectionType2
        );
      }
      if (inputData.length === 0 || !Array.isArray(inputData)) {
        return [];
      }
      return inputData;
    },
    getPinDataOrLiveData(inputData) {
      if (this.pinnedData.data.value && !this.isProductionExecutionPreview) {
        return Array.isArray(this.pinnedData.data.value) ? this.pinnedData.data.value.map((value) => ({
          json: value
        })) : [
          {
            json: this.pinnedData.data.value
          }
        ];
      }
      return inputData;
    },
    getFilteredData(inputData) {
      if (!this.search || this.isSchemaView) {
        return inputData;
      }
      this.currentPage = 1;
      return inputData.filter(({ json }) => searchInObject(json, this.search));
    },
    getDataCount(runIndex, outputIndex, connectionType2 = NodeConnectionType.Main) {
      var _a, _b, _c;
      if (!this.node) {
        return 0;
      }
      if ((_c = (_b = (_a = this.workflowRunData) == null ? void 0 : _a[this.node.name]) == null ? void 0 : _b[runIndex]) == null ? void 0 : _c.hasOwnProperty("error")) {
        return 1;
      }
      const rawInputData = this.getRawInputData(runIndex, outputIndex, connectionType2);
      const pinOrLiveData = this.getPinDataOrLiveData(rawInputData);
      return this.getFilteredData(pinOrLiveData).length;
    },
    init() {
      this.outputIndex = 0;
      this.refreshDataSize();
      this.closeBinaryDataDisplay();
      let outputTypes = [];
      if (this.nodeType !== null && this.node !== null) {
        const outputs2 = this.getResolvedNodeOutputs();
        outputTypes = getConnectionTypes(outputs2);
      }
      this.connectionType = outputTypes.length === 0 ? NodeConnectionType.Main : outputTypes[0];
      if (this.binaryData.length > 0) {
        this.ndvStore.setPanelDisplayMode({
          pane: this.paneType,
          mode: "binary"
        });
      } else if (this.displayMode === "binary") {
        this.ndvStore.setPanelDisplayMode({
          pane: this.paneType,
          mode: "table"
        });
      }
    },
    closeBinaryDataDisplay() {
      this.binaryDataDisplayVisible = false;
      this.binaryDataDisplayData = null;
    },
    clearExecutionData() {
      this.workflowsStore.setWorkflowExecutionData(null);
      this.nodeHelpers.updateNodesExecutionIssues();
    },
    isViewable(index, key) {
      const { fileType } = this.binaryData[index][key];
      return !!fileType && ["image", "audio", "video", "text", "json", "pdf", "html"].includes(fileType);
    },
    isDownloadable(index, key) {
      const { mimeType, fileName } = this.binaryData[index][key];
      return !!(mimeType && fileName);
    },
    async downloadBinaryData(index, key) {
      const { id: id2, data, fileName, fileExtension, mimeType } = this.binaryData[index][key];
      if (id2) {
        const url = this.workflowsStore.getBinaryUrl(id2, "download", fileName ?? "", mimeType);
        FileSaver_minExports.saveAs(url, [fileName, fileExtension].join("."));
        return;
      } else {
        const bufferString = "data:" + mimeType + ";base64," + data;
        const blob = await fetch(bufferString).then(async (d) => await d.blob());
        FileSaver_minExports.saveAs(blob, fileName);
      }
    },
    async downloadJsonData() {
      var _a;
      const fileName = (((_a = this.node) == null ? void 0 : _a.name) ?? "").replace(/[^\w\d]/g, "_");
      const blob = new Blob([JSON.stringify(this.rawInputData, null, 2)], {
        type: "application/json"
      });
      FileSaver_minExports.saveAs(blob, `${fileName}.json`);
    },
    displayBinaryData(index, key) {
      var _a;
      const { data, mimeType } = this.binaryData[index][key];
      this.binaryDataDisplayVisible = true;
      this.binaryDataDisplayData = {
        node: (_a = this.node) == null ? void 0 : _a.name,
        runIndex: this.runIndex,
        outputIndex: this.currentOutputIndex,
        index,
        key,
        data,
        mimeType
      };
    },
    getOutputName(outputIndex) {
      if (this.node === null) {
        return outputIndex + 1;
      }
      const nodeType = this.nodeType;
      const outputs2 = this.getResolvedNodeOutputs();
      const outputConfiguration = outputs2 == null ? void 0 : outputs2[outputIndex];
      if (outputConfiguration && isObject$2(outputConfiguration)) {
        return outputConfiguration == null ? void 0 : outputConfiguration.displayName;
      }
      if (!(nodeType == null ? void 0 : nodeType.outputNames) || nodeType.outputNames.length <= outputIndex) {
        return outputIndex + 1;
      }
      return nodeType.outputNames[outputIndex];
    },
    refreshDataSize() {
      this.showData = false;
      const jsonItems = this.inputDataPage.map((item) => item.json);
      const byteSize = new Blob([JSON.stringify(jsonItems)]).size;
      this.dataSize = byteSize;
      this.updateShowData();
    },
    updateShowData() {
      this.showData = this.isSchemaView && this.dataSize < this.MAX_DISPLAY_DATA_SIZE_SCHEMA_VIEW || this.dataSize < this.MAX_DISPLAY_DATA_SIZE;
    },
    onRunIndexChange(run) {
      this.$emit("runChange", run);
    },
    enableNode() {
      if (this.node) {
        const updateInformation = {
          name: this.node.name,
          properties: {
            disabled: !this.node.disabled
          }
        };
        this.workflowsStore.updateNodeProperties(updateInformation);
      }
    },
    setDisplayMode() {
      if (!this.activeNode) return;
      const shouldDisplayHtml = this.activeNode.type === HTML_NODE_TYPE && this.activeNode.parameters.operation === "generateHtmlTemplate";
      if (shouldDisplayHtml) {
        this.ndvStore.setPanelDisplayMode({
          pane: "output",
          mode: "html"
        });
      }
    },
    activatePane() {
      this.$emit("activatePane");
    },
    onSearchClear() {
      this.search = "";
      document.dispatchEvent(new KeyboardEvent("keyup", { key: "/" }));
    }
  }
});
const infoIcon = "_infoIcon_1i220_1";
const center = "_center_1i220_5";
const container$1 = "_container_1i220_19";
const pinnedDataCallout = "_pinnedDataCallout_1i220_28";
const header$1 = "_header_1i220_36";
const dataContainer = "_dataContainer_1i220_50";
const dataDisplay = "_dataDisplay_1i220_59";
const inlineError = "_inlineError_1i220_71";
const outputs = "_outputs_1i220_78";
const tabs = "_tabs_1i220_87";
const itemsCount = "_itemsCount_1i220_95";
const itemsText = "_itemsText_1i220_103";
const muted = "_muted_1i220_109";
const inputSelect = "_inputSelect_1i220_114";
const runSelector = "_runSelector_1i220_120";
const search = "_search_1i220_132";
const runSelectorInner = "_runSelectorInner_1i220_136";
const pagination = "_pagination_1i220_140";
const pageSizeSelector = "_pageSizeSelector_1i220_150";
const binaryIndex = "_binaryIndex_1i220_156";
const binaryRow = "_binaryRow_1i220_173";
const binaryCell = "_binaryCell_1i220_178";
const binaryHeader = "_binaryHeader_1i220_190";
const binaryButtonContainer = "_binaryButtonContainer_1i220_199";
const binaryValue = "_binaryValue_1i220_210";
const displayModes = "_displayModes_1i220_215";
const tooltipContain = "_tooltipContain_1i220_222";
const spinner = "_spinner_1i220_226";
const editMode = "_editMode_1i220_237";
const editModeBody = "_editModeBody_1i220_246";
const editModeFooter = "_editModeFooter_1i220_253";
const editModeFooterInfotip = "_editModeFooterInfotip_1i220_263";
const editModeActions = "_editModeActions_1i220_269";
const stretchVertically = "_stretchVertically_1i220_276";
const uiBlocker = "_uiBlocker_1i220_280";
const hintCallout = "_hintCallout_1i220_285";
const schema = "_schema_1i220_291";
const style0$s = {
  infoIcon,
  center,
  container: container$1,
  pinnedDataCallout,
  header: header$1,
  dataContainer,
  "actions-group": "_actions-group_1i220_55",
  dataDisplay,
  inlineError,
  outputs,
  tabs,
  itemsCount,
  itemsText,
  muted,
  inputSelect,
  runSelector,
  search,
  runSelectorInner,
  pagination,
  pageSizeSelector,
  binaryIndex,
  binaryRow,
  binaryCell,
  binaryHeader,
  binaryButtonContainer,
  binaryValue,
  displayModes,
  tooltipContain,
  spinner,
  editMode,
  editModeBody,
  editModeFooter,
  editModeFooterInfotip,
  editModeActions,
  stretchVertically,
  uiBlocker,
  hintCallout,
  schema
};
const _hoisted_1$j = {
  key: 0,
  class: "ml-4xs"
};
const _hoisted_2$c = { key: 1 };
const _hoisted_3$a = { key: 0 };
const _hoisted_4$4 = ["data-test-id"];
const _hoisted_5$3 = { key: 0 };
const _hoisted_6$3 = { key: 1 };
const _hoisted_7$2 = { key: 2 };
const _hoisted_8$2 = { key: 3 };
const _hoisted_9$1 = { key: 4 };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b, _c, _d, _e, _f;
  const _component_n8n_link = resolveComponent("n8n-link");
  const _component_n8n_callout = resolveComponent("n8n-callout");
  const _component_BinaryDataDisplay = _sfc_main$O;
  const _component_LazyRunDataSearch = resolveComponent("LazyRunDataSearch");
  const _component_n8n_radio_buttons = resolveComponent("n8n-radio-buttons");
  const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
  const _component_RunDataPinButton = __unplugin_components_1$1;
  const _component_n8n_button = resolveComponent("n8n-button");
  const _component_n8n_option = resolveComponent("n8n-option");
  const _component_n8n_select = resolveComponent("n8n-select");
  const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
  const _component_n8n_text = resolveComponent("n8n-text");
  const _component_n8n_tabs = resolveComponent("n8n-tabs");
  const _component_n8n_spinner = resolveComponent("n8n-spinner");
  const _component_JsonEditor = __unplugin_components_2$2;
  const _component_n8n_info_tip = resolveComponent("n8n-info-tip");
  const _component_NodeErrorView = _sfc_main$12;
  const _component_i18n_t = resolveComponent("i18n-t");
  const _component_LazyRunDataTable = resolveComponent("LazyRunDataTable");
  const _component_LazyRunDataJson = resolveComponent("LazyRunDataJson");
  const _component_LazyRunDataHtml = resolveComponent("LazyRunDataHtml");
  const _component_LazyRunDataSchema = resolveComponent("LazyRunDataSchema");
  const _component_el_pagination = resolveComponent("el-pagination");
  const _component_n8n_block_ui = resolveComponent("n8n-block-ui");
  const _directive_n8n_html = resolveDirective("n8n-html");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["run-data", _ctx.$style.container]),
    onMouseover: _cache[12] || (_cache[12] = (...args) => _ctx.activatePane && _ctx.activatePane(...args))
  }, [
    _ctx.canPinData && _ctx.pinnedData.hasData.value && !_ctx.editMode.enabled && !_ctx.isProductionExecutionPreview ? (openBlock(), createBlock(_component_n8n_callout, {
      key: 0,
      theme: "secondary",
      icon: "thumbtack",
      class: normalizeClass(_ctx.$style.pinnedDataCallout)
    }, {
      trailingContent: withCtx(() => [
        createVNode(_component_n8n_link, {
          to: _ctx.dataPinningDocsUrl,
          size: "small",
          theme: "secondary",
          bold: "",
          underline: "",
          onClick: _ctx.onClickDataPinningDocsLink
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.pindata.learnMore")), 1)
          ]),
          _: 1
        }, 8, ["to", "onClick"])
      ]),
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.pindata.thisDataIsPinned")) + " ", 1),
        !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv ? (openBlock(), createElementBlock("span", _hoisted_1$j, [
          createVNode(_component_n8n_link, {
            theme: "secondary",
            size: "small",
            underline: "",
            bold: "",
            onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.onTogglePinData({ source: "banner-link" }), ["stop"]))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.pindata.unpin")), 1)
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["class"])) : createCommentVNode("", true),
    _ctx.binaryDataDisplayData ? (openBlock(), createBlock(_component_BinaryDataDisplay, {
      key: 1,
      "window-visible": _ctx.binaryDataDisplayVisible,
      "display-data": _ctx.binaryDataDisplayData,
      onClose: _ctx.closeBinaryDataDisplay
    }, null, 8, ["window-visible", "display-data", "onClose"])) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.$style.header)
    }, [
      renderSlot(_ctx.$slots, "header", {}, void 0, true),
      withDirectives(createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.displayModes),
        "data-test-id": "run-data-pane-header",
        onClick: _cache[4] || (_cache[4] = withModifiers(() => {
        }, ["stop"]))
      }, [
        (openBlock(), createBlock(Suspense, null, {
          default: withCtx(() => [
            _ctx.showIOSearch ? (openBlock(), createBlock(_component_LazyRunDataSearch, {
              key: 0,
              modelValue: _ctx.search,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.search = $event),
              class: normalizeClass(_ctx.$style.search),
              "pane-type": _ctx.paneType,
              "display-mode": _ctx.displayMode,
              "is-area-active": _ctx.isPaneActive,
              onFocus: _ctx.activatePane
            }, null, 8, ["modelValue", "class", "pane-type", "display-mode", "is-area-active", "onFocus"])) : createCommentVNode("", true)
          ]),
          _: 1
        })),
        withDirectives(createVNode(_component_n8n_radio_buttons, {
          "model-value": _ctx.displayMode,
          options: _ctx.displayModes,
          "data-test-id": "ndv-run-data-display-mode",
          "onUpdate:modelValue": _ctx.onDisplayModeChange
        }, null, 8, ["model-value", "options", "onUpdate:modelValue"]), [
          [
            vShow,
            _ctx.hasNodeRun && (_ctx.inputData.length || _ctx.binaryData.length || _ctx.search) && !_ctx.editMode.enabled
          ]
        ]),
        _ctx.canPinData && !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv ? withDirectives((openBlock(), createBlock(_component_n8n_icon_button, {
          key: 0,
          title: _ctx.$locale.baseText("runData.editOutput"),
          circle: false,
          disabled: (_a = _ctx.node) == null ? void 0 : _a.disabled,
          icon: "pencil-alt",
          type: "tertiary",
          "data-test-id": "ndv-edit-pinned-data",
          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.enterEditMode({ origin: "editIconButton" }))
        }, null, 8, ["title", "disabled"])), [
          [vShow, !_ctx.editMode.enabled]
        ]) : createCommentVNode("", true),
        (_ctx.canPinData || !!((_b = _ctx.binaryData) == null ? void 0 : _b.length)) && _ctx.rawInputData.length && !_ctx.editMode.enabled ? (openBlock(), createBlock(_component_RunDataPinButton, {
          key: 1,
          disabled: !_ctx.rawInputData.length && !_ctx.pinnedData.hasData.value || _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !!((_c = _ctx.binaryData) == null ? void 0 : _c.length),
          "tooltip-contents-visibility": {
            binaryDataTooltipContent: !!((_d = _ctx.binaryData) == null ? void 0 : _d.length),
            pinDataDiscoveryTooltipContent: _ctx.isControlledPinDataTooltip && _ctx.pinDataDiscoveryTooltipVisible
          },
          "data-pinning-docs-url": _ctx.dataPinningDocsUrl,
          "pinned-data": _ctx.pinnedData,
          onTogglePinData: _cache[3] || (_cache[3] = ($event) => _ctx.onTogglePinData({ source: "pin-icon-click" }))
        }, null, 8, ["disabled", "tooltip-contents-visibility", "data-pinning-docs-url", "pinned-data"])) : createCommentVNode("", true),
        withDirectives(createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.editModeActions)
        }, [
          createVNode(_component_n8n_button, {
            type: "tertiary",
            label: _ctx.$locale.baseText("runData.editor.cancel"),
            onClick: _ctx.onClickCancelEdit
          }, null, 8, ["label", "onClick"]),
          createVNode(_component_n8n_button, {
            class: "ml-2xs",
            type: "primary",
            label: _ctx.$locale.baseText("runData.editor.save"),
            onClick: _ctx.onClickSaveEdit
          }, null, 8, ["label", "onClick"])
        ], 2), [
          [vShow, _ctx.editMode.enabled]
        ])
      ], 2), [
        [vShow, !_ctx.hasRunError]
      ])
    ], 2),
    _ctx.inputSelectLocation === "header" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(_ctx.$style.inputSelect)
    }, [
      renderSlot(_ctx.$slots, "input-select", {}, void 0, true)
    ], 2)) : createCommentVNode("", true),
    _ctx.maxRunIndex > 0 && !_ctx.displaysMultipleNodes ? withDirectives((openBlock(), createElementBlock("div", {
      key: 3,
      class: normalizeClass(_ctx.$style.runSelector)
    }, [
      _ctx.inputSelectLocation === "runs" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
      createVNode(_component_n8n_select, {
        "model-value": _ctx.runIndex,
        class: normalizeClass(_ctx.$style.runSelectorInner),
        size: "small",
        teleported: "",
        "data-test-id": "run-selector",
        "onUpdate:modelValue": _ctx.onRunIndexChange,
        onClick: _cache[5] || (_cache[5] = withModifiers(() => {
        }, ["stop"]))
      }, {
        prepend: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.run")), 1)
        ]),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.maxRunIndex + 1, (option2) => {
            return openBlock(), createBlock(_component_n8n_option, {
              key: option2,
              label: _ctx.getRunLabel(option2),
              value: option2 - 1
            }, null, 8, ["label", "value"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "class", "onUpdate:modelValue"]),
      _ctx.canLinkRuns ? (openBlock(), createBlock(_component_n8n_tooltip, {
        key: 1,
        placement: "right"
      }, {
        content: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.$locale.baseText(_ctx.linkedRuns ? "runData.unlinking.hint" : "runData.linking.hint")), 1)
        ]),
        default: withCtx(() => [
          createVNode(_component_n8n_icon_button, {
            icon: _ctx.linkedRuns ? "unlink" : "link",
            class: "linkRun",
            text: "",
            type: "tertiary",
            size: "small",
            "data-test-id": "link-run",
            onClick: _ctx.toggleLinkRuns
          }, null, 8, ["icon", "onClick"])
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "run-info", {}, void 0, true)
    ], 2)), [
      [vShow, !_ctx.editMode.enabled]
    ]) : createCommentVNode("", true),
    !_ctx.displaysMultipleNodes ? renderSlot(_ctx.$slots, "before-data", { key: 4 }, void 0, true) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getNodeHints(), (hint) => {
      return openBlock(), createBlock(_component_n8n_callout, {
        key: hint.message,
        class: normalizeClass(_ctx.$style.hintCallout),
        theme: hint.type || "info"
      }, {
        default: withCtx(() => [
          withDirectives(createVNode(_component_n8n_text, { size: "small" }, null, 512), [
            [_directive_n8n_html, hint.message]
          ])
        ]),
        _: 2
      }, 1032, ["class", "theme"]);
    }), 128)),
    _ctx.maxOutputIndex > 0 && _ctx.branches.length > 1 && !_ctx.displaysMultipleNodes ? (openBlock(), createElementBlock("div", {
      key: 5,
      class: normalizeClass(_ctx.$style.outputs),
      "data-test-id": "branches"
    }, [
      _ctx.inputSelectLocation === "outputs" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.tabs)
      }, [
        createVNode(_component_n8n_tabs, {
          "model-value": _ctx.currentOutputIndex,
          options: _ctx.branches,
          "onUpdate:modelValue": _ctx.onBranchChange
        }, null, 8, ["model-value", "options", "onUpdate:modelValue"])
      ], 2)
    ], 2)) : !_ctx.hasRunError && _ctx.hasNodeRun && (_ctx.dataCount > 0 && _ctx.maxRunIndex === 0 || _ctx.search) && !_ctx.isArtificialRecoveredEventItem && !_ctx.displaysMultipleNodes ? withDirectives((openBlock(), createElementBlock("div", {
      key: 6,
      class: normalizeClass([_ctx.$style.itemsCount, { [_ctx.$style.muted]: _ctx.paneType === "input" && _ctx.maxRunIndex === 0 }]),
      "data-test-id": "ndv-items-count"
    }, [
      _ctx.inputSelectLocation === "items" ? renderSlot(_ctx.$slots, "input-select", { key: 0 }, void 0, true) : createCommentVNode("", true),
      _ctx.search ? (openBlock(), createBlock(_component_n8n_text, {
        key: 1,
        class: normalizeClass(_ctx.$style.itemsText)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.search.items", {
            adjustToNumber: _ctx.unfilteredDataCount,
            interpolate: { matched: _ctx.dataCount, total: _ctx.unfilteredDataCount }
          })), 1)
        ]),
        _: 1
      }, 8, ["class"])) : (openBlock(), createBlock(_component_n8n_text, {
        key: 2,
        class: normalizeClass(_ctx.$style.itemsText)
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.items", {
            adjustToNumber: _ctx.dataCount,
            interpolate: { count: _ctx.dataCount }
          })), 1)
        ]),
        _: 1
      }, 8, ["class"]))
    ], 2)), [
      [vShow, !_ctx.editMode.enabled && !_ctx.hasRunError]
    ]) : createCommentVNode("", true),
    createBaseVNode("div", {
      ref: "dataContainer",
      class: normalizeClass(_ctx.$style.dataContainer),
      "data-test-id": "ndv-data-container"
    }, [
      _ctx.isExecuting ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.$style.center),
        "data-test-id": "ndv-executing"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.spinner)
        }, [
          createVNode(_component_n8n_spinner, { type: "ring" })
        ], 2),
        createVNode(_component_n8n_text, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.executingMessage), 1)
          ]),
          _: 1
        })
      ], 2)) : _ctx.editMode.enabled ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.$style.editMode)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.editModeBody, "ignore-key-press"])
        }, [
          createVNode(_component_JsonEditor, {
            "model-value": _ctx.editMode.value,
            "fill-parent": true,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => _ctx.ndvStore.setOutputPanelEditModeValue($event))
          }, null, 8, ["model-value"])
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.editModeFooter)
        }, [
          createVNode(_component_n8n_info_tip, {
            bold: false,
            class: normalizeClass(_ctx.$style.editModeFooterInfotip)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.editor.copyDataInfo")) + " ", 1),
              createVNode(_component_n8n_link, {
                to: _ctx.dataEditingDocsUrl,
                size: "small"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("generic.learnMore")), 1)
                ]),
                _: 1
              }, 8, ["to"])
            ]),
            _: 1
          }, 8, ["class"])
        ], 2)
      ], 2)) : _ctx.paneType === "output" && _ctx.hasSubworkflowExecutionError ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass(_ctx.$style.stretchVertically)
      }, [
        createVNode(_component_NodeErrorView, {
          error: _ctx.subworkflowExecutionError,
          class: normalizeClass(_ctx.$style.errorDisplay)
        }, null, 8, ["error", "class"])
      ], 2)) : _ctx.isWaitNodeWaiting ? (openBlock(), createElementBlock("div", {
        key: 3,
        class: normalizeClass(_ctx.$style.center)
      }, [
        renderSlot(_ctx.$slots, "node-waiting", {}, () => [
          _cache[13] || (_cache[13] = createTextVNode("xxx"))
        ], true)
      ], 2)) : !_ctx.hasNodeRun && !(_ctx.displaysMultipleNodes && ((_e = _ctx.node) == null ? void 0 : _e.disabled)) ? (openBlock(), createElementBlock("div", {
        key: 4,
        class: normalizeClass(_ctx.$style.center)
      }, [
        renderSlot(_ctx.$slots, "node-not-run", {}, void 0, true)
      ], 2)) : _ctx.paneType === "input" && !_ctx.displaysMultipleNodes && ((_f = _ctx.node) == null ? void 0 : _f.disabled) ? (openBlock(), createElementBlock("div", {
        key: 5,
        class: normalizeClass(_ctx.$style.center)
      }, [
        createVNode(_component_n8n_text, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.disabled", { interpolate: { nodeName: _ctx.node.name } })) + " ", 1),
            createVNode(_component_n8n_link, { onClick: _ctx.enableNode }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.disabled.cta")), 1)
              ]),
              _: 1
            }, 8, ["onClick"])
          ]),
          _: 1
        })
      ], 2)) : _ctx.hasNodeRun && _ctx.isArtificialRecoveredEventItem ? (openBlock(), createElementBlock("div", {
        key: 6,
        class: normalizeClass(_ctx.$style.center)
      }, [
        renderSlot(_ctx.$slots, "recovered-artificial-output-data", {}, void 0, true)
      ], 2)) : _ctx.hasNodeRun && _ctx.hasRunError ? (openBlock(), createElementBlock("div", {
        key: 7,
        class: normalizeClass(_ctx.$style.stretchVertically)
      }, [
        _ctx.isPaneTypeInput ? (openBlock(), createBlock(_component_n8n_text, {
          key: 0,
          class: normalizeClass(_ctx.$style.center),
          size: "large",
          tag: "p",
          bold: ""
        }, {
          default: withCtx(() => {
            var _a2;
            return [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeErrorView.inputPanel.previousNodeError.title", {
                interpolate: { nodeName: ((_a2 = _ctx.node) == null ? void 0 : _a2.name) ?? "" }
              })), 1)
            ];
          }),
          _: 1
        }, 8, ["class"])) : _ctx.$slots["content"] ? (openBlock(), createElementBlock("div", _hoisted_2$c, [
          _ctx.workflowRunErrorAsNodeError ? (openBlock(), createBlock(_component_NodeErrorView, {
            key: 0,
            error: _ctx.workflowRunErrorAsNodeError,
            class: normalizeClass(_ctx.$style.inlineError),
            compact: ""
          }, null, 8, ["error", "class"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "content", {}, void 0, true)
        ])) : _ctx.workflowRunErrorAsNodeError ? (openBlock(), createBlock(_component_NodeErrorView, {
          key: 2,
          error: _ctx.workflowRunErrorAsNodeError,
          class: normalizeClass(_ctx.$style.dataDisplay)
        }, null, 8, ["error", "class"])) : createCommentVNode("", true)
      ], 2)) : _ctx.hasNodeRun && (!_ctx.unfilteredDataCount || _ctx.search && !_ctx.dataCount) && _ctx.branches.length > 1 ? (openBlock(), createElementBlock("div", {
        key: 8,
        class: normalizeClass(_ctx.$style.center)
      }, [
        _ctx.search ? (openBlock(), createElementBlock("div", _hoisted_3$a, [
          createVNode(_component_n8n_text, {
            tag: "h3",
            size: "large"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.search.noMatch.title")), 1)
            ]),
            _: 1
          }),
          createVNode(_component_n8n_text, null, {
            default: withCtx(() => [
              createVNode(_component_i18n_t, {
                keypath: "ndv.search.noMatch.description",
                tag: "span"
              }, {
                link: withCtx(() => [
                  createBaseVNode("a", {
                    href: "#",
                    onClick: _cache[7] || (_cache[7] = (...args) => _ctx.onSearchClear && _ctx.onSearchClear(...args))
                  }, toDisplayString(_ctx.$locale.baseText("ndv.search.noMatch.description.link")), 1)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])) : (openBlock(), createBlock(_component_n8n_text, { key: 1 }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.noDataInBranchMessage), 1)
          ]),
          _: 1
        }))
      ], 2)) : _ctx.hasNodeRun && !_ctx.inputData.length && !_ctx.search ? (openBlock(), createElementBlock("div", {
        key: 9,
        class: normalizeClass(_ctx.$style.center)
      }, [
        renderSlot(_ctx.$slots, "no-output-data", {}, () => [
          _cache[14] || (_cache[14] = createTextVNode("xxx"))
        ], true)
      ], 2)) : _ctx.hasNodeRun && !_ctx.showData ? (openBlock(), createElementBlock("div", {
        key: 10,
        class: normalizeClass(_ctx.$style.center)
      }, [
        createVNode(_component_n8n_text, {
          bold: true,
          color: "text-dark",
          size: "large"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.tooMuchDataTitle), 1)
          ]),
          _: 1
        }),
        createVNode(_component_n8n_text, {
          align: "center",
          tag: "div"
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("span", null, null, 512), [
              [
                _directive_n8n_html,
                _ctx.$locale.baseText("ndv.output.tooMuchData.message", {
                  interpolate: { size: _ctx.dataSizeInMB }
                })
              ]
            ])
          ]),
          _: 1
        }),
        createVNode(_component_n8n_button, {
          outline: "",
          label: _ctx.$locale.baseText("ndv.output.tooMuchData.showDataAnyway"),
          onClick: _ctx.showTooMuchData
        }, null, 8, ["label", "onClick"]),
        createVNode(_component_n8n_button, {
          size: "small",
          label: _ctx.$locale.baseText("runData.downloadBinaryData"),
          onClick: _cache[8] || (_cache[8] = ($event) => _ctx.downloadJsonData())
        }, null, 8, ["label"])
      ], 2)) : _ctx.hasNodeRun && _ctx.$slots["content"] ? renderSlot(_ctx.$slots, "content", { key: 11 }, void 0, true) : _ctx.hasNodeRun && _ctx.displayMode === "table" && _ctx.binaryData.length > 0 && _ctx.inputData.length === 1 && Object.keys(_ctx.jsonData[0] || {}).length === 0 ? (openBlock(), createElementBlock("div", {
        key: 12,
        class: normalizeClass(_ctx.$style.center)
      }, [
        createVNode(_component_n8n_text, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.switchToBinary.info")) + " ", 1),
            createBaseVNode("a", {
              onClick: _cache[9] || (_cache[9] = (...args) => _ctx.switchToBinary && _ctx.switchToBinary(...args))
            }, toDisplayString(_ctx.$locale.baseText("runData.switchToBinary.binary")), 1)
          ]),
          _: 1
        })
      ], 2)) : _ctx.showIoSearchNoMatchContent ? (openBlock(), createElementBlock("div", {
        key: 13,
        class: normalizeClass(_ctx.$style.center)
      }, [
        createVNode(_component_n8n_text, {
          tag: "h3",
          size: "large"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.search.noMatch.title")), 1)
          ]),
          _: 1
        }),
        createVNode(_component_n8n_text, null, {
          default: withCtx(() => [
            createVNode(_component_i18n_t, {
              keypath: "ndv.search.noMatch.description",
              tag: "span"
            }, {
              link: withCtx(() => [
                createBaseVNode("a", {
                  href: "#",
                  onClick: _cache[10] || (_cache[10] = (...args) => _ctx.onSearchClear && _ctx.onSearchClear(...args))
                }, toDisplayString(_ctx.$locale.baseText("ndv.search.noMatch.description.link")), 1)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ], 2)) : _ctx.hasNodeRun && _ctx.displayMode === "table" && _ctx.node ? (openBlock(), createBlock(Suspense, { key: 14 }, {
        default: withCtx(() => [
          createVNode(_component_LazyRunDataTable, {
            node: _ctx.node,
            "input-data": _ctx.inputDataPage,
            "mapping-enabled": _ctx.mappingEnabled,
            "distance-from-active": _ctx.distanceFromActive,
            "run-index": _ctx.runIndex,
            "page-offset": _ctx.currentPageOffset,
            "total-runs": _ctx.maxRunIndex,
            "has-default-hover-state": _ctx.paneType === "input" && !_ctx.search,
            search: _ctx.search,
            onMounted: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("tableMounted", $event)),
            onActiveRowChanged: _ctx.onItemHover,
            onDisplayModeChange: _ctx.onDisplayModeChange
          }, null, 8, ["node", "input-data", "mapping-enabled", "distance-from-active", "run-index", "page-offset", "total-runs", "has-default-hover-state", "search", "onActiveRowChanged", "onDisplayModeChange"])
        ]),
        _: 1
      })) : _ctx.hasNodeRun && _ctx.displayMode === "json" && _ctx.node ? (openBlock(), createBlock(Suspense, { key: 15 }, {
        default: withCtx(() => [
          createVNode(_component_LazyRunDataJson, {
            "pane-type": _ctx.paneType,
            "edit-mode": _ctx.editMode,
            "push-ref": _ctx.pushRef,
            node: _ctx.node,
            "input-data": _ctx.inputDataPage,
            "mapping-enabled": _ctx.mappingEnabled,
            "distance-from-active": _ctx.distanceFromActive,
            "run-index": _ctx.runIndex,
            "total-runs": _ctx.maxRunIndex,
            search: _ctx.search
          }, null, 8, ["pane-type", "edit-mode", "push-ref", "node", "input-data", "mapping-enabled", "distance-from-active", "run-index", "total-runs", "search"])
        ]),
        _: 1
      })) : _ctx.hasNodeRun && _ctx.isPaneTypeOutput && _ctx.displayMode === "html" ? (openBlock(), createBlock(Suspense, { key: 16 }, {
        default: withCtx(() => [
          createVNode(_component_LazyRunDataHtml, { "input-html": _ctx.inputHtml }, null, 8, ["input-html"])
        ]),
        _: 1
      })) : _ctx.hasNodeRun && _ctx.isSchemaView ? (openBlock(), createBlock(Suspense, { key: 17 }, {
        default: withCtx(() => [
          createVNode(_component_LazyRunDataSchema, {
            nodes: _ctx.nodes,
            "mapping-enabled": _ctx.mappingEnabled,
            node: _ctx.node,
            data: _ctx.jsonData,
            "pane-type": _ctx.paneType,
            "connection-type": _ctx.connectionType,
            "run-index": _ctx.runIndex,
            "output-index": _ctx.currentOutputIndex,
            "total-runs": _ctx.maxRunIndex,
            search: _ctx.search,
            class: normalizeClass(_ctx.$style.schema),
            "onClear:search": _ctx.onSearchClear
          }, null, 8, ["nodes", "mapping-enabled", "node", "data", "pane-type", "connection-type", "run-index", "output-index", "total-runs", "search", "class", "onClear:search"])
        ]),
        _: 1
      })) : _ctx.displayMode === "binary" && _ctx.binaryData.length === 0 ? (openBlock(), createElementBlock("div", {
        key: 18,
        class: normalizeClass(_ctx.$style.center)
      }, [
        createVNode(_component_n8n_text, {
          align: "center",
          tag: "div"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.noBinaryDataFound")), 1)
          ]),
          _: 1
        })
      ], 2)) : _ctx.displayMode === "binary" ? (openBlock(), createElementBlock("div", {
        key: 19,
        class: normalizeClass(_ctx.$style.dataDisplay)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.binaryData, (binaryDataEntry, index) => {
          return openBlock(), createElementBlock("div", { key: index }, [
            _ctx.binaryData.length > 1 ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.$style.binaryIndex)
            }, [
              createBaseVNode("div", null, toDisplayString(index + 1), 1)
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.binaryRow)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(binaryDataEntry, (binaryData, key) => {
                return openBlock(), createElementBlock("div", {
                  key: index + "_" + key,
                  class: normalizeClass(_ctx.$style.binaryCell)
                }, [
                  createBaseVNode("div", {
                    "data-test-id": "ndv-binary-data_" + index
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.$style.binaryHeader)
                    }, toDisplayString(key), 3),
                    binaryData.fileName ? (openBlock(), createElementBlock("div", _hoisted_5$3, [
                      createBaseVNode("div", null, [
                        createVNode(_component_n8n_text, {
                          size: "small",
                          bold: true
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.fileName")) + ": ", 1)
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.$style.binaryValue)
                      }, toDisplayString(binaryData.fileName), 3)
                    ])) : createCommentVNode("", true),
                    binaryData.directory ? (openBlock(), createElementBlock("div", _hoisted_6$3, [
                      createBaseVNode("div", null, [
                        createVNode(_component_n8n_text, {
                          size: "small",
                          bold: true
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.directory")) + ": ", 1)
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.$style.binaryValue)
                      }, toDisplayString(binaryData.directory), 3)
                    ])) : createCommentVNode("", true),
                    binaryData.fileExtension ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
                      createBaseVNode("div", null, [
                        createVNode(_component_n8n_text, {
                          size: "small",
                          bold: true
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.fileExtension")) + ":", 1)
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.$style.binaryValue)
                      }, toDisplayString(binaryData.fileExtension), 3)
                    ])) : createCommentVNode("", true),
                    binaryData.mimeType ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
                      createBaseVNode("div", null, [
                        createVNode(_component_n8n_text, {
                          size: "small",
                          bold: true
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.mimeType")) + ": ", 1)
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.$style.binaryValue)
                      }, toDisplayString(binaryData.mimeType), 3)
                    ])) : createCommentVNode("", true),
                    binaryData.fileSize ? (openBlock(), createElementBlock("div", _hoisted_9$1, [
                      createBaseVNode("div", null, [
                        createVNode(_component_n8n_text, {
                          size: "small",
                          bold: true
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(_ctx.$locale.baseText("runData.fileSize")) + ": ", 1)
                          ]),
                          _: 1
                        })
                      ]),
                      createBaseVNode("div", {
                        class: normalizeClass(_ctx.$style.binaryValue)
                      }, toDisplayString(binaryData.fileSize), 3)
                    ])) : createCommentVNode("", true),
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.$style.binaryButtonContainer)
                    }, [
                      _ctx.isViewable(index, key) ? (openBlock(), createBlock(_component_n8n_button, {
                        key: 0,
                        size: "small",
                        label: _ctx.$locale.baseText("runData.showBinaryData"),
                        "data-test-id": "ndv-view-binary-data",
                        onClick: ($event) => _ctx.displayBinaryData(index, key)
                      }, null, 8, ["label", "onClick"])) : createCommentVNode("", true),
                      _ctx.isDownloadable(index, key) ? (openBlock(), createBlock(_component_n8n_button, {
                        key: 1,
                        size: "small",
                        type: "secondary",
                        label: _ctx.$locale.baseText("runData.downloadBinaryData"),
                        "data-test-id": "ndv-download-binary-data",
                        onClick: ($event) => _ctx.downloadBinaryData(index, key)
                      }, null, 8, ["label", "onClick"])) : createCommentVNode("", true)
                    ], 2)
                  ], 8, _hoisted_4$4)
                ], 2);
              }), 128))
            ], 2)
          ]);
        }), 128))
      ], 2)) : createCommentVNode("", true)
    ], 2),
    _ctx.hasNodeRun && !_ctx.hasRunError && _ctx.binaryData.length === 0 && _ctx.dataCount > _ctx.pageSize && !_ctx.isSchemaView && !_ctx.isArtificialRecoveredEventItem ? withDirectives((openBlock(), createElementBlock("div", {
      key: 7,
      class: normalizeClass(_ctx.$style.pagination),
      "data-test-id": "ndv-data-pagination"
    }, [
      createVNode(_component_el_pagination, {
        background: "",
        "hide-on-single-page": true,
        "current-page": _ctx.currentPage,
        "pager-count": 5,
        "page-size": _ctx.pageSize,
        layout: "prev, pager, next",
        total: _ctx.dataCount,
        "onUpdate:currentPage": _ctx.onCurrentPageChange
      }, null, 8, ["current-page", "page-size", "total", "onUpdate:currentPage"]),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.pageSizeSelector)
      }, [
        createVNode(_component_n8n_select, {
          size: "mini",
          "model-value": _ctx.pageSize,
          teleported: "",
          "onUpdate:modelValue": _ctx.onPageSizeChange
        }, {
          prepend: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.pageSize")), 1)
          ]),
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pageSizes, (size) => {
              return openBlock(), createBlock(_component_n8n_option, {
                key: size,
                label: size,
                value: size
              }, null, 8, ["label", "value"]);
            }), 128)),
            createVNode(_component_n8n_option, {
              label: _ctx.$locale.baseText("ndv.output.all"),
              value: _ctx.dataCount
            }, null, 8, ["label", "value"])
          ]),
          _: 1
        }, 8, ["model-value", "onUpdate:modelValue"])
      ], 2)
    ], 2)), [
      [vShow, !_ctx.editMode.enabled]
    ]) : createCommentVNode("", true),
    createVNode(_component_n8n_block_ui, {
      show: _ctx.blockUI,
      class: normalizeClass(_ctx.$style.uiBlocker)
    }, null, 8, ["show", "class"])
  ], 34);
}
const cssModules$u = {
  "$style": style0$s
};
const __unplugin_components_3 = /* @__PURE__ */ _export_sfc$1(_sfc_main$N, [["render", _sfc_render$6], ["__cssModules", cssModules$u], ["__scopeId", "data-v-714627a3"]]);
const _sfc_main$M = /* @__PURE__ */ defineComponent({
  __name: "RunInfo",
  props: {
    taskData: {},
    hasStaleData: { type: Boolean },
    hasPinData: { type: Boolean }
  },
  setup(__props) {
    const i18n2 = useI18n();
    const props = __props;
    const runTaskData = computed(() => {
      return props.taskData;
    });
    const theme = computed(() => {
      var _a;
      return ((_a = props.taskData) == null ? void 0 : _a.error) ? "danger" : "success";
    });
    const runMetadata = computed(() => {
      if (!runTaskData.value) {
        return null;
      }
      const { date, time } = convertToDisplayDateComponents(runTaskData.value.startTime);
      return {
        executionTime: runTaskData.value.executionTime,
        startTime: `${date} at ${time}`
      };
    });
    return (_ctx, _cache) => {
      const _component_n8n_info_tip = resolveComponent("n8n-info-tip");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return _ctx.hasStaleData ? (openBlock(), createBlock(_component_n8n_info_tip, {
        key: 0,
        theme: "warning",
        type: "tooltip",
        "tooltip-placement": "right",
        "data-test-id": "node-run-info-stale"
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("span", null, null, 512), [
            [
              _directive_n8n_html,
              unref(i18n2).baseText(
                _ctx.hasPinData ? "ndv.output.staleDataWarning.pinData" : "ndv.output.staleDataWarning.regular"
              )
            ]
          ])
        ]),
        _: 1
      })) : runMetadata.value ? (openBlock(), createBlock(_component_n8n_info_tip, {
        key: 1,
        type: "tooltip",
        theme: theme.value,
        "data-test-id": `node-run-info-${theme.value}`,
        "tooltip-placement": "right"
      }, {
        default: withCtx(() => [
          createBaseVNode("div", null, [
            createVNode(_component_n8n_text, {
              bold: true,
              size: "small"
            }, {
              default: withCtx(() => {
                var _a;
                return [
                  createTextVNode(toDisplayString(((_a = runTaskData.value) == null ? void 0 : _a.error) ? unref(i18n2).baseText("runData.executionStatus.failed") : unref(i18n2).baseText("runData.executionStatus.success")), 1)
                ];
              }),
              _: 1
            }),
            _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
            createVNode(_component_n8n_text, {
              bold: true,
              size: "small"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n2).baseText("runData.startTime") + ":"), 1)
              ]),
              _: 1
            }),
            createTextVNode(" " + toDisplayString(runMetadata.value.startTime), 1),
            _cache[1] || (_cache[1] = createBaseVNode("br", null, null, -1)),
            createVNode(_component_n8n_text, {
              bold: true,
              size: "small"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(unref(i18n2).baseText("runData.executionTime") + ":"), 1)
              ]),
              _: 1
            }),
            createTextVNode(" " + toDisplayString(runMetadata.value.executionTime) + " " + toDisplayString(unref(i18n2).baseText("runData.ms")), 1)
          ])
        ]),
        _: 1
      }, 8, ["theme", "data-test-id"])) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$L = /* @__PURE__ */ defineComponent({
  __name: "OutputPanel",
  props: {
    workflow: {},
    runIndex: {},
    isReadOnly: { type: Boolean },
    linkedRuns: { type: Boolean },
    canLinkRuns: { type: Boolean },
    pushRef: {},
    blockUI: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    isPaneActive: { type: Boolean, default: false }
  },
  emits: ["linkRun", "unlinkRun", "runChange", "activatePane", "tableMounted", "itemHover", "search", "openSettings"],
  setup(__props, { emit: __emit }) {
    const OUTPUT_TYPE = {
      REGULAR: "regular",
      LOGS: "logs"
    };
    const props = __props;
    const emit = __emit;
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const workflowsStore = useWorkflowsStore();
    const uiStore = useUIStore();
    const telemetry = useTelemetry();
    const i18n2 = useI18n();
    const { activeNode } = storeToRefs(ndvStore);
    const { isSubNodeType: isSubNodeType2 } = useNodeType({
      node: activeNode
    });
    const pinnedData2 = usePinnedData(activeNode, {
      runIndex: props.runIndex,
      displayMode: ndvStore.getPanelDisplayMode("output")
    });
    const outputMode = ref(OUTPUT_TYPE.REGULAR);
    const outputTypes = ref([
      { label: i18n2.baseText("ndv.output.outType.regular"), value: OUTPUT_TYPE.REGULAR },
      { label: i18n2.baseText("ndv.output.outType.logs"), value: OUTPUT_TYPE.LOGS }
    ]);
    const runDataRef = ref(null);
    const node2 = computed(() => {
      return ndvStore.activeNode ?? void 0;
    });
    const isTriggerNode = computed(() => {
      return !!node2.value && nodeTypesStore.isTriggerNode(node2.value.type);
    });
    const hasAiMetadata = computed(() => {
      if (node2.value) {
        const resultData = workflowsStore.getWorkflowResultDataByNodeName(node2.value.name);
        if (!resultData || !Array.isArray(resultData) || resultData.length === 0) {
          return false;
        }
        return !!resultData[resultData.length - 1].metadata;
      }
      return false;
    });
    const defaultOutputMode = computed(() => {
      var _a, _b;
      const hasError = workflowRunData.value && node2.value && ((_b = (_a = workflowRunData.value[node2.value.name]) == null ? void 0 : _a[props.runIndex]) == null ? void 0 : _b.error);
      return Boolean(hasError) && hasAiMetadata.value ? OUTPUT_TYPE.LOGS : OUTPUT_TYPE.REGULAR;
    });
    const isNodeRunning = computed(() => {
      return workflowRunning.value && !!node2.value && workflowsStore.isNodeExecuting(node2.value.name);
    });
    const workflowRunning = computed(() => {
      return uiStore.isActionActive["workflowRunning"];
    });
    const workflowExecution = computed(() => {
      return workflowsStore.getWorkflowExecution;
    });
    const workflowRunData = computed(() => {
      var _a;
      if (workflowExecution.value === null) {
        return null;
      }
      const executionData = workflowExecution.value.data;
      if (!((_a = executionData == null ? void 0 : executionData.resultData) == null ? void 0 : _a.runData)) {
        return null;
      }
      return executionData.resultData.runData;
    });
    const hasNodeRun = computed(() => {
      if (workflowsStore.subWorkflowExecutionError) return true;
      return Boolean(
        node2.value && workflowRunData.value && workflowRunData.value.hasOwnProperty(node2.value.name)
      );
    });
    const runTaskData = computed(() => {
      if (!node2.value || workflowExecution.value === null) {
        return null;
      }
      const runData2 = workflowRunData.value;
      if (runData2 === null || !runData2.hasOwnProperty(node2.value.name)) {
        return null;
      }
      if (runData2[node2.value.name].length <= props.runIndex) {
        return null;
      }
      return runData2[node2.value.name][props.runIndex];
    });
    const runsCount = computed(() => {
      if (node2.value === null) {
        return 0;
      }
      const runData2 = workflowRunData.value;
      if (runData2 === null || node2.value && !runData2.hasOwnProperty(node2.value.name)) {
        return 0;
      }
      if (node2.value && runData2[node2.value.name].length) {
        return runData2[node2.value.name].length;
      }
      return 0;
    });
    const staleData = computed(() => {
      if (!node2.value) {
        return false;
      }
      const updatedAt = workflowsStore.getParametersLastUpdate(node2.value.name);
      if (!updatedAt || !runTaskData.value) {
        return false;
      }
      const runAt = runTaskData.value.startTime;
      return updatedAt > runAt;
    });
    const outputPanelEditMode = computed(() => {
      return ndvStore.outputPanelEditMode;
    });
    const canPinData = computed(() => {
      return pinnedData2.isValidNodeType.value && !props.isReadOnly;
    });
    const insertTestData = () => {
      var _a;
      if (!runDataRef.value) return;
      runDataRef.value.enterEditMode({
        origin: "insertTestDataLink"
      });
      telemetry.track("User clicked ndv link", {
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        node_type: (_a = node2.value) == null ? void 0 : _a.type,
        pane: "output",
        type: "insert-test-data"
      });
    };
    const onLinkRun = () => {
      emit("linkRun");
    };
    const onUnlinkRun = () => {
      emit("unlinkRun");
    };
    const openSettings = () => {
      var _a;
      emit("openSettings");
      telemetry.track("User clicked ndv link", {
        node_type: (_a = node2.value) == null ? void 0 : _a.type,
        workflow_id: workflowsStore.workflowId,
        push_ref: props.pushRef,
        pane: "output",
        type: "settings"
      });
    };
    const onRunIndexChange = (run) => {
      emit("runChange", run);
    };
    const onUpdateOutputMode = (outputMode2) => {
      if (outputMode2 === OUTPUT_TYPE.LOGS) {
        ndvEventBus.emit("setPositionByName", "minLeft");
      } else {
        ndvEventBus.emit("setPositionByName", "initial");
      }
    };
    onMounted(() => {
      outputMode.value = defaultOutputMode.value;
    });
    watch(defaultOutputMode, (newValue, oldValue) => {
      if (newValue === OUTPUT_TYPE.LOGS && oldValue === OUTPUT_TYPE.REGULAR && hasNodeRun.value) {
        outputMode.value = defaultOutputMode.value;
      }
    });
    const activatePane = () => {
      emit("activatePane");
    };
    return (_ctx, _cache) => {
      const _component_n8n_radio_buttons = resolveComponent("n8n-radio-buttons");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createBlock(__unplugin_components_3, {
        ref_key: "runDataRef",
        ref: runDataRef,
        node: node2.value,
        workflow: _ctx.workflow,
        "run-index": _ctx.runIndex,
        "linked-runs": _ctx.linkedRuns,
        "can-link-runs": _ctx.canLinkRuns,
        "too-much-data-title": _ctx.$locale.baseText("ndv.output.tooMuchData.title"),
        "no-data-in-branch-message": _ctx.$locale.baseText("ndv.output.noOutputDataInBranch"),
        "is-executing": isNodeRunning.value,
        "executing-message": _ctx.$locale.baseText("ndv.output.executing"),
        "push-ref": _ctx.pushRef,
        "block-u-i": _ctx.blockUI,
        "is-production-execution-preview": _ctx.isProductionExecutionPreview,
        "is-pane-active": _ctx.isPaneActive,
        "pane-type": "output",
        "data-output-type": outputMode.value,
        onActivatePane: activatePane,
        onRunChange: onRunIndexChange,
        onLinkRun,
        onUnlinkRun,
        onTableMounted: _cache[1] || (_cache[1] = ($event) => emit("tableMounted", $event)),
        onItemHover: _cache[2] || (_cache[2] = ($event) => emit("itemHover", $event)),
        onSearch: _cache[3] || (_cache[3] = ($event) => emit("search", $event))
      }, createSlots({
        header: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.titleSection)
          }, [
            hasAiMetadata.value ? (openBlock(), createBlock(_component_n8n_radio_buttons, {
              key: 0,
              "data-test-id": "ai-output-mode-select",
              modelValue: outputMode.value,
              "onUpdate:modelValue": [
                _cache[0] || (_cache[0] = ($event) => outputMode.value = $event),
                onUpdateOutputMode
              ],
              options: outputTypes.value
            }, null, 8, ["modelValue", "options"])) : (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(_ctx.$style.title)
            }, toDisplayString(_ctx.$locale.baseText(outputPanelEditMode.value.enabled ? "ndv.output.edit" : "ndv.output")), 3)),
            hasNodeRun.value && !unref(pinnedData2).hasData.value && runsCount.value === 1 ? withDirectives((openBlock(), createBlock(_sfc_main$M, {
              key: 2,
              "task-data": runTaskData.value,
              "has-stale-data": staleData.value,
              "has-pin-data": unref(pinnedData2).hasData.value
            }, null, 8, ["task-data", "has-stale-data", "has-pin-data"])), [
              [vShow, !outputPanelEditMode.value.enabled]
            ]) : createCommentVNode("", true)
          ], 2)
        ]),
        "node-not-run": withCtx(() => [
          workflowRunning.value && !isTriggerNode.value ? (openBlock(), createBlock(_component_n8n_text, {
            key: 0,
            "data-test-id": "ndv-output-waiting"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.waitingToRun")), 1)
            ]),
            _: 1
          })) : createCommentVNode("", true),
          !workflowRunning.value ? (openBlock(), createBlock(_component_n8n_text, {
            key: 1,
            "data-test-id": "ndv-output-run-node-hint"
          }, {
            default: withCtx(() => [
              unref(isSubNodeType2) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.runNodeHintSubNode")), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.runNodeHint")) + " ", 1),
                canPinData.value ? (openBlock(), createElementBlock("span", {
                  key: 0,
                  onClick: insertTestData
                }, [
                  _cache[4] || (_cache[4] = createBaseVNode("br", null, null, -1)),
                  createTextVNode(" " + toDisplayString(_ctx.$locale.baseText("generic.or")) + " ", 1),
                  createVNode(_component_n8n_text, {
                    tag: "a",
                    size: "medium",
                    color: "primary"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.insertTestData")), 1)
                    ]),
                    _: 1
                  })
                ])) : createCommentVNode("", true)
              ], 64))
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ]),
        "node-waiting": withCtx(() => [
          createVNode(_component_n8n_text, {
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => _cache[5] || (_cache[5] = [
              createTextVNode("Waiting for input")
            ])),
            _: 1
          }),
          withDirectives(createVNode(_component_n8n_text, null, null, 512), [
            [_directive_n8n_html, unref(waitingNodeTooltip)()]
          ])
        ]),
        "no-output-data": withCtx(() => [
          createVNode(_component_n8n_text, {
            bold: true,
            color: "text-dark",
            size: "large"
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.noOutputData.title")), 1)
            ]),
            _: 1
          }),
          createVNode(_component_n8n_text, null, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.output.noOutputData.message")) + " ", 1),
              createBaseVNode("a", { onClick: openSettings }, toDisplayString(_ctx.$locale.baseText("ndv.output.noOutputData.message.settings")), 1),
              createTextVNode(" " + toDisplayString(_ctx.$locale.baseText("ndv.output.noOutputData.message.settingsOption")), 1)
            ]),
            _: 1
          })
        ]),
        "recovered-artificial-output-data": withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.recoveredOutputData)
          }, [
            createVNode(_component_n8n_text, {
              tag: "div",
              bold: true,
              color: "text-dark",
              size: "large"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("executionDetails.executionFailed.recoveredNodeTitle")), 1)
              ]),
              _: 1
            }),
            createVNode(_component_n8n_text, null, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("executionDetails.executionFailed.recoveredNodeMessage")), 1)
              ]),
              _: 1
            })
          ], 2)
        ]),
        _: 2
      }, [
        outputMode.value === "logs" && node2.value ? {
          name: "content",
          fn: withCtx(() => [
            createVNode(RunDataAi, {
              node: node2.value,
              "run-index": _ctx.runIndex
            }, null, 8, ["node", "run-index"])
          ]),
          key: "0"
        } : void 0,
        !unref(pinnedData2).hasData.value && runsCount.value > 1 ? {
          name: "run-info",
          fn: withCtx(() => [
            createVNode(_sfc_main$M, { "task-data": runTaskData.value }, null, 8, ["task-data"])
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["node", "workflow", "run-index", "linked-runs", "can-link-runs", "too-much-data-title", "no-data-in-branch-message", "is-executing", "executing-message", "push-ref", "block-u-i", "is-production-execution-preview", "is-pane-active", "data-output-type"]);
    };
  }
});
const outputTypeSelect = "_outputTypeSelect_f1tu5_6";
const titleSection$1 = "_titleSection_f1tu5_11";
const title$2 = "_title_f1tu5_11";
const noOutputData$1 = "_noOutputData_f1tu5_27";
const recoveredOutputData$1 = "_recoveredOutputData_f1tu5_37";
const style0$r = {
  outputTypeSelect,
  titleSection: titleSection$1,
  title: title$2,
  noOutputData: noOutputData$1,
  recoveredOutputData: recoveredOutputData$1
};
const cssModules$t = {
  "$style": style0$r
};
const OutputPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$L, [["__cssModules", cssModules$t]]);
const _sfc_main$K = {};
const _hoisted_1$i = {
  width: "112",
  height: "80",
  viewBox: "0 0 112 80",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
};
function _sfc_render$5(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$i, _cache[0] || (_cache[0] = [
    createStaticVNode('<mask id="mask0_489_46042" style="mask-type:alpha;" maskUnits="userSpaceOnUse" x="0" y="0" width="112" height="80"><rect width="112" height="80" fill="url(#paint0_linear_489_46042)"></rect></mask><g mask="url(#mask0_489_46042)"><rect x="-0.5" width="112" height="80" fill="url(#pattern0)" fill-opacity="0.6"></rect></g><defs><pattern id="pattern0" patternContentUnits="objectBoundingBox" width="1" height="1"><use xlink:href="#image0_489_46042" transform="scale(0.00357143 0.005)"></use></pattern><linearGradient id="paint0_linear_489_46042" x1="90.5" y1="40.4494" x2="112.5" y2="40.4494" gradientUnits="userSpaceOnUse"><stop></stop><stop offset="1" stop-color="white" stop-opacity="0"></stop></linearGradient><image id="image0_489_46042" width="280" height="200" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADICAYAAAAzx/4XAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAABhdSURBVHgB7d0JcFTVngbw/72d4IYa0Ie4IK2llgpodNwtB9AaxVILF7ZxynkgWupojaRwASXQGEBqEAI8LXfBpZQS9IFabjMFkXFfijCKyqjQqIiKShCUpdP3vvPdpXP7pjtk6dPdSX+/qlPpJX07UfrL/yz3XEOIPJNiswaZkbKBtkiluC0qRB1gCJW86ntmjzYM81YvWIhyhgFTwlCxGJGyBcJKhTQxhUrSpJraKSpcVgjDhTQqEyo5U+6prbVExmV6TnWT6ixbnuxmSZ262xCLVTUIUTsxYEoMKpdM4aKCZV5ZUmIMFMoljsGUkMk1c9RArjE39HBchcuYadVVdUKUYwyYEjEhVhstj8gqdbMi8HA8kpTBqmqJC5EGHOQtEeVlMkXSw6WB4UK6cQymBKB6UYMso4OPWYZMrWG4kGasYEpAmWGHB3Xj0ydVzRUizRgwJcAwjaFpD9gyVYjygAHTxTndo9Bium2WLBWiPGDAdHFlkWT4/KK6uVzrQnnCgOniDNuIBu/blr1aiPKEAdPF2Xba1DQeYfVCecOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBEpA0Dhoi0YcAQkTYMGCLShgFDRNowYIhIGwYMEWnDgCEibRgwRKQNA4aItGHAEJE2DBgi0oYBQ0TaMGCISBsGDBFpw4AhIm0YMESkDQOGiLRhwBCRNgwYItKGAUNE2hhCXc7ll19eUVZWNto0zYFGJDLIamys8J+LRMrilpWst217WSKRqFu6dGlciDRhwHQho0aNilqWVavC4/I2vGyhCpqpDBrSISLUJYwcOfJWFS6vq5vHS9tURiKRcf3795c1a9a8JUQ5xAqmk0N3qLy8/O/q5iDpIMMwlu7evXuMqmYahCgHOMjbyalwWSE5CBdA18o7HlFOsIvUiY0YMaJWfWnLeEtr9FbdpQrVXXpDiDqIXaROavjw4aPVlwWiiapmBi9ZsqROiDqAXaTOa4popMZjtIUXlQ4GTCfkVS9R0SvqvQ9RuzFgOqe/Sn7k632oi+IYTCfjTUtvkTxJJBI9OG1N7cUKppMpKyurlDzK9/tR18KA6Xzy+oG3LCsqRO3EgOl8KiSPTNOMClE7MWCISJsyIUcsVlvRGJEVhm3Nq5k8fqEUr3wPuHKAl9qNFYwnFqtqMND9MMwF1TW16yfXzLl1Qqw2KkXGtu245Fe9ELUTAybAaPprHbXFmFsekfXV02oX3BX7r6KZSUkmk3WSR42NjQwYajcGTIBl2aubPWjL6EikfJWqalZU3zN7tBSYtyalTvJAVUt1XANDHcExmDTofmRdezhIdZ8GqaCZYog9d3fSWDYzVhWXwnhScrRFQ0sMw3hSiDqAFUyAZUi8Fd9W8O5TIpFYqr7ERa/44sWLFwpRBzBggiJm28YbCtR9QrfFsqwq0WuqEHUQz0UKwFR1MiIdOc8nns/u01VXXTXXNM1bJcdUeM174YUXxglRBzFgQlQ1goDp+GpZQxYmGxPzZsTu0DYL4534iC0uc9lNq1ddo1OEKAfYRQoYpyoYI1djG6r7ZEbKF+CYogm6Smo8ZjA265YcwHFwPCHKkZKrYPCB31cSUTEjlaYtUSNi9rVtqTTcqiUqOWKLzCtLql5XrCov07zDhg2LqYBo9y53akq6asmSJXOFKIe6ZMDEYvdGG6W80jKNioiYJ6vfUs38qDBxA0T7yYJqNqpq+qSqvH9YceG1xsZGBE1bNorihddIm04ZMMEqJILAMFWI2E5wYCwiKoUTV0E2Zlp1VZ0UEIImmUwOUjeHRiKRSnU76j9nlpU1WI2NdapieUuF0UIupCOdijZgUIXslkhFhq5MVPRWIQ3tOb4KlnrVJboiVrjFdxlNmjo7ZphmqutkW9bUaVPGx4QoDwq6ktfvyhimEVV/W/uiKyNuFVKRVC110SbEoJ2zNGywMZ1sSL2dtLdahlFvGtKgwqEe4aCmqqNqqnp9Ww6Y7/EWos5Ca8Bk6cpExa1CoipEdJVQ6Ko0uCFibbAMM94tIvWSkPieQgAho6aqpbUKNd5C1Bl0OGCaDaiaUpHelSlv+mZbcimuWr1t2RvUoGbcNiSOKkQ91pCDSiIuex7LccZbVLjUhR5vT2bm9r8MUZHYY8CgCqmQnRVZujKpKiTVnclTV0b0QlBFsz2ZZbzFCH0N3w4dIo3Riu/Z0+NERScVMM5Je1nWhiRlb21dGcGHWQWHWLJahVVDa7syOjlVkZn5Nw6Nt4S/yQg0LGJECJ+n2nGqdVPtO9XeUW2lagnZw4+R4bYdeE8GDRW9VMCURcoX2PhA5HhA1WvNujLFNtsSZBjetg12+mfYErtq+uTx86QpQFIvkab/ZOgTnqlajWpniBssQY2qrVJtumornMOK9BQ3jE5XrY9q3VXbodo61d5U7TPVtgeO4QcNQ4aKWipgsNmS+qvdnnNaAl2ZtAHVhmIOkZbYKmCM9HCJJ3bvGjtz2sT/FffDv7e4/+3wTegl7lJtt3f/JHHD5VzVjH333Ve6deuGZfjYHU62b99eZts2gmS+ajHVvlZtjGqjVNsnw4+DkxkfVW2OapuF1Qx1IoExmBY3W1LPFV9XRhcracUjpulUMKq8WP3Lr1uGPzx/Gk6CPFu1gaqdrNrB4lYjP6n2iWr/p9pG1W5X7Z9UM4499li59NJL5ZRTTnFC5ssvv5Tly5fL+++/L7t370alMkO1TaqdYqr36969uxx44IG42Bm2xpStW7fK77//fqAKpPHiVkYIpR+897Wl5WBh6FDBNQWMaSJAFhZgQLXYGNbO5AZzn4gkLWv+199+O23xgr/tpR7/V9VuUK1fhtdcLW43BhXOaart07NnT5kzZ44MGTLECQxABTN06FAZM2aM1NfXI817oyFcEEbnn3++DBgwwAmZbdu2yTvvvCNvvPGGbN68WRVU9s3ijt9sFbdqOki1fcUNEoTfL9I0rhOsbogKJhUw06qrcEZuTs7K7exmzpy49a7qe8feWzPxKXErh39TrVq1ngiLCjWv1qNHD+ybggpDGhoasMtcf/X8ieJ9sC+88EI599xzU+ECuH3MMcfIyJEjETCpxw8++GCpqqqSa665RtCl8g0fPlzuuusuWbRoEaoZHOhKcSumY8Ttgh0pbjWD6ul/xJ39+i3wq7CKoYLinrzpUlPNM9xwwQAtQuM/VeuJILjgggucdvTRRzsVyTfffCPLli2T9957D1VHauD3zDPPdLpFYfvtt5+cdtppTpD8+eefzmP9+vWTgQMHpoULoAq69tpr5e2333a6S8r54obLaaHDXqTaNar9TbUnVPtVguGC8SSDBQ3lHwOmueA0MwZdMRN01D777COnnnqq1NTUON2ZIHRr7rzzTidkfAcddJBEIpHmB1cfdARV37595YsvvnAeQ0X0l7/8JeMPc8IJJ8ghhxwin3/+ObZU6KUe6uUfPxqNyo4dO2TdunXGzp07D1UP/4dq34hbiWJ2Cq8x8J4MGSoEbjjVJLhQLhgwGNB1xkVQuYTDBc444ww5++yz5YADDkg9tv/++zthkgnCChUQIITQ3cLxM8FxjjrqKCkvb1oRjdCZMWOGzJs3zxnnufrqq3ENaTyFMZ1LxR2ANv3fif0kKhRWMOnCC+XQMMDrjJ+EuzC+vfbay+n2YEB2zZo1zmP+1HQme++9t1OV+LdRwQTHasJQ7SBg1MyTc//mm2+W66+/3jk+xoHw3GuvvSabNm3CQfp4zRmLsdWkO+sWKhRWMJkFF9JhdsYZL9m4cWPWF5x++ulOpeGHSksBg0BCFwdQoWTrHvmOOOKIVAWDMBoxYkTq2KhcevXq5by3Zz9xK5iI83uoAEL3yKlibNYylF8MmHTh6sWfoXEGWT/99NPUwGwYxkMwJY1qA10m3M80BgPoEmGGqbKy0hkMRmsJxn4wOIxQwXuEAwlhhuDx74obMs7vkFRjMIwVKhR2kVzBpf7BbhICZr1qW5LJZA/MGK1du9ZZOBeGLs5ll13mTEPj9mGHHeaPizSDQBg8eLAzZoNqpn///tISjPvMmjVLNmzYIIMGDWr2PN4Hx/Eg1RAyTsBgkDdVubCzRHnGgMkcLH4Fg9vbxK1iBm7evNlZhZspYODII4902h7fUH3QES4ImdbA2M+wYcOcGSNUMpkEwsw/uT01yEtUKKXeRco0c4SG2ZgrVLtRtb+KNxGDBXXvvvsuVtZKvmEMBqGUrdsVkgpIO5k0/HMK2FWifCvlCiZT5YJp6RGqjVXtEO++3+Vwzg/CepS6ujpnlW2RMkKNqGBYwTRVLvuLe8byveIurouKGzKYkUktcME09EsvveSvrC16lhAVTqlWMMHqxe9O3CbuuT7OdMzxxx/vnAmNLsknn3wiK1eudNah7Nq1ywmZVatWZRxwLQScsrBz507/LjIFJz2ygqGCK+Uukj8Iiq/YcW6keOFyww03yN133+2sUcHgKaqV5557TqZOnepMU3/77bfO1gvFEjDougWmzxEuu4WoCJRiwGSaLbpANWdxyVlnnSUPPfRQ2gswuDp27Fhn1ezEiROdr63xww8/yPr16+Wcc85ptugOA8aYkcIpAlg3Ex68xZQ0zrg++eSTpU+fPi0O7qKCCXTZEC47hKgIlOoYTDBk8MnFMlhnqewll1yS8QVYeYvl+Y8++qjMnDnTmTZuCVb94gzp8847T6qrq9OeQxg888wzcvHFF8tNN90kL7/8ctrzv/zyi0yYMEGuvPJKufHGG+Wrr75q8b3QbcNrPOgrdY4BIurySrmCQbj660XKvcdSS/gzwXPXXXedtAbGabBXjG3bznYLQVjP8v333zu3f/vtN6fLFYSw2LJli1Mpff3119hms8X3QsD8+uuv/l30lRAwzsw0l2pTIZXav7/wJUX8CuYP8SZc8IHvTBBgCKA//vjDuStuBfO7EBWBUvwDF5xd8cdgUttNrlu3TjqTRCIh8Xg8dVfczaawCTnX1VHBlXIFHewqob/iBAy6NnYnOusYAYOBZA+ql58leOUBNQvGVXdUKFxo58In1Pmrj5W6GP/o8IEDs0aYRtYFa3NwlrcH/SR/TwlWMFRwpV7B+PChxEhrI3bzf/7556WjsGudHzLZtnjoKExPYzr7448/9h/CANL/S9OpR9gvk0FDBVPKARP84KHEeEu89SNPPPFEh09oxJYNfsDoqmAwsPvqq6/6U9T42dHVQ1Cmn9+In4NbNVABlGLAhK/57DcsRomrlvzoo4/kvvvuS21RWawwIP3444/7dzG4i8vMImgwI8YTqKngSi1ggpdd9ZvlNVwxEbvxO4tO8MFdunRpq1ft5hsGonH6gjfrhSTEJWhxWYNguLCLRAVV6l0kS9JD5lVxr87oLFybPXu2rFixQnINXSd/gygERXtCDCdfPvvss/5d9JH+W7Ufpel3SS20S80gsZtEeVaqXaRgwwCJ5X3FwMsDqq3CN+JcICzz/+CDDySXcF6Rv8UlBmrb2hVbvXq1cyVIbxNyTK9jqTACxgo1VjBUUKVawQS7R37I+A19DlwhcR0++NiWAdce+uyzzySXgicvtqWCQWU1efJk5+cS9+fHz/uCuDNIflimmmFGbFYuVCilXMH4H0L/Q9no3cbXD1Wbr9pm7LPyyiuvSG1tbcFX+SKIHnzwQXn99df9hzCw+4i4ewYHQ5KDvFQUSn0Mxg+a4IcTAYM+CwZfZqm2BetYsDYGlcN3333XqoMfeuihqbUwuMJAEK4qgEuXADb0Dp9giX1ounfv7rwWx8HF2QAXV3vssceCXaoHxb3o/W7v5/ZD0g9PB8dfqFBatYN0F5TppMdwQ/g0iLv0/sxEIlGOcEFFc+KJJ2a91KsPwYFrUGNnPGy5cPjhh6eewxoZvB7PY9OqK664wgkVHwIFe9DgciWjRo2Sk046yTkDe/z48c64kKdO3IDBVQ8QLAlJr8KcKmbg4Iv+WQXVoFTA2PZbK+verBOiPCjVHe0QHn6I+GMwqOYS3vP+SZAIl9dU66Vme67fsmVL+YIFC+Tnn3+W6dOnOxdZywZVysiRI51qI3ypEYy/IHjuuOOO8DWNUq+96KKLnMua4Htx//777xesz/HOk8Ks0Qxxt2VISnq4sItERaPUr4sUnk0KngDp38bWB4vFvUb1v2/durUcm36j4sBMznHHHZf14AiOcHgEZbvWNaDK8a9XjbGXxYsXC05j8Dyh2iZp6hZlC5emlbxEBVDKAROsYvzxiuAVHYMnIP+k2jOq7VIVxLXbt2/f++mnn3bOMbrttttkwIABohO23sSWDN5sE6qVl6SpagmHS7ARFVSpn02daU1MIktDyDyl2gMqZLbhPKCnnnpKbr/9dmeLh/ZAcNxyyy3Su3dv6devnzz88MPBKiUF2zFg1zoPRpl/C/1smWaQRNhFogLjpWObPoTBv/jB7pIEvqK7hDUn+LTfotoBb775pnOdJAziBi5Av0c//vijzJ8/Xx544AHn/k8//SRTpkxxFt5hn97gda2xQXjghMmNkh4o4XDh+AsVDW7Zmnm62p+V8S8BEqwWMLD6d9UeVu1nDLouX77cuYxJa2FbTgQTAsZ7b6e7g5BZtGiRfPjhh2lnYKN6CWyCtUOyj70EqxeigmPAuIJdinDQBMPGb9jg5RPVPseLsGQfVUZrYYOoWbNmOVPP4p5cWe8dy8a1r1ER4Zh+qIQueWJK5vEWW9g1oiLDLlKTTFPXRuh5/3vQsO2ds7k2LkPiX4wNMLUcvg4SwgLbW2ItDS7g5p16gLDCiU4LVTtBtR5qILcPVuuiizRkyBBnvQwqG7zWg+s3ZQsXdo2oqDBg0vkBgg+tXymINL9YW3DTcKfL88gjj8iLL77oBAMWygXHUABjK9iKEwHj7aGLY8dVW6baN+IO3PZW7SpVDVXgTO4lS5Y44zp4XWBXvL7e+zJYqOgxYJoLhox4t4NB4y/CA2clNFb34vrVbYBuF1IG+898JE1ncmO7CKzK+xd1zB5r167N1IXtJu51nFi9UNFjwGQWDhlfsILBtDVOisSJRPuGno9I8038cUzMPmHnf8wEYd+ZleKGjR8MOJtyobhbX1aqdqB3LASQf0lY7PD9hzBYqBNgwGQXDBm/e+QP/vrXUkIFgg98T0m/UmQ3aQqi4DQ4ggELXbBvrn/1xeDMD74f4YNFfW94x8WxEt7rMO6zSTKfDsCQoaLDgGlZeLVveJUvQgZBgS5LRJoCxsxwnEzbRPiDyb5gFwxVzEbJvAgwKaxgqBNgwLROOBwQMqb31YcP/Z4CxsrS/IDwqx5T0isgW9L3rOGCOuoUGDB7FuyCBM9bagw8jsf8cMk2/tJSwPiCYzzB2apM+9bwrGkqegyY1guGCzQGHiuTpqom05VagwETDppgQISnws0Mr/cXAPK8Iyp6DJjWC6/2Dd72181ASwETrmQyVR/h7SLCxwhu88kxGCpqDJjWCa/ytaR5WIR3xAu/Pjzj01LA7Cmk2DWiToEB03Z+mJiB28GAEckcMMHbVuhxO/S6TCHlf1+msGLQUFFiwLSeX8X4ty1pHiit2TouU7cmU8BI6Lad5StR0WLAtE0wCMKDs209RkvPtTY8GDJU1Bgw7WNnuW+04TVEXR4DJrcYIkQB3HCKiLRhwBCRNgwYItKGAUNE2jBgiEgbBgwRacOAISJtGDBdnGFI2gWbjIjZV4jyhAHTxdmGHU9/QKJClCcMmC6uLBmpDz1UOS5W2/qLaBN1AAOmi4vFquLiXuDNV7GfaY0WojxgwJQA27KeDN43DXOoEOUBA6YElNnmwtBDg6rvmT1OiDRjwJQAdJNssdOqGDHMKRNitVEh0ogBUyLKkkZMfQlOWVeUR2QFQ4Z0YsCUCGew15CpoYejCJlJNbWDhEiDtmz1SF2ACpOY+p8+pdkThixMNMrUme6sE1FOMGBK0KSaOXMNMW7N8vRSNe20LGkl62fE7qgXog5gwJSorJUMUQ4xYEoYxl7UP4AF6mZUiDRgwJBU31M7Wv1LQDUTFaIcYsBQSmx6bWVjo3W5mOZAww2bqBB1wD8AobUpv0xPqN8AAAAASUVORK5CYII="></image></defs>', 3)
  ]));
}
const __unplugin_components_2$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$K, [["render", _sfc_render$5]]);
const _hoisted_1$h = { key: 0 };
const _sfc_main$J = /* @__PURE__ */ defineComponent({
  __name: "InputNodeSelect",
  props: {
    nodes: {},
    workflow: {},
    modelValue: {}
  },
  emits: ["update:model-value"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const i18n2 = useI18n();
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const selectedInputNode = computed(() => workflowsStore.getNodeByName(props.modelValue ?? ""));
    const selectedInputNodeType = computed(() => {
      const node2 = selectedInputNode.value;
      if (!node2) return null;
      return nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    });
    const inputNodes = computed(
      () => props.nodes.map((node2) => {
        const fullNode = workflowsStore.getNodeByName(node2.name);
        if (!fullNode) return null;
        return {
          node: fullNode,
          type: nodeTypesStore.getNodeType(fullNode.type, fullNode.typeVersion),
          depth: node2.depth
        };
      }).filter(isPresent)
    );
    const activeNode = computed(() => ndvStore.activeNode);
    const activeNodeType = computed(() => {
      const node2 = activeNode.value;
      if (!node2) return null;
      return nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    });
    const isMultiInputNode = computed(() => {
      const nodeType = activeNodeType.value;
      return nodeType !== null && nodeType.inputs.length > 1;
    });
    const connectedTo = (nodeName) => {
      const connections2 = ndvStore.ndvNodeInputNumber[nodeName];
      if (!connections2) return "";
      if (connections2.length === 1) {
        return `Input ${ndvStore.ndvNodeInputNumber[nodeName]}`;
      }
      return `Inputs ${ndvStore.ndvNodeInputNumber[nodeName].join(", ")}`;
    };
    function getMultipleNodesText(nodeName) {
      var _a;
      if (!nodeName || !isMultiInputNode.value || !activeNode.value || !((_a = activeNodeType.value) == null ? void 0 : _a.inputNames))
        return "";
      const activeNodeConnections = props.workflow.connectionsByDestinationNode[activeNode.value.name].main || [];
      const connectedInputIndexes = activeNodeConnections.reduce((acc, node2, index) => {
        if (node2[0] && node2[0].node === nodeName) return [...acc, index];
        return acc;
      }, []);
      const connectedInputs = connectedInputIndexes.map(
        (inputIndex) => {
          var _a2, _b;
          return (_b = (_a2 = activeNodeType.value) == null ? void 0 : _a2.inputNames) == null ? void 0 : _b[inputIndex];
        }
      );
      if (connectedInputs.length === 0) return "";
      return `(${connectedInputs.join(" & ")})`;
    }
    function title2(nodeName, length = 30) {
      return truncate(nodeName, length);
    }
    function subtitle2(nodeName, depth) {
      const multipleNodesText = getMultipleNodesText(nodeName);
      if (multipleNodesText) return multipleNodesText;
      return i18n2.baseText("ndv.input.nodeDistance", { adjustToNumber: depth });
    }
    function onInputNodeChange(value) {
      emit("update:model-value", value);
    }
    return (_ctx, _cache) => {
      const _component_n8n_option = resolveComponent("n8n-option");
      const _component_n8n_select = resolveComponent("n8n-select");
      return openBlock(), createBlock(_component_n8n_select, {
        "model-value": _ctx.modelValue,
        "no-data-text": unref(i18n2).baseText("ndv.input.noNodesFound"),
        placeholder: unref(i18n2).baseText("ndv.input.parentNodes"),
        class: normalizeClass(_ctx.$style.select),
        teleported: "",
        size: "small",
        filterable: "",
        "data-test-id": "ndv-input-select",
        "onUpdate:modelValue": onInputNodeChange
      }, {
        prefix: withCtx(() => {
          var _a;
          return [
            createVNode(_sfc_main$10, {
              disabled: (_a = selectedInputNode.value) == null ? void 0 : _a.disabled,
              "node-type": selectedInputNodeType.value,
              size: 14,
              shrink: false
            }, null, 8, ["disabled", "node-type"])
          ];
        }),
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(inputNodes.value, ({ node: node2, type, depth }) => {
            return openBlock(), createBlock(_component_n8n_option, {
              key: node2.name,
              value: node2.name,
              class: normalizeClass([_ctx.$style.node, { [_ctx.$style.disabled]: node2.disabled }]),
              label: `${title2(node2.name)} ${getMultipleNodesText(node2.name)}`,
              "data-test-id": "ndv-input-option"
            }, {
              default: withCtx(() => [
                createVNode(_sfc_main$10, {
                  disabled: node2.disabled,
                  "node-type": type,
                  size: 14,
                  shrink: false,
                  class: normalizeClass(_ctx.$style.icon)
                }, null, 8, ["disabled", "node-type", "class"]),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.$style.title)
                }, [
                  createTextVNode(toDisplayString(title2(node2.name)) + " ", 1),
                  node2.disabled ? (openBlock(), createElementBlock("span", _hoisted_1$h, "(" + toDisplayString(unref(i18n2).baseText("node.disabled")) + ")", 1)) : createCommentVNode("", true)
                ], 2),
                createBaseVNode("span", {
                  class: normalizeClass(_ctx.$style.subtitle)
                }, toDisplayString(connectedTo(node2.name) ? connectedTo(node2.name) : subtitle2(node2.name, depth)), 3)
              ]),
              _: 2
            }, 1032, ["value", "class", "label"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["model-value", "no-data-text", "placeholder", "class"]);
    };
  }
});
const select$3 = "_select_68vpa_1";
const node$1 = "_node_68vpa_10";
const icon = "_icon_68vpa_18";
const title$1 = "_title_68vpa_22";
const disabled$1 = "_disabled_68vpa_31";
const subtitle$1 = "_subtitle_68vpa_35";
const style0$q = {
  select: select$3,
  node: node$1,
  icon,
  title: title$1,
  disabled: disabled$1,
  subtitle: subtitle$1
};
const cssModules$s = {
  "$style": style0$q
};
const __unplugin_components_0$7 = /* @__PURE__ */ _export_sfc$1(_sfc_main$J, [["__cssModules", cssModules$s]]);
const _sfc_main$I = defineComponent({
  name: "InputPanel",
  components: { RunData: __unplugin_components_3, NodeExecuteButton: _sfc_main$W, WireMeUp: __unplugin_components_2$1, InputNodeSelect: __unplugin_components_0$7 },
  props: {
    currentNodeName: {
      type: String
    },
    runIndex: {
      type: Number,
      required: true
    },
    linkedRuns: {
      type: Boolean
    },
    workflow: {
      type: Object,
      required: true
    },
    canLinkRuns: {
      type: Boolean
    },
    pushRef: {
      type: String
    },
    readOnly: {
      type: Boolean
    },
    isProductionExecutionPreview: {
      type: Boolean,
      default: false
    },
    isPaneActive: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "itemHover",
    "tableMounted",
    "linkRun",
    "unlinkRun",
    "runChange",
    "search",
    "changeInputNode",
    "execute",
    "activatePane"
  ],
  data() {
    return {
      showDraggableHintWithDelay: false,
      draggableHintShown: false,
      inputMode: "debugging",
      mappedNode: null,
      inputModes: [
        { value: "mapping", label: this.$locale.baseText("ndv.input.mapping") },
        { value: "debugging", label: this.$locale.baseText("ndv.input.debugging") }
      ]
    };
  },
  computed: {
    ...mapStores(useNodeTypesStore, useNDVStore, useWorkflowsStore, useUIStore),
    focusedMappableInput() {
      return this.ndvStore.focusedMappableInput;
    },
    isUserOnboarded() {
      return this.ndvStore.isMappingOnboarded;
    },
    isMappingMode() {
      return this.isActiveNodeConfig && this.inputMode === "mapping";
    },
    showDraggableHint() {
      const toIgnore = [
        START_NODE_TYPE,
        MANUAL_TRIGGER_NODE_TYPE,
        CRON_NODE_TYPE,
        INTERVAL_NODE_TYPE
      ];
      if (!this.currentNode || toIgnore.includes(this.currentNode.type)) {
        return false;
      }
      return !!this.focusedMappableInput && !this.isUserOnboarded;
    },
    isActiveNodeConfig() {
      var _a, _b;
      let inputs2 = ((_a = this.activeNodeType) == null ? void 0 : _a.inputs) ?? [];
      let outputs2 = ((_b = this.activeNodeType) == null ? void 0 : _b.outputs) ?? [];
      if (this.activeNode !== null && this.workflow !== null) {
        const node2 = this.workflow.getNode(this.activeNode.name);
        inputs2 = getNodeInputs(this.workflow, node2, this.activeNodeType);
        outputs2 = getNodeOutputs(this.workflow, node2, this.activeNodeType);
      } else {
        if (!Array.isArray(inputs2)) {
          inputs2 = [];
        }
        if (!Array.isArray(outputs2)) {
          outputs2 = [];
        }
      }
      if (inputs2.length === 0 || inputs2.every((input) => this.filterOutConnectionType(input, NodeConnectionType.Main)) && outputs2.find((output) => this.filterOutConnectionType(output, NodeConnectionType.Main))) {
        return true;
      }
      return false;
    },
    isMappingEnabled() {
      if (this.readOnly) return false;
      if (this.isActiveNodeConfig) return this.isMappingMode && this.mappedNode !== null;
      return true;
    },
    isExecutingPrevious() {
      if (!this.workflowRunning) {
        return false;
      }
      const triggeredNode = this.workflowsStore.executedNode;
      const executingNode = this.workflowsStore.executingNode;
      if (this.activeNode && triggeredNode === this.activeNode.name && !this.workflowsStore.isNodeExecuting(this.activeNode.name)) {
        return true;
      }
      if (executingNode.length || triggeredNode) {
        return !!this.parentNodes.find(
          (node2) => this.workflowsStore.isNodeExecuting(node2.name) || node2.name === triggeredNode
        );
      }
      return false;
    },
    workflowRunning() {
      return this.uiStore.isActionActive["workflowRunning"];
    },
    activeNode() {
      return this.ndvStore.activeNode;
    },
    rootNode() {
      var _a;
      const workflow = this.workflow;
      const rootNodes = workflow.getChildNodes(((_a = this.activeNode) == null ? void 0 : _a.name) ?? "", "ALL_NON_MAIN");
      return rootNodes[0];
    },
    rootNodesParents() {
      const workflow = this.workflow;
      const parentNodes = [...workflow.getParentNodes(this.rootNode, NodeConnectionType.Main)].reverse().map((parent) => ({ name: parent, depth: 1, indicies: [] }));
      return parentNodes;
    },
    currentNode() {
      if (this.isActiveNodeConfig) {
        if (this.mappedNode) {
          return this.workflowsStore.getNodeByName(this.mappedNode);
        }
        return this.activeNode;
      }
      return this.workflowsStore.getNodeByName(this.currentNodeName ?? "");
    },
    connectedCurrentNodeOutputs() {
      const search2 = this.parentNodes.find(({ name }) => name === this.currentNodeName);
      if (search2) {
        return search2.indicies;
      }
      return void 0;
    },
    parentNodes() {
      if (!this.activeNode) {
        return [];
      }
      const nodes = this.workflow.getParentNodesByDepth(this.activeNode.name);
      return nodes.filter(
        ({ name }, i) => this.activeNode && name !== this.activeNode.name && nodes.findIndex((node2) => node2.name === name) === i
      );
    },
    currentNodeDepth() {
      const node2 = this.parentNodes.find(
        (parent) => this.currentNode && parent.name === this.currentNode.name
      );
      return node2 ? node2.depth : -1;
    },
    activeNodeType() {
      if (!this.activeNode) return null;
      return this.nodeTypesStore.getNodeType(this.activeNode.type, this.activeNode.typeVersion);
    },
    isMultiInputNode() {
      return this.activeNodeType !== null && this.activeNodeType.inputs.length > 1;
    },
    waitingMessage() {
      return waitingNodeTooltip();
    }
  },
  watch: {
    inputMode: {
      handler(val) {
        var _a;
        this.onRunIndexChange(-1);
        if (val === "mapping") {
          this.onUnlinkRun();
          this.mappedNode = ((_a = this.rootNodesParents[0]) == null ? void 0 : _a.name) ?? null;
        } else {
          this.mappedNode = null;
        }
      },
      immediate: true
    },
    showDraggableHint(curr, prev) {
      if (curr && !prev) {
        setTimeout(() => {
          if (this.draggableHintShown) {
            return;
          }
          this.showDraggableHintWithDelay = this.showDraggableHint;
          if (this.showDraggableHintWithDelay) {
            this.draggableHintShown = true;
            this.$telemetry.track("User viewed data mapping tooltip", {
              type: "unexecuted input pane"
            });
          }
        }, 1e3);
      } else if (!curr) {
        this.showDraggableHintWithDelay = false;
      }
    }
  },
  methods: {
    filterOutConnectionType(item, type) {
      if (!item) return false;
      return typeof item === "string" ? item !== type : item.type !== type;
    },
    onInputModeChange(val) {
      this.inputMode = val;
    },
    onMappedNodeSelected(val) {
      this.mappedNode = val;
      this.onRunIndexChange(0);
      this.onUnlinkRun();
    },
    onNodeExecute() {
      this.$emit("execute");
      if (this.activeNode) {
        this.$telemetry.track("User clicked ndv button", {
          node_type: this.activeNode.type,
          workflow_id: this.workflowsStore.workflowId,
          push_ref: this.pushRef,
          pane: "input",
          type: "executePrevious"
        });
      }
    },
    onRunIndexChange(run) {
      this.$emit("runChange", run);
    },
    onLinkRun() {
      this.$emit("linkRun");
    },
    onUnlinkRun() {
      this.$emit("unlinkRun");
    },
    onInputNodeChange(value) {
      const index = this.parentNodes.findIndex((node2) => node2.name === value) + 1;
      this.$emit("changeInputNode", value, index);
    },
    onConnectionHelpClick() {
      if (this.activeNode) {
        this.$telemetry.track("User clicked ndv link", {
          node_type: this.activeNode.type,
          workflow_id: this.workflowsStore.workflowId,
          push_ref: this.pushRef,
          pane: "input",
          type: "not-connected-help"
        });
      }
    },
    activatePane() {
      this.$emit("activatePane");
    }
  }
});
const mappedNode = "_mappedNode_17wvq_1";
const titleSection = "_titleSection_17wvq_5";
const inputModeTab = "_inputModeTab_17wvq_14";
const noOutputData = "_noOutputData_17wvq_18";
const recoveredOutputData = "_recoveredOutputData_17wvq_28";
const notConnected = "_notConnected_17wvq_37";
const title = "_title_17wvq_5";
const style0$p = {
  mappedNode,
  titleSection,
  inputModeTab,
  noOutputData,
  recoveredOutputData,
  notConnected,
  title
};
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_n8n_radio_buttons = resolveComponent("n8n-radio-buttons");
  const _component_InputNodeSelect = __unplugin_components_0$7;
  const _component_n8n_text = resolveComponent("n8n-text");
  const _component_NodeExecuteButton = _sfc_main$W;
  const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
  const _component_WireMeUp = __unplugin_components_2$1;
  const _component_RunData = __unplugin_components_3;
  const _directive_n8n_html = resolveDirective("n8n-html");
  return openBlock(), createBlock(_component_RunData, {
    node: _ctx.currentNode,
    nodes: _ctx.isMappingMode ? _ctx.rootNodesParents : _ctx.parentNodes,
    workflow: _ctx.workflow,
    "run-index": _ctx.runIndex,
    "linked-runs": _ctx.linkedRuns,
    "can-link-runs": !_ctx.mappedNode && _ctx.canLinkRuns,
    "too-much-data-title": _ctx.$locale.baseText("ndv.input.tooMuchData.title"),
    "no-data-in-branch-message": _ctx.$locale.baseText("ndv.input.noOutputDataInBranch"),
    "is-executing": _ctx.isExecutingPrevious,
    "executing-message": _ctx.$locale.baseText("ndv.input.executingPrevious"),
    "push-ref": _ctx.pushRef,
    "override-outputs": _ctx.connectedCurrentNodeOutputs,
    "mapping-enabled": _ctx.isMappingEnabled,
    "distance-from-active": _ctx.currentNodeDepth,
    "is-production-execution-preview": _ctx.isProductionExecutionPreview,
    "is-pane-active": _ctx.isPaneActive,
    "pane-type": "input",
    "data-test-id": "ndv-input-panel",
    onActivatePane: _ctx.activatePane,
    onItemHover: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("itemHover", $event)),
    onLinkRun: _ctx.onLinkRun,
    onUnlinkRun: _ctx.onUnlinkRun,
    onRunChange: _ctx.onRunIndexChange,
    onTableMounted: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("tableMounted", $event)),
    onSearch: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("search", $event))
  }, createSlots({
    header: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.titleSection)
      }, [
        createBaseVNode("span", {
          class: normalizeClass(_ctx.$style.title)
        }, toDisplayString(_ctx.$locale.baseText("ndv.input")), 3),
        _ctx.isActiveNodeConfig && !_ctx.readOnly ? (openBlock(), createBlock(_component_n8n_radio_buttons, {
          key: 0,
          options: _ctx.inputModes,
          "model-value": _ctx.inputMode,
          "onUpdate:modelValue": _ctx.onInputModeChange
        }, null, 8, ["options", "model-value", "onUpdate:modelValue"])) : createCommentVNode("", true)
      ], 2)
    ]),
    "input-select": withCtx(() => [
      _ctx.parentNodes.length && _ctx.currentNodeName ? (openBlock(), createBlock(_component_InputNodeSelect, {
        key: 0,
        "model-value": _ctx.currentNodeName,
        workflow: _ctx.workflow,
        nodes: _ctx.parentNodes,
        "onUpdate:modelValue": _ctx.onInputNodeChange
      }, null, 8, ["model-value", "workflow", "nodes", "onUpdate:modelValue"])) : createCommentVNode("", true)
    ]),
    "node-not-run": withCtx(() => [
      _ctx.isActiveNodeConfig && _ctx.rootNode || _ctx.parentNodes.length ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.$style.noOutputData)
      }, [
        createVNode(_component_n8n_text, {
          tag: "div",
          bold: true,
          color: "text-dark",
          size: "large"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.noOutputData.title")), 1)
          ]),
          _: 1
        }),
        !_ctx.readOnly ? (openBlock(), createBlock(_component_n8n_tooltip, {
          key: 0,
          visible: _ctx.showDraggableHint && _ctx.showDraggableHintWithDelay
        }, {
          content: withCtx(() => [
            withDirectives(createBaseVNode("div", null, null, 512), [
              [
                _directive_n8n_html,
                _ctx.$locale.baseText("dataMapping.dragFromPreviousHint", {
                  interpolate: { name: _ctx.focusedMappableInput }
                })
              ]
            ])
          ]),
          default: withCtx(() => [
            createVNode(_component_NodeExecuteButton, {
              type: "secondary",
              "hide-icon": "",
              transparent: true,
              "node-name": _ctx.isActiveNodeConfig ? _ctx.rootNode : _ctx.currentNodeName ?? "",
              label: _ctx.$locale.baseText("ndv.input.noOutputData.executePrevious"),
              "telemetry-source": "inputs",
              "data-test-id": "execute-previous-node",
              onExecute: _ctx.onNodeExecute
            }, null, 8, ["node-name", "label", "onExecute"])
          ]),
          _: 1
        }, 8, ["visible"])) : createCommentVNode("", true),
        !_ctx.readOnly ? (openBlock(), createBlock(_component_n8n_text, {
          key: 1,
          tag: "div",
          size: "small"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.noOutputData.hint")), 1)
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ], 2)) : (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.$style.notConnected)
      }, [
        createBaseVNode("div", null, [
          createVNode(_component_WireMeUp)
        ]),
        createVNode(_component_n8n_text, {
          tag: "div",
          bold: true,
          color: "text-dark",
          size: "large"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.notConnected.title")), 1)
          ]),
          _: 1
        }),
        createVNode(_component_n8n_text, { tag: "div" }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.notConnected.message")) + " ", 1),
            createBaseVNode("a", {
              href: "https://docs.n8n.io/workflows/connections/",
              target: "_blank",
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onConnectionHelpClick && _ctx.onConnectionHelpClick(...args))
            }, toDisplayString(_ctx.$locale.baseText("ndv.input.notConnected.learnMore")), 1)
          ]),
          _: 1
        })
      ], 2))
    ]),
    "node-waiting": withCtx(() => [
      createVNode(_component_n8n_text, {
        bold: true,
        color: "text-dark",
        size: "large"
      }, {
        default: withCtx(() => _cache[5] || (_cache[5] = [
          createTextVNode("Waiting for input")
        ])),
        _: 1
      }),
      withDirectives(createVNode(_component_n8n_text, null, null, 512), [
        [_directive_n8n_html, _ctx.waitingMessage]
      ])
    ]),
    "no-output-data": withCtx(() => [
      createVNode(_component_n8n_text, {
        tag: "div",
        bold: true,
        color: "text-dark",
        size: "large"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.input.noOutputData")), 1)
        ]),
        _: 1
      })
    ]),
    "recovered-artificial-output-data": withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.$style.recoveredOutputData)
      }, [
        createVNode(_component_n8n_text, {
          tag: "div",
          bold: true,
          color: "text-dark",
          size: "large"
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("executionDetails.executionFailed.recoveredNodeTitle")), 1)
          ]),
          _: 1
        }),
        createVNode(_component_n8n_text, null, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("executionDetails.executionFailed.recoveredNodeMessage")), 1)
          ]),
          _: 1
        })
      ], 2)
    ]),
    _: 2
  }, [
    _ctx.isMappingMode ? {
      name: "before-data",
      fn: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent("style"), null, {
          default: withCtx(() => _cache[4] || (_cache[4] = [
            createTextVNode("button.linkRun { display: none }")
          ])),
          _: 1
        })),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.$style.mappedNode)
        }, [
          createVNode(_component_InputNodeSelect, {
            "model-value": _ctx.mappedNode,
            workflow: _ctx.workflow,
            nodes: _ctx.rootNodesParents,
            "onUpdate:modelValue": _ctx.onMappedNodeSelected
          }, null, 8, ["model-value", "workflow", "nodes", "onUpdate:modelValue"])
        ], 2)
      ]),
      key: "0"
    } : void 0
  ]), 1032, ["node", "nodes", "workflow", "run-index", "linked-runs", "can-link-runs", "too-much-data-title", "no-data-in-branch-message", "is-executing", "executing-message", "push-ref", "override-outputs", "mapping-enabled", "distance-from-active", "is-production-execution-preview", "is-pane-active", "onActivatePane", "onLinkRun", "onUnlinkRun", "onRunChange"]);
}
const cssModules$r = {
  "$style": style0$p
};
const InputPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$I, [["render", _sfc_render$4], ["__cssModules", cssModules$r]]);
const _sfc_main$H = defineComponent({
  name: "TriggerPanel",
  components: {
    NodeExecuteButton: _sfc_main$W,
    CopyInput,
    NodeIcon: _sfc_main$10
  },
  props: {
    nodeName: {
      type: String,
      required: true
    },
    pushRef: {
      type: String,
      default: ""
    }
  },
  emits: { activate: null, execute: null },
  setup() {
    const router = useRouter();
    const workflowHelpers = useWorkflowHelpers({ router });
    return {
      workflowHelpers
    };
  },
  data: () => {
    return {
      executionsHelpEventBus: createEventBus()
    };
  },
  computed: {
    ...mapStores(useNodeTypesStore, useNDVStore, useUIStore, useWorkflowsStore),
    node() {
      return this.workflowsStore.getNodeByName(this.nodeName);
    },
    nodeType() {
      if (this.node) {
        return this.nodeTypesStore.getNodeType(this.node.type, this.node.typeVersion);
      }
      return null;
    },
    triggerPanel() {
      var _a;
      const panel = (_a = this.nodeType) == null ? void 0 : _a.triggerPanel;
      if (isTriggerPanelObject(panel)) {
        return panel;
      }
      return void 0;
    },
    hideContent() {
      var _a;
      const hideContent = (_a = this.triggerPanel) == null ? void 0 : _a.hideContent;
      if (typeof hideContent === "boolean") {
        return hideContent;
      }
      if (this.node) {
        const hideContentValue = this.workflowHelpers.getCurrentWorkflow().expression.getSimpleParameterValue(this.node, hideContent, "internal", {});
        if (typeof hideContentValue === "boolean") {
          return hideContentValue;
        }
      }
      return false;
    },
    hasIssues() {
      var _a;
      return Boolean(
        ((_a = this.node) == null ? void 0 : _a.issues) && (this.node.issues.parameters ?? this.node.issues.credentials)
      );
    },
    serviceName() {
      if (this.nodeType) {
        return getTriggerNodeServiceName(this.nodeType);
      }
      return "";
    },
    displayChatButton() {
      return Boolean(
        this.node && this.node.type === CHAT_TRIGGER_NODE_TYPE && this.node.parameters.mode !== "webhook"
      );
    },
    isWebhookNode() {
      return Boolean(this.node && this.node.type === WEBHOOK_NODE_TYPE);
    },
    webhookHttpMethod() {
      var _a, _b;
      if (!this.node || !((_b = (_a = this.nodeType) == null ? void 0 : _a.webhooks) == null ? void 0 : _b.length)) {
        return void 0;
      }
      const httpMethod = this.workflowHelpers.getWebhookExpressionValue(
        this.nodeType.webhooks[0],
        "httpMethod",
        false
      );
      if (Array.isArray(httpMethod)) {
        return httpMethod.join(", ");
      }
      return httpMethod;
    },
    webhookTestUrl() {
      var _a, _b;
      if (!this.node || !((_b = (_a = this.nodeType) == null ? void 0 : _a.webhooks) == null ? void 0 : _b.length)) {
        return void 0;
      }
      return this.workflowHelpers.getWebhookUrl(this.nodeType.webhooks[0], this.node, "test");
    },
    isWebhookBasedNode() {
      var _a, _b;
      return Boolean((_b = (_a = this.nodeType) == null ? void 0 : _a.webhooks) == null ? void 0 : _b.length);
    },
    isPollingNode() {
      var _a;
      return Boolean((_a = this.nodeType) == null ? void 0 : _a.polling);
    },
    isListeningForEvents() {
      const waitingOnWebhook = this.workflowsStore.executionWaitingForWebhook;
      const executedNode = this.workflowsStore.executedNode;
      return !!this.node && !this.node.disabled && this.isWebhookBasedNode && waitingOnWebhook && (!executedNode || executedNode === this.nodeName);
    },
    workflowRunning() {
      return this.uiStore.isActionActive["workflowRunning"];
    },
    isActivelyPolling() {
      const triggeredNode = this.workflowsStore.executedNode;
      return this.workflowRunning && this.isPollingNode && this.nodeName === triggeredNode;
    },
    isWorkflowActive() {
      return this.workflowsStore.isWorkflowActive;
    },
    listeningTitle() {
      var _a;
      return ((_a = this.nodeType) == null ? void 0 : _a.name) === FORM_TRIGGER_NODE_TYPE ? this.$locale.baseText("ndv.trigger.webhookNode.formTrigger.listening") : this.$locale.baseText("ndv.trigger.webhookNode.listening");
    },
    listeningHint() {
      var _a;
      switch ((_a = this.nodeType) == null ? void 0 : _a.name) {
        case CHAT_TRIGGER_NODE_TYPE:
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.chatTrigger.serviceHint");
        case FORM_TRIGGER_NODE_TYPE:
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.formTrigger.serviceHint");
        default:
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.serviceHint", {
            interpolate: { service: this.serviceName }
          });
      }
    },
    header() {
      var _a;
      const serviceName = this.nodeType ? getTriggerNodeServiceName(this.nodeType) : "";
      if (this.isActivelyPolling) {
        return this.$locale.baseText("ndv.trigger.pollingNode.fetchingEvent");
      }
      if ((_a = this.triggerPanel) == null ? void 0 : _a.header) {
        return this.triggerPanel.header;
      }
      if (this.isWebhookBasedNode) {
        return this.$locale.baseText("ndv.trigger.webhookBasedNode.action", {
          interpolate: { name: serviceName }
        });
      }
      return "";
    },
    subheader() {
      const serviceName = this.nodeType ? getTriggerNodeServiceName(this.nodeType) : "";
      if (this.isActivelyPolling) {
        return this.$locale.baseText("ndv.trigger.pollingNode.fetchingHint", {
          interpolate: { name: serviceName }
        });
      }
      return "";
    },
    executionsHelp() {
      var _a;
      if ((_a = this.triggerPanel) == null ? void 0 : _a.executionsHelp) {
        if (typeof this.triggerPanel.executionsHelp === "string") {
          return this.triggerPanel.executionsHelp;
        }
        if (!this.isWorkflowActive && this.triggerPanel.executionsHelp.inactive) {
          return this.triggerPanel.executionsHelp.inactive;
        }
        if (this.isWorkflowActive && this.triggerPanel.executionsHelp.active) {
          return this.triggerPanel.executionsHelp.active;
        }
      }
      if (this.isWebhookBasedNode) {
        if (this.isWorkflowActive) {
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.executionsHelp.active", {
            interpolate: { service: this.serviceName }
          });
        } else {
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.executionsHelp.inactive", {
            interpolate: { service: this.serviceName }
          });
        }
      }
      if (this.isPollingNode) {
        if (this.isWorkflowActive) {
          return this.$locale.baseText("ndv.trigger.pollingNode.executionsHelp.active", {
            interpolate: { service: this.serviceName }
          });
        } else {
          return this.$locale.baseText("ndv.trigger.pollingNode.executionsHelp.inactive", {
            interpolate: { service: this.serviceName }
          });
        }
      }
      return "";
    },
    activationHint() {
      if (this.isActivelyPolling || !this.triggerPanel) {
        return "";
      }
      if (this.triggerPanel.activationHint) {
        if (typeof this.triggerPanel.activationHint === "string") {
          return this.triggerPanel.activationHint;
        }
        if (!this.isWorkflowActive && typeof this.triggerPanel.activationHint.inactive === "string") {
          return this.triggerPanel.activationHint.inactive;
        }
        if (this.isWorkflowActive && typeof this.triggerPanel.activationHint.active === "string") {
          return this.triggerPanel.activationHint.active;
        }
      }
      if (this.isWebhookBasedNode) {
        if (this.isWorkflowActive) {
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.activationHint.active", {
            interpolate: { service: this.serviceName }
          });
        } else {
          return this.$locale.baseText("ndv.trigger.webhookBasedNode.activationHint.inactive", {
            interpolate: { service: this.serviceName }
          });
        }
      }
      if (this.isPollingNode) {
        if (this.isWorkflowActive) {
          return this.$locale.baseText("ndv.trigger.pollingNode.activationHint.active", {
            interpolate: { service: this.serviceName }
          });
        } else {
          return this.$locale.baseText("ndv.trigger.pollingNode.activationHint.inactive", {
            interpolate: { service: this.serviceName }
          });
        }
      }
      return "";
    }
  },
  methods: {
    expandExecutionHelp() {
      if (this.$refs.help) {
        this.executionsHelpEventBus.emit("expand");
      }
    },
    openWebhookUrl() {
      this.$telemetry.track("User clicked ndv link", {
        workflow_id: this.workflowsStore.workflowId,
        push_ref: this.pushRef,
        pane: "input",
        type: "open-chat"
      });
      window.open(this.webhookTestUrl, "_blank", "noreferrer");
    },
    onLinkClick(e) {
      var _a;
      if (!e.target) {
        return;
      }
      const target2 = e.target;
      if (target2.localName !== "a") return;
      if ((_a = target2.dataset) == null ? void 0 : _a.key) {
        e.stopPropagation();
        e.preventDefault();
        if (target2.dataset.key === "activate") {
          this.$emit("activate");
        } else if (target2.dataset.key === "executions") {
          this.$telemetry.track("User clicked ndv link", {
            workflow_id: this.workflowsStore.workflowId,
            push_ref: this.pushRef,
            pane: "input",
            type: "open-executions-log"
          });
          this.ndvStore.activeNodeName = null;
          void this.$router.push({
            name: VIEWS.EXECUTIONS
          });
        } else if (target2.dataset.key === "settings") {
          this.uiStore.openModal(WORKFLOW_SETTINGS_MODAL_KEY);
        }
      }
    },
    onTestLinkCopied() {
      this.$telemetry.track("User copied webhook URL", {
        pane: "inputs",
        type: "test url"
      });
    },
    onNodeExecute() {
      this.$emit("execute");
    }
  }
});
const container = "_container_1evnm_1";
const header = "_header_1evnm_18";
const action = "_action_1evnm_25";
const shake$1 = "_shake_1evnm_29";
const accordion = "_accordion_1evnm_50";
const style0$o = {
  container,
  header,
  action,
  shake: shake$1,
  accordion
};
const _hoisted_1$g = { key: "empty" };
const _hoisted_2$b = { key: "listening" };
const _hoisted_3$9 = { key: 0 };
const _hoisted_4$3 = { key: 1 };
const _hoisted_5$2 = { key: 0 };
const _hoisted_6$2 = { key: "default" };
const _hoisted_7$1 = {
  key: 0,
  class: "mb-xl"
};
const _hoisted_8$1 = ["textContent"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_NodeIcon = _sfc_main$10;
  const _component_n8n_pulse = resolveComponent("n8n-pulse");
  const _component_n8n_text = resolveComponent("n8n-text");
  const _component_CopyInput = CopyInput;
  const _component_NodeExecuteButton = _sfc_main$W;
  const _component_n8n_button = resolveComponent("n8n-button");
  const _component_n8n_spinner = resolveComponent("n8n-spinner");
  const _component_n8n_heading = resolveComponent("n8n-heading");
  const _component_n8n_link = resolveComponent("n8n-link");
  const _component_n8n_info_accordion = resolveComponent("n8n-info-accordion");
  const _directive_n8n_html = resolveDirective("n8n-html");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.$style.container)
  }, [
    createVNode(Transition$2, {
      name: "fade",
      mode: "out-in"
    }, {
      default: withCtx(() => [
        _ctx.hasIssues || _ctx.hideContent ? (openBlock(), createElementBlock("div", _hoisted_1$g)) : _ctx.isListeningForEvents ? (openBlock(), createElementBlock("div", _hoisted_2$b, [
          createVNode(_component_n8n_pulse, null, {
            default: withCtx(() => [
              createVNode(_component_NodeIcon, {
                "node-type": _ctx.nodeType,
                size: 40
              }, null, 8, ["node-type"])
            ]),
            _: 1
          }),
          _ctx.isWebhookNode ? (openBlock(), createElementBlock("div", _hoisted_3$9, [
            createVNode(_component_n8n_text, {
              tag: "div",
              size: "large",
              color: "text-dark",
              class: "mb-2xs",
              bold: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.trigger.webhookNode.listening")), 1)
              ]),
              _: 1
            }),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.$style.shake, "mb-xs"])
            }, [
              createVNode(_component_n8n_text, null, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.trigger.webhookNode.requestHint", {
                    interpolate: { type: _ctx.webhookHttpMethod ?? "" }
                  })), 1)
                ]),
                _: 1
              })
            ], 2),
            createVNode(_component_CopyInput, {
              value: _ctx.webhookTestUrl,
              "toast-title": _ctx.$locale.baseText("ndv.trigger.copiedTestUrl"),
              class: "mb-2xl",
              size: "medium",
              collapse: true,
              "copy-button-text": _ctx.$locale.baseText("generic.clickToCopy"),
              onCopy: _ctx.onTestLinkCopied
            }, null, 8, ["value", "toast-title", "copy-button-text", "onCopy"]),
            createVNode(_component_NodeExecuteButton, {
              "data-test-id": "trigger-execute-button",
              "node-name": _ctx.nodeName,
              size: "medium",
              "telemetry-source": "inputs",
              onExecute: _ctx.onNodeExecute
            }, null, 8, ["node-name", "onExecute"])
          ])) : (openBlock(), createElementBlock("div", _hoisted_4$3, [
            createVNode(_component_n8n_text, {
              tag: "div",
              size: "large",
              color: "text-dark",
              class: "mb-2xs",
              bold: ""
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.listeningTitle), 1)
              ]),
              _: 1
            }),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.$style.shake, "mb-xs"])
            }, [
              createVNode(_component_n8n_text, { tag: "div" }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.listeningHint), 1)
                ]),
                _: 1
              })
            ], 2),
            _ctx.displayChatButton ? (openBlock(), createElementBlock("div", _hoisted_5$2, [
              createVNode(_component_n8n_button, {
                class: "mb-xl",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.openWebhookUrl())
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.trigger.chatTrigger.openChat")), 1)
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            createVNode(_component_NodeExecuteButton, {
              "data-test-id": "trigger-execute-button",
              "node-name": _ctx.nodeName,
              size: "medium",
              "telemetry-source": "inputs",
              onExecute: _ctx.onNodeExecute
            }, null, 8, ["node-name", "onExecute"])
          ]))
        ])) : (openBlock(), createElementBlock("div", _hoisted_6$2, [
          _ctx.isActivelyPolling ? (openBlock(), createElementBlock("div", _hoisted_7$1, [
            createVNode(_component_n8n_spinner, { type: "ring" })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.action)
          }, [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.$style.header)
            }, [
              _ctx.header ? (openBlock(), createBlock(_component_n8n_heading, {
                key: 0,
                tag: "h1",
                bold: ""
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(_ctx.header), 1)
                ]),
                _: 1
              })) : createCommentVNode("", true),
              _ctx.subheader ? (openBlock(), createBlock(_component_n8n_text, { key: 1 }, {
                default: withCtx(() => [
                  createBaseVNode("span", {
                    textContent: toDisplayString(_ctx.subheader)
                  }, null, 8, _hoisted_8$1)
                ]),
                _: 1
              })) : createCommentVNode("", true)
            ], 2),
            createVNode(_component_NodeExecuteButton, {
              "data-test-id": "trigger-execute-button",
              "node-name": _ctx.nodeName,
              size: "medium",
              "telemetry-source": "inputs",
              onExecute: _ctx.onNodeExecute
            }, null, 8, ["node-name", "onExecute"])
          ], 2),
          _ctx.activationHint ? (openBlock(), createBlock(_component_n8n_text, {
            key: 1,
            size: "small",
            onClick: _ctx.onLinkClick
          }, {
            default: withCtx(() => [
              withDirectives(createBaseVNode("span", null, null, 512), [
                [_directive_n8n_html, _ctx.activationHint]
              ]),
              _cache[1] || (_cache[1] = createTextVNode("  "))
            ]),
            _: 1
          }, 8, ["onClick"])) : createCommentVNode("", true),
          _ctx.activationHint && _ctx.executionsHelp ? (openBlock(), createBlock(_component_n8n_link, {
            key: 2,
            size: "small",
            onClick: _ctx.expandExecutionHelp
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.trigger.moreInfo")), 1)
            ]),
            _: 1
          }, 8, ["onClick"])) : createCommentVNode("", true),
          _ctx.executionsHelp ? (openBlock(), createBlock(_component_n8n_info_accordion, {
            key: 3,
            ref: "help",
            class: normalizeClass(_ctx.$style.accordion),
            title: _ctx.$locale.baseText("ndv.trigger.executionsHint.question"),
            description: _ctx.executionsHelp,
            "event-bus": _ctx.executionsHelpEventBus,
            "onClick:body": _ctx.onLinkClick
          }, null, 8, ["class", "title", "description", "event-bus", "onClick:body"])) : createCommentVNode("", true)
        ]))
      ]),
      _: 1
    })
  ], 2);
}
const cssModules$q = {
  "$style": style0$o
};
const TriggerPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$H, [["render", _sfc_render$3], ["__cssModules", cssModules$q], ["__scopeId", "data-v-32dc70fa"]]);
const _sfc_main$G = /* @__PURE__ */ defineComponent({
  __name: "NodeDetailsView",
  props: {
    workflowObject: {},
    readOnly: { type: Boolean, default: false },
    renaming: { type: Boolean },
    isProductionExecutionPreview: { type: Boolean, default: false }
  },
  emits: ["saveKeyboardShortcut", "valueChanged", "switchSelectedNode", "openConnectionNodeCreator", "redrawNode", "stopExecution"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const ndvStore = useNDVStore();
    const externalHooks = useExternalHooks();
    const nodeHelpers = useNodeHelpers();
    const { activeNode } = storeToRefs(ndvStore);
    const pinnedData2 = usePinnedData(activeNode);
    const workflowActivate = useWorkflowActivate();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const settingsStore = useSettingsStore();
    const deviceSupport = useDeviceSupport();
    const telemetry = useTelemetry();
    const i18n2 = useI18n();
    const message = useMessage();
    const settingsEventBus = createEventBus();
    const redrawRequired = ref(false);
    const runInputIndex = ref(-1);
    const runOutputIndex = ref(-1);
    const isLinkingEnabled = ref(true);
    const selectedInput = ref();
    const triggerWaitingWarningEnabled = ref(false);
    const isDragging = ref(false);
    const mainPanelPosition = ref(0);
    const pinDataDiscoveryTooltipVisible = ref(false);
    const avgInputRowHeight = ref(0);
    const avgOutputRowHeight = ref(0);
    const isInputPaneActive = ref(false);
    const isOutputPaneActive = ref(false);
    const isPairedItemHoveringEnabled = ref(true);
    const pushRef = computed(() => ndvStore.pushRef);
    const activeNodeType = computed(() => {
      if (activeNode.value) {
        return nodeTypesStore.getNodeType(activeNode.value.type, activeNode.value.typeVersion);
      }
      return null;
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const showTriggerWaitingWarning = computed(
      () => triggerWaitingWarningEnabled.value && !!activeNodeType.value && !activeNodeType.value.group.includes("trigger") && workflowRunning.value && workflowsStore.executionWaitingForWebhook
    );
    const workflowRunData = computed(() => {
      if (workflowExecution.value === null) {
        return null;
      }
      const executionData = workflowExecution.value.data;
      if (executionData == null ? void 0 : executionData.resultData) {
        return executionData.resultData.runData;
      }
      return null;
    });
    const parentNodes = computed(() => {
      if (activeNode.value) {
        return props.workflowObject.getParentNodesByDepth(activeNode.value.name, 1).map(({ name }) => name) || [];
      } else {
        return [];
      }
    });
    const parentNode = computed(() => {
      var _a, _b;
      for (const parentNodeName of parentNodes.value) {
        if ((_a = workflowsStore == null ? void 0 : workflowsStore.pinnedWorkflowData) == null ? void 0 : _a[parentNodeName]) {
          return parentNodeName;
        }
        if ((_b = workflowRunData.value) == null ? void 0 : _b[parentNodeName]) {
          return parentNodeName;
        }
      }
      return parentNodes.value[0];
    });
    const inputNodeName = computed(() => {
      return selectedInput.value || parentNode.value;
    });
    const inputNode = computed(() => {
      if (inputNodeName.value) {
        return workflowsStore.getNodeByName(inputNodeName.value);
      }
      return null;
    });
    const inputSize = computed(() => ndvStore.ndvInputDataWithPinnedData.length);
    const isTriggerNode = computed(
      () => !!activeNodeType.value && (activeNodeType.value.group.includes("trigger") || activeNodeType.value.name === START_NODE_TYPE)
    );
    const showTriggerPanel = computed(() => {
      var _a, _b, _c, _d, _e;
      const override = !!((_a = activeNodeType.value) == null ? void 0 : _a.triggerPanel);
      if (typeof ((_b = activeNodeType.value) == null ? void 0 : _b.triggerPanel) === "boolean") {
        return override;
      }
      const isWebhookBasedNode = !!((_d = (_c = activeNodeType.value) == null ? void 0 : _c.webhooks) == null ? void 0 : _d.length);
      const isPollingNode = (_e = activeNodeType.value) == null ? void 0 : _e.polling;
      return !props.readOnly && isTriggerNode.value && (isWebhookBasedNode || isPollingNode || override);
    });
    const hasOutputConnection = computed(() => {
      var _a, _b;
      if (!activeNode.value) return false;
      const outgoingConnections = workflowsStore.outgoingConnectionsByNodeName(activeNode.value.name);
      return (((_b = (_a = Object.values(outgoingConnections)) == null ? void 0 : _a[0]) == null ? void 0 : _b[0]) ?? []).length > 0;
    });
    const isExecutableTriggerNode = computed(() => {
      if (!activeNodeType.value) return false;
      return EXECUTABLE_TRIGGER_NODE_TYPES.includes(activeNodeType.value.name);
    });
    const isActiveStickyNode = computed(
      () => !!ndvStore.activeNode && ndvStore.activeNode.type === STICKY_NODE_TYPE
    );
    const workflowExecution = computed(() => workflowsStore.getWorkflowExecution);
    const maxOutputRun = computed(() => {
      if (activeNode.value === null) {
        return 0;
      }
      const runData2 = workflowRunData.value;
      if (!(runData2 == null ? void 0 : runData2[activeNode.value.name])) {
        return 0;
      }
      if (runData2[activeNode.value.name].length) {
        return runData2[activeNode.value.name].length - 1;
      }
      return 0;
    });
    const outputRun = computed(
      () => runOutputIndex.value === -1 ? maxOutputRun.value : Math.min(runOutputIndex.value, maxOutputRun.value)
    );
    const maxInputRun = computed(() => {
      if (inputNode.value === null || activeNode.value === null) {
        return 0;
      }
      const workflowNode = props.workflowObject.getNode(activeNode.value.name);
      if (!workflowNode || !activeNodeType.value) {
        return 0;
      }
      const outputs2 = getNodeOutputs(
        props.workflowObject,
        workflowNode,
        activeNodeType.value
      );
      let node2 = inputNode.value;
      const runData2 = workflowRunData.value;
      if (outputs2.some((output) => output !== NodeConnectionType.Main)) {
        node2 = activeNode.value;
      }
      if (!node2 || !runData2 || !runData2.hasOwnProperty(node2.name)) {
        return 0;
      }
      if (runData2[node2.name].length) {
        return runData2[node2.name].length - 1;
      }
      return 0;
    });
    const inputRun = computed(() => {
      if (isLinkingEnabled.value && maxOutputRun.value === maxInputRun.value) {
        return outputRun.value;
      }
      if (runInputIndex.value === -1) {
        return maxInputRun.value;
      }
      return Math.min(runInputIndex.value, maxInputRun.value);
    });
    const canLinkRuns = computed(
      () => maxOutputRun.value > 0 && maxOutputRun.value === maxInputRun.value
    );
    const linked = computed(() => isLinkingEnabled.value && canLinkRuns.value);
    const featureRequestUrl = computed(() => {
      if (!activeNodeType.value) {
        return "";
      }
      return `${BASE_NODE_SURVEY_URL}${activeNodeType.value.name}`;
    });
    const outputPanelEditMode = computed(() => ndvStore.outputPanelEditMode);
    const isWorkflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const isExecutionWaitingForWebhook = computed(() => workflowsStore.executionWaitingForWebhook);
    const blockUi = computed(() => isWorkflowRunning.value || isExecutionWaitingForWebhook.value);
    const foreignCredentials = computed(() => {
      var _a;
      const credentials = (_a = activeNode.value) == null ? void 0 : _a.credentials;
      const usedCredentials = workflowsStore.usedCredentials;
      const foreignCredentialsArray = [];
      if (credentials && settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]) {
        Object.values(credentials).forEach((credential) => {
          if (credential.id && usedCredentials[credential.id] && !usedCredentials[credential.id].currentUserHasAccess) {
            foreignCredentialsArray.push(credential.id);
          }
        });
      }
      return foreignCredentialsArray;
    });
    const hasForeignCredential = computed(() => foreignCredentials.value.length > 0);
    const setIsTooltipVisible = ({ isTooltipVisible }) => {
      pinDataDiscoveryTooltipVisible.value = isTooltipVisible;
    };
    const onKeyDown2 = (e) => {
      if (e.key === "s" && deviceSupport.isCtrlKeyPressed(e)) {
        e.stopPropagation();
        e.preventDefault();
        if (props.readOnly) return;
        emit("saveKeyboardShortcut", e);
      }
    };
    const onInputItemHover = (e) => {
      if (e === null || !inputNodeName.value || !isPairedItemHoveringEnabled.value) {
        ndvStore.setHoveringItem(null);
        return;
      }
      const item = {
        nodeName: inputNodeName.value,
        runIndex: inputRun.value,
        outputIndex: e.outputIndex,
        itemIndex: e.itemIndex
      };
      ndvStore.setHoveringItem(item);
    };
    const onInputTableMounted = (e) => {
      avgInputRowHeight.value = e.avgRowHeight;
    };
    const onWorkflowActivate = () => {
      ndvStore.activeNodeName = null;
      setTimeout(() => {
        void workflowActivate.activateCurrentWorkflow("ndv");
      }, 1e3);
    };
    const onOutputItemHover = (e) => {
      var _a;
      if (e === null || !activeNode.value || !isPairedItemHoveringEnabled.value) {
        ndvStore.setHoveringItem(null);
        return;
      }
      const item = {
        nodeName: (_a = activeNode.value) == null ? void 0 : _a.name,
        runIndex: outputRun.value,
        outputIndex: e.outputIndex,
        itemIndex: e.itemIndex
      };
      ndvStore.setHoveringItem(item);
    };
    const onFeatureRequestClick = () => {
      window.open(featureRequestUrl.value, "_blank");
      if (activeNode.value) {
        telemetry.track("User clicked ndv link", {
          node_type: activeNode.value.type,
          workflow_id: workflowsStore.workflowId,
          push_ref: pushRef.value,
          pane: NodeConnectionType.Main,
          type: "i-wish-this-node-would"
        });
      }
    };
    const onDragEnd = (e) => {
      isDragging.value = false;
      telemetry.track("User moved parameters pane", {
        // example method for tracking
        window_width: e.windowWidth,
        start_position: mainPanelPosition.value,
        end_position: e.position,
        node_type: activeNodeType.value ? activeNodeType.value.name : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId
      });
      mainPanelPosition.value = e.position;
    };
    const onDragStart = (e) => {
      isDragging.value = true;
      mainPanelPosition.value = e.position;
    };
    const onPanelsInit = (e) => {
      mainPanelPosition.value = e.position;
    };
    const onLinkRunToOutput = () => {
      isLinkingEnabled.value = true;
      trackLinking("output");
    };
    const onUnlinkRun = (pane) => {
      runInputIndex.value = runOutputIndex.value;
      isLinkingEnabled.value = false;
      trackLinking(pane);
    };
    const onNodeExecute = () => {
      setTimeout(() => {
        if (!activeNode.value || !workflowRunning.value) {
          return;
        }
        triggerWaitingWarningEnabled.value = true;
      }, 1e3);
    };
    const openSettings = () => {
      settingsEventBus.emit("openSettings");
    };
    const trackLinking = (pane) => {
      telemetry.track("User changed ndv run linking", {
        node_type: activeNodeType.value ? activeNodeType.value.name : "",
        push_ref: pushRef.value,
        linked: linked.value,
        pane
      });
    };
    const onLinkRunToInput = () => {
      runOutputIndex.value = runInputIndex.value;
      isLinkingEnabled.value = true;
      trackLinking("input");
    };
    const valueChanged = (parameterData) => {
      emit("valueChanged", parameterData);
    };
    const onSwitchSelectedNode = (nodeTypeName) => {
      emit("switchSelectedNode", nodeTypeName);
    };
    const onOpenConnectionNodeCreator = (nodeTypeName, connectionType2) => {
      emit("openConnectionNodeCreator", nodeTypeName, connectionType2);
    };
    const close = async () => {
      var _a, _b, _c;
      if (isDragging.value) {
        return;
      }
      if (activeNode.value && (typeof ((_a = activeNodeType.value) == null ? void 0 : _a.outputs) === "string" || typeof ((_b = activeNodeType.value) == null ? void 0 : _b.inputs) === "string" || redrawRequired.value)) {
        const nodeName = activeNode.value.name;
        setTimeout(() => {
          emit("redrawNode", nodeName);
        }, 1);
      }
      if (outputPanelEditMode.value.enabled && activeNode.value) {
        const shouldPinDataBeforeClosing = await message.confirm(
          "",
          i18n2.baseText("ndv.pinData.beforeClosing.title"),
          {
            confirmButtonText: i18n2.baseText("ndv.pinData.beforeClosing.confirm"),
            cancelButtonText: i18n2.baseText("ndv.pinData.beforeClosing.cancel")
          }
        );
        if (shouldPinDataBeforeClosing === MODAL_CONFIRM) {
          const { value } = outputPanelEditMode.value;
          try {
            pinnedData2.setData(jsonParse(value), "on-ndv-close-modal");
          } catch (error2) {
            console.error(error2);
          }
        }
        ndvStore.setOutputPanelEditModeEnabled(false);
      }
      await externalHooks.run("dataDisplay.nodeEditingFinished");
      telemetry.track("User closed node modal", {
        node_type: activeNodeType.value ? (_c = activeNodeType.value) == null ? void 0 : _c.name : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId
      });
      triggerWaitingWarningEnabled.value = false;
      ndvStore.activeNodeName = null;
      ndvStore.resetNDVPushRef();
    };
    const trackRunChange = (run, pane) => {
      var _a;
      telemetry.track("User changed ndv run dropdown", {
        push_ref: pushRef.value,
        run_index: run,
        node_type: activeNodeType.value ? (_a = activeNodeType.value) == null ? void 0 : _a.name : "",
        pane
      });
    };
    const onRunOutputIndexChange = (run) => {
      runOutputIndex.value = run;
      trackRunChange(run, "output");
    };
    const onRunInputIndexChange = (run) => {
      runInputIndex.value = run;
      if (linked.value) {
        runOutputIndex.value = run;
      }
      trackRunChange(run, "input");
    };
    const onOutputTableMounted = (e) => {
      avgOutputRowHeight.value = e.avgRowHeight;
    };
    const onInputNodeChange = (value, index) => {
      runInputIndex.value = -1;
      isLinkingEnabled.value = true;
      selectedInput.value = value;
      telemetry.track("User changed ndv input dropdown", {
        node_type: activeNode.value ? activeNode.value.type : "",
        push_ref: pushRef.value,
        workflow_id: workflowsStore.workflowId,
        selection_value: index,
        input_node_type: inputNode.value ? inputNode.value.type : ""
      });
    };
    const onStopExecution = () => {
      emit("stopExecution");
    };
    const activateInputPane = () => {
      isInputPaneActive.value = true;
      isOutputPaneActive.value = false;
    };
    const activateOutputPane = () => {
      isInputPaneActive.value = false;
      isOutputPaneActive.value = true;
    };
    const onSearch = (search2) => {
      isPairedItemHoveringEnabled.value = !search2;
    };
    watch(
      activeNode,
      (node2, oldNode) => {
        if (node2 && node2.name !== (oldNode == null ? void 0 : oldNode.name) && !isActiveStickyNode.value) {
          runInputIndex.value = -1;
          runOutputIndex.value = -1;
          isLinkingEnabled.value = true;
          selectedInput.value = void 0;
          triggerWaitingWarningEnabled.value = false;
          avgOutputRowHeight.value = 0;
          avgInputRowHeight.value = 0;
          setTimeout(() => ndvStore.setNDVPushRef(), 0);
          if (!activeNodeType.value) {
            return;
          }
          void externalHooks.run("dataDisplay.nodeTypeChanged", {
            nodeSubtitle: nodeHelpers.getNodeSubtitle(node2, activeNodeType.value, props.workflowObject)
          });
          setTimeout(() => {
            var _a, _b, _c;
            if (activeNode.value) {
              const outgoingConnections = workflowsStore.outgoingConnectionsByNodeName(
                (_a = activeNode.value) == null ? void 0 : _a.name
              );
              telemetry.track("User opened node modal", {
                node_type: activeNodeType.value ? (_b = activeNodeType.value) == null ? void 0 : _b.name : "",
                workflow_id: workflowsStore.workflowId,
                push_ref: pushRef.value,
                is_editable: !hasForeignCredential.value,
                parameters_pane_position: mainPanelPosition.value,
                input_first_connector_runs: maxInputRun.value,
                output_first_connector_runs: maxOutputRun.value,
                selected_view_inputs: isTriggerNode.value ? "trigger" : ndvStore.inputPanelDisplayMode,
                selected_view_outputs: ndvStore.outputPanelDisplayMode,
                input_connectors: parentNodes.value.length,
                output_connectors: (_c = outgoingConnections == null ? void 0 : outgoingConnections.main) == null ? void 0 : _c.length,
                input_displayed_run_index: inputRun.value,
                output_displayed_run_index: outputRun.value,
                data_pinning_tooltip_presented: pinDataDiscoveryTooltipVisible.value,
                input_displayed_row_height_avg: avgInputRowHeight.value,
                output_displayed_row_height_avg: avgOutputRowHeight.value
              });
            }
          }, 2e3);
        }
        if (window.top && !isActiveStickyNode.value) {
          window.top.postMessage(JSON.stringify({ command: node2 ? "openNDV" : "closeNDV" }), "*");
        }
      },
      { immediate: true }
    );
    watch(maxOutputRun, () => {
      runOutputIndex.value = -1;
    });
    watch(maxInputRun, () => {
      runInputIndex.value = -1;
    });
    watch(inputNodeName, (nodeName) => {
      setTimeout(() => {
        ndvStore.setInputNodeName(nodeName);
      }, 0);
    });
    watch(inputRun, (inputRun2) => {
      setTimeout(() => {
        ndvStore.setInputRunIndex(inputRun2);
      }, 0);
    });
    onMounted(() => {
      dataPinningEventBus.on("data-pinning-discovery", setIsTooltipVisible);
    });
    onBeforeUnmount(() => {
      dataPinningEventBus.off("data-pinning-discovery", setIsTooltipVisible);
    });
    return (_ctx, _cache) => {
      const _component_n8n_icon = resolveComponent("n8n-icon");
      const _component_n8n_text = resolveComponent("n8n-text");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_el_dialog = resolveComponent("el-dialog");
      return openBlock(), createBlock(_component_el_dialog, {
        "model-value": (!!unref(activeNode) || _ctx.renaming) && !isActiveStickyNode.value,
        "before-close": close,
        "show-close": false,
        class: "data-display-wrapper ndv-wrapper",
        "overlay-class": "data-display-overlay",
        width: "auto",
        "append-to": `#${unref(APP_MODALS_ELEMENT_ID)}`,
        "data-test-id": "ndv",
        "z-index": "1800",
        "data-has-output-connection": hasOutputConnection.value
      }, {
        default: withCtx(() => {
          var _a;
          return [
            createVNode(_component_n8n_tooltip, {
              placement: "bottom-start",
              visible: showTriggerWaitingWarning.value,
              disabled: !showTriggerWaitingWarning.value
            }, {
              content: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.$style.triggerWarning)
                }, toDisplayString(_ctx.$locale.baseText("ndv.backToCanvas.waitingForTriggerWarning")), 3)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.$style.backToCanvas),
                  "data-test-id": "back-to-canvas",
                  onClick: close
                }, [
                  createVNode(_component_n8n_icon, {
                    icon: "arrow-left",
                    color: "text-xlight",
                    size: "medium"
                  }),
                  createVNode(_component_n8n_text, {
                    color: "text-xlight",
                    size: "medium",
                    bold: true
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.$locale.baseText("ndv.backToCanvas")), 1)
                    ]),
                    _: 1
                  })
                ], 2)
              ]),
              _: 1
            }, 8, ["visible", "disabled"]),
            unref(activeNode) ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "container",
              class: "data-display",
              tabindex: "0",
              onKeydownCapture: onKeyDown2
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.$style.modalBackground),
                onClick: close
              }, null, 2),
              (openBlock(), createBlock(NDVDraggablePanels, {
                key: unref(activeNode).name,
                "is-trigger-node": isTriggerNode.value,
                "hide-input-and-output": activeNodeType.value === null,
                position: isTriggerNode.value && !showTriggerPanel.value ? 0 : void 0,
                "is-draggable": !isTriggerNode.value,
                "has-double-width": ((_a = activeNodeType.value) == null ? void 0 : _a.parameterPane) === "wide",
                "node-type": activeNodeType.value,
                onSwitchSelectedNode,
                onOpenConnectionNodeCreator,
                onClose: close,
                onInit: onPanelsInit,
                onDragstart: onDragStart,
                onDragend: onDragEnd
              }, createSlots({
                output: withCtx(() => [
                  createVNode(OutputPanel, {
                    "data-test-id": "output-panel",
                    workflow: _ctx.workflowObject,
                    "can-link-runs": canLinkRuns.value,
                    "run-index": outputRun.value,
                    "linked-runs": linked.value,
                    "push-ref": pushRef.value,
                    "is-read-only": _ctx.readOnly || hasForeignCredential.value,
                    "block-u-i": blockUi.value && isTriggerNode.value && !isExecutableTriggerNode.value,
                    "is-production-execution-preview": _ctx.isProductionExecutionPreview,
                    "is-pane-active": isOutputPaneActive.value,
                    onActivatePane: activateOutputPane,
                    onLinkRun: onLinkRunToOutput,
                    onUnlinkRun: _cache[1] || (_cache[1] = () => onUnlinkRun("output")),
                    onRunChange: onRunOutputIndexChange,
                    onOpenSettings: openSettings,
                    onTableMounted: onOutputTableMounted,
                    onItemHover: onOutputItemHover,
                    onSearch
                  }, null, 8, ["workflow", "can-link-runs", "run-index", "linked-runs", "push-ref", "is-read-only", "block-u-i", "is-production-execution-preview", "is-pane-active"])
                ]),
                main: withCtx(() => [
                  createVNode(NodeSettings, {
                    "event-bus": unref(settingsEventBus),
                    dragging: isDragging.value,
                    "push-ref": pushRef.value,
                    "node-type": activeNodeType.value,
                    "foreign-credentials": foreignCredentials.value,
                    "read-only": _ctx.readOnly,
                    "block-u-i": blockUi.value && showTriggerPanel.value,
                    executable: !_ctx.readOnly,
                    "input-size": inputSize.value,
                    onValueChanged: valueChanged,
                    onExecute: onNodeExecute,
                    onStopExecution,
                    onRedrawRequired: _cache[2] || (_cache[2] = ($event) => redrawRequired.value = true),
                    onActivate: onWorkflowActivate,
                    onSwitchSelectedNode,
                    onOpenConnectionNodeCreator
                  }, null, 8, ["event-bus", "dragging", "push-ref", "node-type", "foreign-credentials", "read-only", "block-u-i", "executable", "input-size"]),
                  featureRequestUrl.value ? (openBlock(), createElementBlock("a", {
                    key: 0,
                    class: normalizeClass(_ctx.$style.featureRequest),
                    target: "_blank",
                    onClick: onFeatureRequestClick
                  }, [
                    createVNode(_component_font_awesome_icon, { icon: "lightbulb" }),
                    createTextVNode(" " + toDisplayString(_ctx.$locale.baseText("ndv.featureRequest")), 1)
                  ], 2)) : createCommentVNode("", true)
                ]),
                _: 2
              }, [
                showTriggerPanel.value || !isTriggerNode.value ? {
                  name: "input",
                  fn: withCtx(() => [
                    showTriggerPanel.value ? (openBlock(), createBlock(TriggerPanel, {
                      key: 0,
                      "node-name": unref(activeNode).name,
                      "push-ref": pushRef.value,
                      onExecute: onNodeExecute,
                      onActivate: onWorkflowActivate
                    }, null, 8, ["node-name", "push-ref"])) : !isTriggerNode.value ? (openBlock(), createBlock(InputPanel, {
                      key: 1,
                      workflow: _ctx.workflowObject,
                      "can-link-runs": canLinkRuns.value,
                      "run-index": inputRun.value,
                      "linked-runs": linked.value,
                      "current-node-name": inputNodeName.value,
                      "push-ref": pushRef.value,
                      "read-only": _ctx.readOnly || hasForeignCredential.value,
                      "is-production-execution-preview": _ctx.isProductionExecutionPreview,
                      "is-pane-active": isInputPaneActive.value,
                      onActivatePane: activateInputPane,
                      onLinkRun: onLinkRunToInput,
                      onUnlinkRun: _cache[0] || (_cache[0] = () => onUnlinkRun("input")),
                      onRunChange: onRunInputIndexChange,
                      onOpenSettings: openSettings,
                      onChangeInputNode: onInputNodeChange,
                      onExecute: onNodeExecute,
                      onTableMounted: onInputTableMounted,
                      onItemHover: onInputItemHover,
                      onSearch
                    }, null, 8, ["workflow", "can-link-runs", "run-index", "linked-runs", "current-node-name", "push-ref", "read-only", "is-production-execution-preview", "is-pane-active"])) : createCommentVNode("", true)
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["is-trigger-node", "hide-input-and-output", "position", "is-draggable", "has-double-width", "node-type"]))
            ], 544)) : createCommentVNode("", true)
          ];
        }),
        _: 1
      }, 8, ["model-value", "append-to", "data-has-output-connection"]);
    };
  }
});
const modalBackground = "_modalBackground_16z4c_1";
const triggerWarning = "_triggerWarning_16z4c_6";
const backToCanvas = "_backToCanvas_16z4c_10";
const featureRequest = "_featureRequest_16z4c_31";
const style1 = {
  modalBackground,
  triggerWarning,
  backToCanvas,
  featureRequest
};
const cssModules$p = {
  "$style": style1
};
const __unplugin_components_2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$G, [["__cssModules", cssModules$p]]);
const NodeDetailsView = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __unplugin_components_2
}, Symbol.toStringTag, { value: "Module" }));
function useNodeBase({
  name,
  instance,
  workflowObject,
  isReadOnly,
  emit
}) {
  const uiStore = useUIStore();
  const deviceSupport = useDeviceSupport();
  const workflowsStore = useWorkflowsStore();
  const nodeTypesStore = useNodeTypesStore();
  const i18n2 = useI18n();
  const refs = computed(() => {
    var _a;
    return ((_a = getCurrentInstance()) == null ? void 0 : _a.refs) ?? {};
  });
  const data = computed(() => {
    return workflowsStore.getNodeByName(name);
  });
  const nodeId = computed(() => {
    var _a;
    return ((_a = data.value) == null ? void 0 : _a.id) ?? "";
  });
  const inputs2 = ref([]);
  const outputs2 = ref([]);
  const createAddInputEndpointSpec = (connectionName, color2) => {
    const multiple = NODE_CONNECTION_TYPE_ALLOW_MULTIPLE.includes(connectionName);
    return {
      type: "N8nAddInput",
      options: {
        width: 24,
        height: 72,
        color: color2,
        multiple
      }
    };
  };
  const createDiamondOutputEndpointSpec = () => ({
    type: "Rectangle",
    options: {
      height: 10,
      width: 10,
      cssClass: "diamond-output-endpoint"
    }
  });
  const getEndpointLabelLength = (length) => {
    if (length <= 2) return "small";
    else if (length <= 6) return "medium";
    return "large";
  };
  function addEndpointTestingData(endpoint, type, inputIndex) {
    var _a;
    if ((window == null ? void 0 : window.Cypress) && "canvas" in endpoint.endpoint && instance) {
      const canvas2 = endpoint.endpoint.canvas;
      instance.setAttribute(canvas2, "data-endpoint-name", ((_a = data.value) == null ? void 0 : _a.name) ?? "");
      instance.setAttribute(canvas2, "data-input-index", inputIndex.toString());
      instance.setAttribute(canvas2, "data-endpoint-type", type);
    }
  }
  function addInputEndpoints(node2, nodeTypeData) {
    var _a;
    const rootTypeIndexData = {};
    const typeIndexData = {};
    inputs2.value = getNodeInputs(workflowObject, data.value, nodeTypeData) || [];
    const sortedInputs = [...inputs2.value];
    sortedInputs.sort((a, b) => {
      if (typeof a === "string") {
        return 1;
      } else if (typeof b === "string") {
        return -1;
      }
      if (a.required && !b.required) {
        return -1;
      } else if (!a.required && b.required) {
        return 1;
      }
      return 0;
    });
    sortedInputs.forEach((value, i) => {
      var _a2, _b, _c;
      let inputConfiguration;
      if (typeof value === "string") {
        inputConfiguration = {
          type: value
        };
      } else {
        inputConfiguration = value;
      }
      const inputName = inputConfiguration.type;
      const rootCategoryInputName = inputName === NodeConnectionType.Main ? NodeConnectionType.Main : "other";
      if (rootTypeIndexData.hasOwnProperty(rootCategoryInputName)) {
        rootTypeIndexData[rootCategoryInputName]++;
      } else {
        rootTypeIndexData[rootCategoryInputName] = 0;
      }
      if (typeIndexData.hasOwnProperty(inputName)) {
        typeIndexData[inputName]++;
      } else {
        typeIndexData[inputName] = 0;
      }
      const rootTypeIndex = rootTypeIndexData[rootCategoryInputName];
      const typeIndex = typeIndexData[inputName];
      const inputsOfSameRootType = inputs2.value.filter((inputData) => {
        const thisInputName = typeof inputData === "string" ? inputData : inputData.type;
        return inputName === NodeConnectionType.Main ? thisInputName === NodeConnectionType.Main : thisInputName !== NodeConnectionType.Main;
      });
      const nonMainInputs = inputsOfSameRootType.filter((inputData) => {
        return inputData !== NodeConnectionType.Main;
      });
      const requiredNonMainInputs = nonMainInputs.filter((inputData) => {
        return typeof inputData !== "string" && inputData.required;
      });
      const optionalNonMainInputs = nonMainInputs.filter((inputData) => {
        return typeof inputData !== "string" && !inputData.required;
      });
      const spacerIndexes = getSpacerIndexes(
        requiredNonMainInputs.length,
        optionalNonMainInputs.length
      );
      const anchorPosition = getAnchorPosition(
        inputName,
        "input",
        inputsOfSameRootType.length,
        spacerIndexes
      )[rootTypeIndex];
      if (!isValidNodeConnectionType(inputName)) {
        return;
      }
      const scope = getEndpointScope(inputName);
      const newEndpointData = {
        uuid: getInputEndpointUUID(nodeId.value, inputName, typeIndex),
        anchor: anchorPosition,
        // We potentially want to change that in the future to allow people to dynamically
        // activate and deactivate connected nodes
        maxConnections: inputConfiguration.maxConnections ?? -1,
        endpoint: "Rectangle",
        paintStyle: getInputEndpointStyle(
          nodeTypeData,
          "--color-foreground-xdark",
          inputName
        ),
        hoverPaintStyle: getInputEndpointStyle(
          nodeTypeData,
          "--color-primary",
          inputName
        ),
        scope: getScope(scope),
        source: inputName !== NodeConnectionType.Main,
        target: !isReadOnly && inputs2.value.length > 1,
        // only enabled for nodes with multiple inputs.. otherwise attachment handled by connectionDrag event in NodeView,
        parameters: {
          connection: "target",
          nodeId: nodeId.value,
          type: inputName,
          index: typeIndex
        },
        enabled: !isReadOnly,
        // enabled in default case to allow dragging
        cssClass: "rect-input-endpoint",
        dragAllowedWhenFull: true,
        hoverClass: "rect-input-endpoint-hover",
        ...getInputConnectionStyle(inputName, nodeTypeData)
      };
      const endpoint = instance == null ? void 0 : instance.addEndpoint(
        refs.value[((_a2 = data.value) == null ? void 0 : _a2.name) ?? ""],
        newEndpointData
      );
      addEndpointTestingData(endpoint, "input", typeIndex);
      if (inputConfiguration.displayName ?? ((_b = nodeTypeData.inputNames) == null ? void 0 : _b[i])) {
        endpoint.addOverlay(
          getInputNameOverlay(
            inputConfiguration.displayName ?? ((_c = nodeTypeData.inputNames) == null ? void 0 : _c[i]) ?? "",
            inputName,
            inputConfiguration.required
          )
        );
      }
      if (!Array.isArray(endpoint)) {
        endpoint.__meta = {
          nodeName: node2.name,
          nodeId: nodeId.value,
          index: typeIndex,
          totalEndpoints: inputsOfSameRootType.length,
          nodeType: node2.type
        };
      }
    });
    if (sortedInputs.length === 0) {
      instance == null ? void 0 : instance.manage(refs.value[((_a = data.value) == null ? void 0 : _a.name) ?? ""]);
    }
  }
  function getSpacerIndexes(leftGroupItemsCount, rightGroupItemsCount, insertSpacerBetweenGroups = NODE_INSERT_SPACER_BETWEEN_INPUT_GROUPS, minItemsCount = NODE_MIN_INPUT_ITEMS_COUNT) {
    const spacerIndexes = [];
    if (leftGroupItemsCount > 0 && rightGroupItemsCount > 0) {
      if (insertSpacerBetweenGroups) {
        spacerIndexes.push(leftGroupItemsCount);
      } else if (leftGroupItemsCount + rightGroupItemsCount < minItemsCount) {
        for (let spacerIndex = leftGroupItemsCount; spacerIndex < minItemsCount - rightGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex);
        }
      }
    } else {
      if (leftGroupItemsCount > 0 && leftGroupItemsCount < minItemsCount && rightGroupItemsCount === 0) {
        for (let spacerIndex = 0; spacerIndex < minItemsCount - leftGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex + leftGroupItemsCount);
        }
      } else if (leftGroupItemsCount === 0 && rightGroupItemsCount > 0 && rightGroupItemsCount < minItemsCount) {
        for (let spacerIndex = 0; spacerIndex < minItemsCount - rightGroupItemsCount; spacerIndex++) {
          spacerIndexes.push(spacerIndex);
        }
      }
    }
    return spacerIndexes;
  }
  function addOutputEndpoints(node2, nodeTypeData) {
    const rootTypeIndexData = {};
    const typeIndexData = {};
    if (!data.value) {
      return;
    }
    outputs2.value = getNodeOutputs(workflowObject, data.value, nodeTypeData) || [];
    let maxLabelLength = 0;
    const outputConfigurations = [];
    outputs2.value.forEach((value, i) => {
      var _a;
      let outputConfiguration;
      if (typeof value === "string") {
        outputConfiguration = {
          type: value
        };
      } else {
        outputConfiguration = value;
      }
      if ((_a = nodeTypeData.outputNames) == null ? void 0 : _a[i]) {
        outputConfiguration.displayName = nodeTypeData.outputNames[i];
      }
      if (outputConfiguration.displayName) {
        maxLabelLength = outputConfiguration.displayName.length > maxLabelLength ? outputConfiguration.displayName.length : maxLabelLength;
      }
      outputConfigurations.push(outputConfiguration);
    });
    const endpointLabelLength = getEndpointLabelLength(maxLabelLength);
    outputs2.value.forEach((_value, i) => {
      var _a;
      const outputConfiguration = outputConfigurations[i];
      const outputName = outputConfiguration.type;
      const rootCategoryOutputName = outputName === NodeConnectionType.Main ? NodeConnectionType.Main : "other";
      if (rootTypeIndexData.hasOwnProperty(rootCategoryOutputName)) {
        rootTypeIndexData[rootCategoryOutputName]++;
      } else {
        rootTypeIndexData[rootCategoryOutputName] = 0;
      }
      if (typeIndexData.hasOwnProperty(outputName)) {
        typeIndexData[outputName]++;
      } else {
        typeIndexData[outputName] = 0;
      }
      const rootTypeIndex = rootTypeIndexData[rootCategoryOutputName];
      const typeIndex = typeIndexData[outputName];
      const outputsOfSameRootType = outputs2.value.filter((outputData) => {
        const thisOutputName = typeof outputData === "string" ? outputData : outputData.type;
        return outputName === NodeConnectionType.Main ? thisOutputName === NodeConnectionType.Main : thisOutputName !== NodeConnectionType.Main;
      });
      const anchorPosition = getAnchorPosition(
        outputName,
        "output",
        outputsOfSameRootType.length
      )[rootTypeIndex];
      if (!isValidNodeConnectionType(outputName)) {
        return;
      }
      const scope = getEndpointScope(outputName);
      const newEndpointData = {
        uuid: getOutputEndpointUUID(nodeId.value, outputName, typeIndex),
        anchor: anchorPosition,
        maxConnections: -1,
        endpoint: {
          type: "Dot",
          options: {
            radius: nodeTypeData && outputsOfSameRootType.length > 2 ? 7 : 9
          }
        },
        hoverPaintStyle: getOutputEndpointStyle(nodeTypeData, "--color-primary"),
        scope,
        source: true,
        target: outputName !== NodeConnectionType.Main,
        enabled: !isReadOnly,
        parameters: {
          connection: "source",
          nodeId: nodeId.value,
          type: outputName,
          index: typeIndex
        },
        hoverClass: "dot-output-endpoint-hover",
        connectionsDirected: true,
        dragAllowedWhenFull: false,
        ...getOutputConnectionStyle(outputName, outputConfiguration, nodeTypeData)
      };
      const endpoint = instance == null ? void 0 : instance.addEndpoint(
        refs.value[((_a = data.value) == null ? void 0 : _a.name) ?? ""],
        newEndpointData
      );
      if (!endpoint) {
        return;
      }
      addEndpointTestingData(endpoint, "output", typeIndex);
      if (outputConfiguration.displayName && isValidNodeConnectionType(outputName)) {
        const overlaySpec = getOutputNameOverlay(
          outputConfiguration.displayName,
          outputName,
          outputConfiguration == null ? void 0 : outputConfiguration.category
        );
        endpoint.addOverlay(overlaySpec);
      }
      if (!Array.isArray(endpoint)) {
        endpoint.__meta = {
          nodeName: node2.name,
          nodeId: nodeId.value,
          index: typeIndex,
          totalEndpoints: outputsOfSameRootType.length,
          endpointLabelLength
        };
      }
      if (!isReadOnly && outputName === NodeConnectionType.Main) {
        const plusEndpointData = {
          uuid: getOutputEndpointUUID(nodeId.value, outputName, typeIndex),
          anchor: anchorPosition,
          maxConnections: -1,
          endpoint: {
            type: "N8nPlus",
            options: {
              dimensions: 24,
              connectedEndpoint: endpoint,
              showOutputLabel: outputs2.value.length === 1,
              size: outputs2.value.length >= 3 ? "small" : "medium",
              endpointLabelLength,
              hoverMessage: i18n2.baseText("nodeBase.clickToAddNodeOrDragToConnect")
            }
          },
          source: true,
          target: false,
          enabled: !isReadOnly,
          paintStyle: {
            outlineStroke: "none"
          },
          hoverPaintStyle: {
            outlineStroke: "none"
          },
          parameters: {
            connection: "source",
            nodeId: nodeId.value,
            type: outputName,
            index: typeIndex,
            category: outputConfiguration == null ? void 0 : outputConfiguration.category
          },
          cssClass: "plus-draggable-endpoint",
          dragAllowedWhenFull: false
        };
        if (outputConfiguration == null ? void 0 : outputConfiguration.category) {
          plusEndpointData.cssClass = `${plusEndpointData.cssClass} ${outputConfiguration == null ? void 0 : outputConfiguration.category}`;
        }
        if (!instance || !data.value) {
          return;
        }
        const plusEndpoint = instance.addEndpoint(
          refs.value[data.value.name],
          plusEndpointData
        );
        addEndpointTestingData(plusEndpoint, "plus", typeIndex);
        if (!Array.isArray(plusEndpoint)) {
          plusEndpoint.__meta = {
            nodeName: node2.name,
            nodeId: nodeId.value,
            index: typeIndex,
            nodeType: node2.type,
            totalEndpoints: outputsOfSameRootType.length
          };
        }
      }
    });
  }
  function addNode(node2) {
    const nodeTypeData = nodeTypesStore.getNodeType(node2.type, node2.typeVersion) ?? nodeTypesStore.getNodeType(NO_OP_NODE_TYPE);
    addInputEndpoints(node2, nodeTypeData);
    addOutputEndpoints(node2, nodeTypeData);
  }
  function getEndpointColor(connectionType2) {
    return `--node-type-${connectionType2}-color`;
  }
  function getInputConnectionStyle(connectionType2, nodeTypeData) {
    if (connectionType2 === NodeConnectionType.Main) {
      return {
        paintStyle: getInputEndpointStyle(
          nodeTypeData,
          getEndpointColor(NodeConnectionType.Main),
          connectionType2
        )
      };
    }
    if (!isValidNodeConnectionType(connectionType2)) {
      return {};
    }
    const createSupplementalConnectionType = (connectionName) => ({
      endpoint: createAddInputEndpointSpec(
        connectionName,
        getEndpointColor(connectionName)
      )
    });
    return createSupplementalConnectionType(connectionType2);
  }
  function getOutputConnectionStyle(connectionType2, outputConfiguration, nodeTypeData) {
    const createSupplementalConnectionType = (connectionName) => ({
      endpoint: createDiamondOutputEndpointSpec(),
      paintStyle: getOutputEndpointStyle(
        nodeTypeData,
        getEndpointColor(connectionName)
      ),
      hoverPaintStyle: getOutputEndpointStyle(
        nodeTypeData,
        getEndpointColor(connectionName)
      )
    });
    const type = "output";
    if (connectionType2 === NodeConnectionType.Main) {
      if (outputConfiguration.category === "error") {
        return {
          paintStyle: {
            ...getOutputEndpointStyle(
              nodeTypeData,
              getEndpointColor(NodeConnectionType.Main)
            ),
            fill: "var(--color-danger)"
          },
          cssClass: `dot-${type}-endpoint`
        };
      }
      return {
        paintStyle: getOutputEndpointStyle(
          nodeTypeData,
          getEndpointColor(NodeConnectionType.Main)
        ),
        cssClass: `dot-${type}-endpoint`
      };
    }
    if (!isValidNodeConnectionType(connectionType2)) {
      return {};
    }
    return createSupplementalConnectionType(connectionType2);
  }
  function touchEnd(_e) {
    if (deviceSupport.isTouchDevice && uiStore.isActionActive["dragActive"]) {
      uiStore.removeActiveAction("dragActive");
    }
  }
  function mouseLeftClick(e) {
    var _a, _b;
    const path = e.path || ((_a = e.composedPath) == null ? void 0 : _a.call(e));
    for (let index = 0; index < path.length; index++) {
      if (path[index].className && typeof path[index].className === "string" && path[index].className.includes("no-select-on-click")) {
        return;
      }
    }
    if (!deviceSupport.isTouchDevice) {
      if (uiStore.isActionActive["dragActive"]) {
        uiStore.removeActiveAction("dragActive");
      } else {
        if (!deviceSupport.isCtrlKeyPressed(e)) {
          emit("deselectAllNodes");
        }
        if (uiStore.isNodeSelected[((_b = data.value) == null ? void 0 : _b.name) ?? ""]) {
          emit("deselectNode", name);
        } else {
          emit("nodeSelected", name);
        }
      }
    }
  }
  return {
    getSpacerIndexes,
    addInputEndpoints,
    addOutputEndpoints,
    addNode,
    mouseLeftClick,
    touchEnd,
    inputs: inputs2,
    outputs: outputs2
  };
}
const _hoisted_1$f = ["id", "data-name"];
const _hoisted_2$a = { class: "select-sticky-background" };
const _hoisted_3$8 = ["title"];
const _hoisted_4$2 = ["title"];
const _hoisted_5$1 = { class: "content" };
const _hoisted_6$1 = ["onClick"];
const _sfc_main$F = /* @__PURE__ */ defineComponent({
  ...{ name: "Sticky" },
  __name: "Sticky",
  props: {
    nodeViewScale: { default: 1 },
    gridSize: { default: GRID_SIZE },
    name: {},
    instance: {},
    isReadOnly: { type: Boolean },
    isActive: { type: Boolean },
    hideActions: { type: Boolean },
    disableSelecting: { type: Boolean },
    showCustomTooltip: { type: Boolean },
    workflow: {}
  },
  emits: ["removeNode", "nodeSelected"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const deviceSupport = useDeviceSupport();
    const telemetry = useTelemetry();
    const toast = useToast();
    const ndvStore = useNDVStore();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const isResizing = ref(false);
    const isTouchActive = ref(false);
    const forceActions = ref(false);
    const isColorPopoverVisible = ref(false);
    const stickOptions = ref();
    const setForceActions = (value) => {
      forceActions.value = value;
    };
    const setColorPopoverVisible = (value) => {
      isColorPopoverVisible.value = value;
    };
    const contextMenu2 = useContextMenu((action2) => {
      if (action2 === "change_color") {
        setForceActions(true);
        setColorPopoverVisible(true);
      }
    });
    const nodeBase = useNodeBase({
      name: props.name,
      instance: props.instance,
      workflowObject: props.workflow,
      isReadOnly: props.isReadOnly,
      emit
    });
    onClickOutside(stickOptions, () => setColorPopoverVisible(false));
    __expose({
      deviceSupport,
      toast,
      contextMenu: contextMenu2,
      forceActions,
      ...nodeBase,
      setForceActions,
      isColorPopoverVisible,
      setColorPopoverVisible,
      stickOptions
    });
    const data = computed(() => workflowsStore.getNodeByName(props.name));
    const node2 = computed(() => workflowsStore.getNodeByName(props.name));
    const nodeId = computed(() => {
      var _a;
      return (_a = data.value) == null ? void 0 : _a.id;
    });
    const nodeType = computed(() => {
      return data.value && nodeTypesStore.getNodeType(data.value.type, data.value.typeVersion);
    });
    const defaultText = computed(() => {
      if (!nodeType.value) {
        return "";
      }
      const properties = nodeType.value.properties;
      const content2 = properties.find((property) => property.name === "content");
      return content2 && isString(content2.default) ? content2.default : "";
    });
    const isSelected = computed(
      () => uiStore.getSelectedNodes.find(({ name }) => {
        var _a;
        return name === ((_a = data.value) == null ? void 0 : _a.name);
      }) !== void 0
    );
    const position2 = computed(() => node2.value ? node2.value.position : [0, 0]);
    const height = computed(
      () => node2.value && isNumber(node2.value.parameters.height) ? node2.value.parameters.height : 0
    );
    const width = computed(
      () => node2.value && isNumber(node2.value.parameters.width) ? node2.value.parameters.width : 0
    );
    const stickySize = computed(() => ({
      height: height.value + "px",
      width: width.value + "px"
    }));
    const stickyPosition = computed(() => ({
      left: position2.value[0] + "px",
      top: position2.value[1] + "px",
      zIndex: props.isActive ? 9999999 : -1 * Math.floor(height.value * width.value / 1e3)
    }));
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const showActions = computed(
      () => !(props.hideActions || props.isReadOnly || workflowRunning.value || isResizing.value) || forceActions.value
    );
    onMounted(() => {
      if (data.value !== null) {
        try {
          nodeBase.addNode(data.value);
        } catch (error2) {
        }
      }
    });
    const onShowPopover = () => setForceActions(true);
    const onHidePopover = () => setForceActions(false);
    const deleteNode = async () => {
      assert(data.value);
      await nextTick();
      emit("removeNode", data.value.name);
    };
    const changeColor = (index) => {
      var _a, _b;
      workflowsStore.updateNodeProperties({
        name: props.name,
        properties: {
          parameters: {
            ...(_a = node2.value) == null ? void 0 : _a.parameters,
            color: index
          },
          position: ((_b = node2.value) == null ? void 0 : _b.position) ?? [0, 0]
        }
      });
    };
    const onEdit = (edit) => {
      if (edit && !props.isActive && node2.value) {
        ndvStore.activeNodeName = node2.value.name;
      } else if (props.isActive && !edit) {
        ndvStore.activeNodeName = null;
      }
    };
    const onMarkdownClick = (link) => {
      if (link) {
        const isOnboardingNote = props.name === QUICKSTART_NOTE_NAME;
        const isWelcomeVideo = link.querySelector('img[alt="n8n quickstart video"]');
        const type = isOnboardingNote && isWelcomeVideo ? "welcome_video" : isOnboardingNote && link.getAttribute("href") === "/templates" ? "templates" : "other";
        telemetry.track("User clicked note link", { type });
      }
    };
    const setParameters = (params) => {
      if (node2.value) {
        const nodeParameters = {
          content: isString(params.content) ? params.content : node2.value.parameters.content,
          height: isNumber(params.height) ? params.height : node2.value.parameters.height,
          width: isNumber(params.width) ? params.width : node2.value.parameters.width,
          color: isString(params.color) ? params.color : node2.value.parameters.color
        };
        workflowsStore.setNodeParameters({
          key: node2.value.id,
          name: node2.value.name,
          value: nodeParameters
        });
      }
    };
    const onInputChange = (content2) => {
      if (!node2.value) {
        return;
      }
      node2.value.parameters.content = content2;
      setParameters({ content: content2 });
    };
    const setPosition = (newPosition) => {
      if (!node2.value) return;
      workflowsStore.updateNodeProperties({
        name: node2.value.name,
        properties: { position: newPosition }
      });
    };
    const onResizeStart = () => {
      isResizing.value = true;
      if (!isSelected.value && node2.value) {
        emit("nodeSelected", node2.value.name, false, true);
      }
    };
    const onResize = ({
      height: height2,
      width: width2,
      dX,
      dY
    }) => {
      if (!node2.value) {
        return;
      }
      if (dX !== 0 || dY !== 0) {
        setPosition([node2.value.position[0] + (dX || 0), node2.value.position[1] + (dY || 0)]);
      }
      setParameters({ height: height2, width: width2 });
    };
    const onResizeEnd = () => {
      isResizing.value = false;
    };
    const touchStart = () => {
      if (deviceSupport.isTouchDevice && !deviceSupport.isMacOs && !isTouchActive.value) {
        isTouchActive.value = true;
        setTimeout(() => {
          isTouchActive.value = false;
        }, 2e3);
      }
    };
    const onContextMenu = (e) => {
      if (node2.value && !props.isActive) {
        contextMenu2.open(e, { source: "node-right-click", nodeId: node2.value.id });
      } else {
        e.stopPropagation();
      }
    };
    return (_ctx, _cache) => {
      var _a, _b;
      const _component_N8nResizeableSticky = resolveComponent("N8nResizeableSticky");
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_popover = resolveComponent("n8n-popover");
      const _directive_touch = resolveDirective("touch");
      return openBlock(), createElementBlock("div", {
        id: nodeId.value,
        ref: (_a = data.value) == null ? void 0 : _a.name,
        class: "sticky-wrapper",
        style: normalizeStyle(stickyPosition.value),
        "data-name": (_b = data.value) == null ? void 0 : _b.name,
        "data-test-id": "sticky"
      }, [
        createBaseVNode("div", {
          class: normalizeClass({
            "sticky-default": true,
            "touch-active": isTouchActive.value,
            "is-touch-device": unref(deviceSupport).isTouchDevice,
            "is-read-only": _ctx.isReadOnly
          }),
          style: normalizeStyle(stickySize.value)
        }, [
          withDirectives(createBaseVNode("div", _hoisted_2$a, null, 512), [
            [vShow, isSelected.value]
          ]),
          withDirectives((openBlock(), createElementBlock("div", {
            class: "sticky-box",
            onClick: _cache[0] || (_cache[0] = withModifiers(
              //@ts-ignore
              (...args) => unref(nodeBase).mouseLeftClick && unref(nodeBase).mouseLeftClick(...args),
              ["left"]
            )),
            onContextmenu: onContextMenu
          }, [
            node2.value ? (openBlock(), createBlock(_component_N8nResizeableSticky, {
              key: 0,
              id: node2.value.id,
              "model-value": node2.value.parameters.content,
              height: node2.value.parameters.height,
              width: node2.value.parameters.width,
              scale: _ctx.nodeViewScale,
              "background-color": node2.value.parameters.color,
              "read-only": _ctx.isReadOnly,
              "default-text": defaultText.value,
              "edit-mode": _ctx.isActive && !_ctx.isReadOnly,
              "grid-size": _ctx.gridSize,
              onEdit,
              onResizestart: onResizeStart,
              onResize,
              onResizeend: onResizeEnd,
              onMarkdownClick,
              "onUpdate:modelValue": onInputChange
            }, null, 8, ["id", "model-value", "height", "width", "scale", "background-color", "read-only", "default-text", "edit-mode", "grid-size"])) : createCommentVNode("", true)
          ], 32)), [
            [_directive_touch, touchStart, "start"],
            [_directive_touch, unref(nodeBase).touchEnd, "end"]
          ]),
          withDirectives(createBaseVNode("div", {
            ref_key: "stickOptions",
            ref: stickOptions,
            class: normalizeClass({ "sticky-options": true, "no-select-on-click": true, "force-show": forceActions.value })
          }, [
            withDirectives((openBlock(), createElementBlock("div", {
              class: "option",
              "data-test-id": "delete-sticky",
              title: _ctx.$locale.baseText("node.delete")
            }, [
              createVNode(_component_font_awesome_icon, { icon: "trash" })
            ], 8, _hoisted_3$8)), [
              [_directive_touch, deleteNode, "tap"]
            ]),
            createVNode(_component_n8n_popover, {
              effect: "dark",
              trigger: "click",
              placement: "top",
              "popper-style": { width: "208px" },
              visible: isColorPopoverVisible.value,
              onShow: onShowPopover,
              onHide: onHidePopover
            }, {
              reference: withCtx(() => [
                createBaseVNode("div", {
                  class: "option",
                  "data-test-id": "change-sticky-color",
                  title: _ctx.$locale.baseText("node.changeColor"),
                  onClick: _cache[1] || (_cache[1] = () => setColorPopoverVisible(!isColorPopoverVisible.value))
                }, [
                  createVNode(_component_font_awesome_icon, { icon: "palette" })
                ], 8, _hoisted_4$2)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_5$1, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(Array.from({ length: 7 }), (_, index) => {
                    var _a2, _b2;
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(["color", `sticky-color-${index + 1}`]),
                      "data-test-id": "color",
                      style: normalizeStyle({
                        "border-width": "1px",
                        "border-style": "solid",
                        "border-color": "var(--color-foreground-xdark)",
                        "background-color": `var(--color-sticky-background-${index + 1})`,
                        "box-shadow": index === 0 && ((_a2 = node2.value) == null ? void 0 : _a2.parameters.color) === "" || index + 1 === ((_b2 = node2.value) == null ? void 0 : _b2.parameters.color) ? `0 0 0 1px var(--color-sticky-background-${index + 1})` : "none"
                      }),
                      onClick: ($event) => changeColor(index + 1)
                    }, null, 14, _hoisted_6$1);
                  }), 128))
                ])
              ]),
              _: 1
            }, 8, ["visible"])
          ], 2), [
            [vShow, showActions.value]
          ])
        ], 6)
      ], 12, _hoisted_1$f);
    };
  }
});
const __unplugin_components_1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$F, [["__scopeId", "data-v-c3c3325d"]]);
const _hoisted_1$e = ["id", "data-name", "data-node-type"];
const _hoisted_2$9 = { class: "select-background" };
const _hoisted_3$7 = {
  key: 0,
  class: "trigger-icon"
};
const _hoisted_4$1 = {
  key: 0,
  class: "node-issues",
  "data-test-id": "node-issues"
};
const _hoisted_5 = {
  key: 1,
  class: "waiting"
};
const _hoisted_6 = ["textContent"];
const _hoisted_7 = {
  key: 2,
  class: "node-pin-data-icon"
};
const _hoisted_8 = {
  key: 0,
  class: "items-count"
};
const _hoisted_9 = { key: 3 };
const _hoisted_10 = {
  key: 4,
  class: "data-count"
};
const _hoisted_11 = {
  key: 0,
  class: "items-count"
};
const _hoisted_12 = ["title"];
const _hoisted_13 = ["title"];
const _hoisted_14 = { class: "node-trigger-tooltip__wrapper" };
const _hoisted_15 = ["textContent"];
const _hoisted_16 = { class: "node-description" };
const _hoisted_17 = ["title"];
const _hoisted_18 = { "data-test-id": "canvas-node-box-title" };
const _hoisted_19 = { key: 0 };
const _hoisted_20 = ["title"];
const _hoisted_21 = { class: "node-options-inner" };
const _sfc_main$E = /* @__PURE__ */ defineComponent({
  __name: "Node",
  props: {
    name: {},
    instance: {},
    workflow: {},
    isReadOnly: { type: Boolean, default: false },
    isActive: { type: Boolean, default: false },
    hideActions: { type: Boolean, default: false },
    disableSelecting: { type: Boolean, default: false },
    showCustomTooltip: { type: Boolean, default: false },
    isProductionExecutionPreview: { type: Boolean, default: false },
    disablePointerEvents: { type: Boolean, default: false },
    hideNodeIssues: { type: Boolean, default: false }
  },
  emits: ["run", "runWorkflow", "removeNode", "toggleDisableNode"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const workflowsStore = useWorkflowsStore();
    const nodeTypesStore = useNodeTypesStore();
    const ndvStore = useNDVStore();
    const uiStore = useUIStore();
    const contextMenu2 = useContextMenu();
    const nodeHelpers = useNodeHelpers();
    const pinnedData2 = usePinnedData(workflowsStore.getNodeByName(props.name));
    const deviceSupport = useDeviceSupport();
    const { callDebounced } = useDebounce();
    const i18n2 = useI18n();
    const telemetry = useTelemetry();
    const nodeBase = useNodeBase({
      name: props.name,
      instance: props.instance,
      workflowObject: props.workflow,
      isReadOnly: props.isReadOnly,
      emit
    });
    const isTouchActive = ref(false);
    const nodeSubtitle = ref("");
    const showTriggerNodeTooltip = ref(false);
    const pinDataDiscoveryTooltipVisible = ref(false);
    const dragging2 = ref(false);
    const node2 = computed(() => workflowsStore.getNodeByName(props.name));
    const nodeId = computed(() => {
      var _a;
      return ((_a = node2.value) == null ? void 0 : _a.id) ?? "";
    });
    const showPinnedDataInfo = computed(
      () => pinnedData2.hasData.value && !props.isProductionExecutionPreview
    );
    const isScheduledGroup = computed(() => {
      var _a;
      return ((_a = nodeType.value) == null ? void 0 : _a.group.includes("schedule")) === true;
    });
    const iconColorDefault = computed(() => {
      if (isConfigNode.value) {
        return "var(--color-text-base)";
      }
      return void 0;
    });
    const nodeRunData = computed(() => {
      if (!node2.value) return [];
      return workflowsStore.getWorkflowResultDataByNodeName(node2.value.name) ?? [];
    });
    const hasIssues2 = computed(() => {
      var _a;
      if (nodeExecutionStatus.value && ["crashed", "error"].includes(nodeExecutionStatus.value))
        return true;
      if (pinnedData2.hasData.value) return false;
      if (((_a = node2.value) == null ? void 0 : _a.issues) !== void 0 && Object.keys(node2.value.issues).length) {
        return true;
      }
      return false;
    });
    const workflowDataItems = computed(() => {
      const workflowResultDataNode = nodeRunData.value;
      if (workflowResultDataNode === null) {
        return 0;
      }
      return workflowResultDataNode.length;
    });
    const canvasOffsetPosition = computed(() => uiStore.nodeViewOffsetPosition);
    const getTriggerNodeTooltip = computed(() => {
      if (nodeType.value !== null && nodeType.value.hasOwnProperty("eventTriggerDescription")) {
        const nodeName = i18n2.shortNodeType(nodeType.value.name);
        const { eventTriggerDescription } = nodeType.value;
        return i18n2.nodeText().eventTriggerDescription(nodeName, eventTriggerDescription ?? "");
      } else {
        return i18n2.baseText("node.waitingForYouToCreateAnEventIn", {
          interpolate: {
            nodeType: nodeType.value ? getTriggerNodeServiceName(nodeType.value) : ""
          }
        });
      }
    });
    const isPollingTypeNode = computed(() => {
      var _a;
      return !!((_a = nodeType.value) == null ? void 0 : _a.polling);
    });
    const isExecuting = computed(() => {
      if (!node2.value || !workflowRunning.value) return false;
      return workflowsStore.isNodeExecuting(node2.value.name);
    });
    const isSingleActiveTriggerNode = computed(() => {
      const nodes = workflowsStore.workflowTriggerNodes.filter((triggerNode) => {
        const nodeType2 = nodeTypesStore.getNodeType(triggerNode.type, triggerNode.typeVersion);
        return nodeType2 && nodeType2.eventTriggerDescription !== "" && !triggerNode.disabled;
      });
      return nodes.length === 1;
    });
    const isManualTypeNode = computed(() => {
      var _a;
      return ((_a = node2.value) == null ? void 0 : _a.type) === MANUAL_TRIGGER_NODE_TYPE;
    });
    const isConfigNode = computed(() => {
      if (!node2.value) return false;
      return nodeTypesStore.isConfigNode(props.workflow, node2.value, node2.value.type ?? "");
    });
    const isConfigurableNode = computed(() => {
      var _a;
      if (!node2.value) return false;
      return nodeTypesStore.isConfigurableNode(props.workflow, node2.value, ((_a = node2.value) == null ? void 0 : _a.type) ?? "");
    });
    const isTriggerNode = computed(
      () => node2.value ? nodeTypesStore.isTriggerNode(node2.value.type) : false
    );
    const isTriggerNodeTooltipEmpty = computed(
      () => nodeType.value !== null ? nodeType.value.eventTriggerDescription === "" : false
    );
    const isNodeDisabled = computed(() => {
      var _a;
      return ((_a = node2.value) == null ? void 0 : _a.disabled) ?? false;
    });
    const nodeType = computed(
      () => node2.value && nodeTypesStore.getNodeType(node2.value.type, node2.value.typeVersion)
    );
    const nodeWrapperClass = computed(() => {
      const classes = {
        "node-wrapper": true,
        "node-wrapper--trigger": isTriggerNode.value,
        "node-wrapper--configurable": isConfigurableNode.value,
        "node-wrapper--config": isConfigNode.value
      };
      if (nodeBase.outputs.value.length) {
        const outputTypes = getConnectionTypes(nodeBase.outputs.value);
        const otherOutputs = outputTypes.filter((outputName) => outputName !== NodeConnectionType.Main);
        if (otherOutputs.length) {
          otherOutputs.forEach((outputName) => {
            classes[`node-wrapper--connection-type-${outputName}`] = true;
          });
        }
      }
      return classes;
    });
    const nodeWrapperStyles = computed(() => {
      const styles = {
        left: position2.value[0] + "px",
        top: position2.value[1] + "px"
      };
      if (node2.value && nodeType.value) {
        const inputs2 = getNodeInputs(props.workflow, node2.value, nodeType.value) ?? [];
        const inputTypes = getConnectionTypes(inputs2);
        const nonMainInputs = inputTypes.filter((input) => input !== NodeConnectionType.Main);
        if (nonMainInputs.length) {
          inputs2.filter(
            (input) => typeof input !== "string" && input.required
          );
          let spacerCount = 0;
          styles["--configurable-node-input-count"] = nonMainInputs.length + spacerCount;
        }
        const mainInputs = inputTypes.filter((output) => output === NodeConnectionType.Main);
        styles["--node-main-input-count"] = mainInputs.length;
        let outputs2 = [];
        if (props.workflow.nodes[node2.value.name]) {
          outputs2 = getNodeOutputs(props.workflow, node2.value, nodeType.value);
        }
        const outputTypes = getConnectionTypes(outputs2);
        const mainOutputs = outputTypes.filter((output) => output === NodeConnectionType.Main);
        styles["--node-main-output-count"] = mainOutputs.length;
      }
      return styles;
    });
    const nodeClass = computed(() => {
      var _a;
      return {
        "node-box": true,
        disabled: (_a = node2.value) == null ? void 0 : _a.disabled,
        executing: isExecuting.value
      };
    });
    const nodeExecutionStatus = computed(() => {
      var _a, _b;
      const nodeExecutionRunData = (_a = workflowsStore.getWorkflowRunData) == null ? void 0 : _a[props.name];
      if (nodeExecutionRunData) {
        return ((_b = nodeExecutionRunData.filter(Boolean)[0]) == null ? void 0 : _b.executionStatus) ?? "";
      }
      return "";
    });
    const nodeIssues = computed(() => {
      var _a, _b;
      const issues2 = [];
      const nodeExecutionRunData = (_a = workflowsStore.getWorkflowRunData) == null ? void 0 : _a[props.name];
      if (nodeExecutionRunData) {
        nodeExecutionRunData.forEach((executionRunData) => {
          if (executionRunData == null ? void 0 : executionRunData.error) {
            const { message, description: description2 } = executionRunData.error;
            const issue = `${message}${description2 ? ` (${description2})` : ""}`;
            issues2.push(xss(issue));
          }
        });
      }
      if (((_b = node2.value) == null ? void 0 : _b.issues) !== void 0) {
        issues2.push(...nodeIssuesToString(node2.value.issues, node2.value));
      }
      return issues2;
    });
    const nodeDisabledTitle = computed(() => {
      var _a;
      return ((_a = node2.value) == null ? void 0 : _a.disabled) ? i18n2.baseText("node.enable") : i18n2.baseText("node.disable");
    });
    const position2 = computed(() => node2.value ? node2.value.position : [0, 0]);
    const showDisabledLineThrough = computed(
      () => {
        var _a;
        return !isConfigurableNode.value && !!(((_a = node2.value) == null ? void 0 : _a.disabled) && nodeBase.inputs.value.length === 1 && nodeBase.outputs.value.length === 1);
      }
    );
    const nodeTitle = computed(() => {
      var _a, _b;
      if (((_a = node2.value) == null ? void 0 : _a.name) === "Start") {
        return i18n2.headerText({
          key: "headers.start.displayName",
          fallback: "Start"
        });
      }
      return ((_b = node2.value) == null ? void 0 : _b.name) ?? "";
    });
    const waiting2 = computed(() => {
      const workflowExecution = workflowsStore.getWorkflowExecution;
      if ((workflowExecution == null ? void 0 : workflowExecution.waitTill) && !(workflowExecution == null ? void 0 : workflowExecution.finished)) {
        const lastNodeExecuted = get$4(workflowExecution, "data.resultData.lastNodeExecuted");
        if (props.name === lastNodeExecuted) {
          const node22 = props.workflow.getNode(lastNodeExecuted);
          if (node22 && node22.type === WAIT_NODE_TYPE && ["webhook", "form"].includes(node22.parameters.resume)) {
            const event = node22.parameters.resume === "webhook" ? i18n2.baseText("node.theNodeIsWaitingWebhookCall") : i18n2.baseText("node.theNodeIsWaitingFormCall");
            return event;
          }
          if ((node22 == null ? void 0 : node22.parameters.operation) === SEND_AND_WAIT_OPERATION) {
            return i18n2.baseText("node.theNodeIsWaitingUserInput");
          }
          const waitDate = new Date(workflowExecution.waitTill);
          if (waitDate.toISOString() === WAIT_TIME_UNLIMITED) {
            return i18n2.baseText("node.theNodeIsWaitingIndefinitelyForAnIncomingWebhookCall");
          }
          return i18n2.baseText("node.nodeIsWaitingTill", {
            interpolate: {
              date: waitDate.toLocaleDateString(),
              time: waitDate.toLocaleTimeString()
            }
          });
        }
      }
      return void 0;
    });
    const workflowRunning = computed(() => uiStore.isActionActive.workflowRunning);
    const nodeStyle = computed(() => {
      var _a, _b, _c, _d;
      const returnStyles = {};
      let borderColor = "--color-foreground-xdark";
      if (isConfigurableNode.value || isConfigNode.value) {
        borderColor = "--color-foreground-dark";
      }
      if ((_a = node2.value) == null ? void 0 : _a.disabled) {
        borderColor = "--color-foreground-base";
      } else if (!isExecuting.value) {
        if (hasIssues2.value && !props.hideNodeIssues) {
          if (((_d = (_c = (_b = nodeRunData.value) == null ? void 0 : _b[0]) == null ? void 0 : _c.error) == null ? void 0 : _d.functionality) !== "configuration-node") {
            borderColor = "--color-danger";
            returnStyles["border-width"] = "2px";
            returnStyles["border-style"] = "solid";
          }
        } else if (!!waiting2.value || showPinnedDataInfo.value) {
          borderColor = "--color-node-pinned-border";
        } else if (nodeExecutionStatus.value === "unknown") {
          borderColor = "--color-foreground-xdark";
        } else if (workflowDataItems.value) {
          returnStyles["border-width"] = "2px";
          returnStyles["border-style"] = "solid";
          borderColor = "--color-success";
        }
      }
      returnStyles["border-color"] = `var(${borderColor})`;
      return returnStyles;
    });
    const isSelected = computed(
      () => uiStore.getSelectedNodes.find((n) => {
        var _a;
        return n.name === ((_a = node2.value) == null ? void 0 : _a.name);
      }) !== void 0
    );
    const shiftOutputCount = computed(() => !!(nodeType.value && nodeBase.outputs.value.length > 2));
    const shouldShowTriggerTooltip = computed(() => {
      return !!node2.value && isTriggerNode.value && !isPollingTypeNode.value && !pinnedData2.hasData.value && !isNodeDisabled.value && workflowRunning.value && workflowDataItems.value === 0 && isSingleActiveTriggerNode.value && !isTriggerNodeTooltipEmpty.value && !hasIssues2.value && !dragging2.value;
    });
    const isContextMenuOpen = computed(
      () => {
        var _a, _b;
        return contextMenu2.isOpen.value && ((_a = contextMenu2.target.value) == null ? void 0 : _a.source) === "node-button" && contextMenu2.target.value.nodeId === ((_b = node2.value) == null ? void 0 : _b.id);
      }
    );
    const iconNodeType = computed(() => {
      var _a, _b, _c;
      if (((_a = node2.value) == null ? void 0 : _a.type) === SIMULATE_NODE_TYPE || ((_b = node2.value) == null ? void 0 : _b.type) === SIMULATE_TRIGGER_NODE_TYPE) {
        const icon2 = (_c = node2.value.parameters) == null ? void 0 : _c.icon;
        const iconValue = props.workflow.expression.getSimpleParameterValue(
          node2.value,
          icon2,
          "internal",
          {}
        );
        if (iconValue && typeof iconValue === "string") {
          return nodeTypesStore.getNodeType(iconValue);
        }
      }
      return nodeType.value;
    });
    const hasSeenPinDataTooltip = useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG);
    watch(
      () => props.isActive,
      (newValue, oldValue) => {
        if (!newValue && oldValue) {
          setSubtitle();
        }
      }
    );
    watch(canvasOffsetPosition, () => {
      if (showTriggerNodeTooltip.value) {
        showTriggerNodeTooltip.value = false;
        setTimeout(() => {
          showTriggerNodeTooltip.value = shouldShowTriggerTooltip.value;
        }, 200);
      }
      if (pinDataDiscoveryTooltipVisible.value) {
        pinDataDiscoveryTooltipVisible.value = false;
        setTimeout(() => {
          pinDataDiscoveryTooltipVisible.value = true;
        }, 200);
      }
    });
    watch(shouldShowTriggerTooltip, (newValue) => {
      if (newValue) {
        setTimeout(() => {
          showTriggerNodeTooltip.value = shouldShowTriggerTooltip.value;
        }, 2500);
      } else {
        showTriggerNodeTooltip.value = false;
      }
    });
    watch(
      nodeRunData,
      (newValue) => {
        if (!node2.value) {
          return;
        }
        emit("run", { name: node2.value.name, data: newValue, waiting: !!waiting2.value });
      },
      { deep: true }
    );
    const unwatchWorkflowDataItems = watch(workflowDataItems, (dataItemsCount) => {
      if (!hasSeenPinDataTooltip.value) showPinDataDiscoveryTooltip(dataItemsCount);
    });
    onMounted(() => {
      if (node2.value !== null) {
        try {
          nodeBase.addNode(node2.value);
        } catch (error2) {
        }
      }
      setTimeout(() => {
        setSubtitle();
      }, 0);
      setTimeout(() => {
        if (nodeRunData.value && node2.value) {
          emit("run", {
            name: node2.value.name,
            data: nodeRunData.value,
            waiting: !!waiting2.value
          });
        }
      }, 0);
    });
    function showPinDataDiscoveryTooltip(dataItemsCount) {
      if (!isTriggerNode.value || isManualTypeNode.value || isScheduledGroup.value || uiStore.isAnyModalOpen || dataItemsCount === 0 || pinnedData2.hasData.value)
        return;
      useStorage(LOCAL_STORAGE_PIN_DATA_DISCOVERY_CANVAS_FLAG).value = "true";
      pinDataDiscoveryTooltipVisible.value = true;
      unwatchWorkflowDataItems();
    }
    function setSubtitle() {
      if (!node2.value || !nodeType.value) return;
      try {
        const subtitle2 = nodeHelpers.getNodeSubtitle(node2.value, nodeType.value, props.workflow) ?? "";
        nodeSubtitle.value = subtitle2.includes(CUSTOM_API_CALL_KEY) ? "" : subtitle2;
      } catch (e) {
      }
    }
    function executeNode() {
      if (!node2.value) return;
      emit("runWorkflow", node2.value.name, "Node.executeNode");
      telemetry.track("User clicked node hover button", {
        node_type: node2.value.type,
        button_name: "execute",
        workflow_id: workflowsStore.workflowId
      });
    }
    function deleteNode() {
      if (!node2.value) return;
      telemetry.track("User clicked node hover button", {
        node_type: node2.value.type,
        button_name: "delete",
        workflow_id: workflowsStore.workflowId
      });
      emit("removeNode", node2.value.name);
    }
    function toggleDisableNode(event) {
      var _a;
      if (!node2.value) return;
      event.currentTarget.blur();
      telemetry.track("User clicked node hover button", {
        node_type: (_a = node2.value) == null ? void 0 : _a.type,
        button_name: "disable",
        workflow_id: workflowsStore.workflowId
      });
      emit("toggleDisableNode", node2.value);
    }
    function onClick(event) {
      void callDebounced(onClickDebounced, { debounceTime: 50, trailing: true }, event);
    }
    function onClickDebounced(...args) {
      const event = args[0];
      const isDoubleClick = event.detail >= 2;
      if (isDoubleClick) {
        setNodeActive();
      } else {
        nodeBase.mouseLeftClick(event);
      }
    }
    function setNodeActive() {
      ndvStore.activeNodeName = node2.value ? node2.value.name : "";
      pinDataDiscoveryTooltipVisible.value = false;
    }
    function touchStart() {
      if (deviceSupport.isTouchDevice && !deviceSupport.isMacOs && !isTouchActive.value) {
        isTouchActive.value = true;
        setTimeout(() => {
          isTouchActive.value = false;
        }, 2e3);
      }
    }
    const touchEnd = nodeBase.touchEnd;
    function openContextMenu(event, source) {
      if (node2.value) {
        contextMenu2.open(event, { source, nodeId: node2.value.id });
      }
    }
    return (_ctx, _cache) => {
      var _a;
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      const _directive_n8n_html = resolveDirective("n8n-html");
      const _directive_touch = resolveDirective("touch");
      return node2.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        id: nodeId.value,
        ref: node2.value.name,
        class: normalizeClass(nodeWrapperClass.value),
        style: normalizeStyle(nodeWrapperStyles.value),
        "data-test-id": "canvas-node",
        "data-name": node2.value.name,
        "data-node-type": (_a = nodeType.value) == null ? void 0 : _a.name,
        onContextmenu: _cache[3] || (_cache[3] = (e) => openContextMenu(e, "node-right-click"))
      }, [
        withDirectives(createBaseVNode("div", _hoisted_2$9, null, 512), [
          [vShow, isSelected.value]
        ]),
        createBaseVNode("div", {
          class: normalizeClass({
            "node-default": true,
            "touch-active": isTouchActive.value,
            "is-touch-device": unref(deviceSupport).isTouchDevice,
            "menu-open": isContextMenuOpen.value,
            "disable-pointer-events": _ctx.disablePointerEvents
          })
        }, [
          withDirectives((openBlock(), createElementBlock("div", {
            class: normalizeClass(nodeClass.value),
            style: normalizeStyle(nodeStyle.value),
            onClick: withModifiers(onClick, ["left"])
          }, [
            isTriggerNode.value ? (openBlock(), createElementBlock("i", _hoisted_3$7, [
              createVNode(_component_n8n_tooltip, { placement: "bottom" }, {
                content: withCtx(() => [
                  withDirectives(createBaseVNode("span", null, null, 512), [
                    [_directive_n8n_html, unref(i18n2).baseText("node.thisIsATriggerNode")]
                  ])
                ]),
                default: withCtx(() => [
                  createVNode(unref(FontAwesomeIcon), {
                    icon: "bolt",
                    size: "lg"
                  })
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            !node2.value.disabled ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass({ "node-info-icon": true, "shift-icon": shiftOutputCount.value })
            }, [
              hasIssues2.value && !_ctx.hideNodeIssues ? (openBlock(), createElementBlock("div", _hoisted_4$1, [
                createVNode(_component_n8n_tooltip, {
                  "show-after": 500,
                  placement: "bottom"
                }, {
                  content: withCtx(() => [
                    createVNode(TitledList, {
                      title: `${unref(i18n2).baseText("node.issues")}:`,
                      items: nodeIssues.value
                    }, null, 8, ["title", "items"])
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(FontAwesomeIcon), { icon: "exclamation-triangle" })
                  ]),
                  _: 1
                })
              ])) : waiting2.value || nodeExecutionStatus.value === "waiting" ? (openBlock(), createElementBlock("div", _hoisted_5, [
                createVNode(_component_n8n_tooltip, { placement: "bottom" }, {
                  content: withCtx(() => [
                    createBaseVNode("div", {
                      textContent: toDisplayString(waiting2.value)
                    }, null, 8, _hoisted_6)
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(FontAwesomeIcon), { icon: "clock" })
                  ]),
                  _: 1
                })
              ])) : showPinnedDataInfo.value ? (openBlock(), createElementBlock("span", _hoisted_7, [
                createVNode(unref(FontAwesomeIcon), { icon: "thumbtack" }),
                workflowDataItems.value > 1 ? (openBlock(), createElementBlock("span", _hoisted_8, toDisplayString(workflowDataItems.value), 1)) : createCommentVNode("", true)
              ])) : nodeExecutionStatus.value === "unknown" ? (openBlock(), createElementBlock("span", _hoisted_9)) : workflowDataItems.value ? (openBlock(), createElementBlock("span", _hoisted_10, [
                createVNode(unref(FontAwesomeIcon), { icon: "check" }),
                workflowDataItems.value > 1 ? (openBlock(), createElementBlock("span", _hoisted_11, toDisplayString(workflowDataItems.value), 1)) : createCommentVNode("", true)
              ])) : createCommentVNode("", true)
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: "node-executing-info",
              title: unref(i18n2).baseText("node.nodeIsExecuting")
            }, [
              createVNode(unref(FontAwesomeIcon), {
                icon: "sync-alt",
                spin: ""
              })
            ], 8, _hoisted_12),
            waiting2.value ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: "node-waiting-spinner",
              title: waiting2.value
            }, [
              createVNode(unref(FontAwesomeIcon), {
                icon: "sync-alt",
                spin: ""
              })
            ], 8, _hoisted_13)) : createCommentVNode("", true),
            createBaseVNode("div", _hoisted_14, [
              createVNode(_component_n8n_tooltip, {
                placement: "top",
                "show-after": 500,
                visible: showTriggerNodeTooltip.value,
                "popper-class": "node-trigger-tooltip__wrapper--item"
              }, {
                content: withCtx(() => [
                  createBaseVNode("div", {
                    textContent: toDisplayString(getTriggerNodeTooltip.value)
                  }, null, 8, _hoisted_15)
                ]),
                default: withCtx(() => [
                  _cache[4] || (_cache[4] = createBaseVNode("span", null, null, -1))
                ]),
                _: 1
              }, 8, ["visible"]),
              isTriggerNode.value ? (openBlock(), createBlock(_component_n8n_tooltip, {
                key: 0,
                placement: "top",
                visible: pinDataDiscoveryTooltipVisible.value,
                "popper-class": "node-trigger-tooltip__wrapper--item"
              }, {
                content: withCtx(() => [
                  createTextVNode(toDisplayString(unref(i18n2).baseText("node.discovery.pinData.canvas")), 1)
                ]),
                default: withCtx(() => [
                  _cache[5] || (_cache[5] = createBaseVNode("span", null, null, -1))
                ]),
                _: 1
              }, 8, ["visible"])) : createCommentVNode("", true)
            ]),
            createVNode(_sfc_main$10, {
              class: "node-icon",
              "node-type": iconNodeType.value,
              size: 40,
              shrink: false,
              "color-default": iconColorDefault.value,
              disabled: node2.value.disabled
            }, null, 8, ["node-type", "color-default", "disabled"])
          ], 6)), [
            [_directive_touch, touchStart, "start"],
            [_directive_touch, unref(touchEnd), "end"]
          ]),
          showDisabledLineThrough.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass({
              "disabled-line-through": true,
              success: !["unknown"].includes(nodeExecutionStatus.value) && workflowDataItems.value > 0
            })
          }, null, 2)) : createCommentVNode("", true)
        ], 2),
        createBaseVNode("div", _hoisted_16, [
          createBaseVNode("div", {
            class: "node-name",
            title: nodeTitle.value
          }, [
            createBaseVNode("p", _hoisted_18, toDisplayString(nodeTitle.value), 1),
            node2.value.disabled ? (openBlock(), createElementBlock("p", _hoisted_19, "(" + toDisplayString(unref(i18n2).baseText("node.disabled")) + ")", 1)) : createCommentVNode("", true)
          ], 8, _hoisted_17),
          nodeSubtitle.value !== void 0 ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "node-subtitle",
            title: nodeSubtitle.value
          }, toDisplayString(nodeSubtitle.value), 9, _hoisted_20)) : createCommentVNode("", true)
        ]),
        !_ctx.isReadOnly ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: "node-options no-select-on-click",
          onContextmenu: _cache[1] || (_cache[1] = withModifiers(() => {
          }, ["stop"])),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"]))
        }, [
          createBaseVNode("div", _hoisted_21, [
            !isConfigNode.value ? (openBlock(), createBlock(unref(_sfc_main$13), {
              key: 0,
              "data-test-id": "execute-node-button",
              type: "tertiary",
              text: "",
              size: "small",
              icon: "play",
              disabled: workflowRunning.value,
              title: unref(i18n2).baseText("node.testStep"),
              onClick: executeNode
            }, null, 8, ["disabled", "title"])) : createCommentVNode("", true),
            createVNode(unref(_sfc_main$13), {
              "data-test-id": "disable-node-button",
              type: "tertiary",
              text: "",
              size: "small",
              icon: "power-off",
              title: nodeDisabledTitle.value,
              onClick: toggleDisableNode
            }, null, 8, ["title"]),
            createVNode(unref(_sfc_main$13), {
              "data-test-id": "delete-node-button",
              type: "tertiary",
              size: "small",
              text: "",
              icon: "trash",
              title: unref(i18n2).baseText("node.delete"),
              onClick: deleteNode
            }, null, 8, ["title"]),
            createVNode(unref(_sfc_main$13), {
              "data-test-id": "overflow-node-button",
              type: "tertiary",
              size: "small",
              text: "",
              icon: "ellipsis-h",
              onClick: _cache[0] || (_cache[0] = (e) => openContextMenu(e, "node-button"))
            })
          ])
        ], 544)), [
          [vShow, !_ctx.hideActions]
        ]) : createCommentVNode("", true)
      ], 46, _hoisted_1$e)) : createCommentVNode("", true);
    };
  }
});
const __unplugin_components_0$6 = /* @__PURE__ */ _export_sfc$1(_sfc_main$E, [["__scopeId", "data-v-88ab292e"]]);
const state = reactive({
  customActions: {},
  delegatedClickHandler: null
});
function useGlobalLinkActions() {
  function registerCustomAction({ key, action: action2 }) {
    state.customActions[key] = action2;
  }
  function unregisterCustomAction(key) {
    const { [key]: _, ...rest } = state.customActions;
    state.customActions = rest;
  }
  function getElementAttributes(element) {
    const attributesObject = {};
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.name.startsWith("data-action-parameter-")) {
        attributesObject[attr.name.replace("data-action-parameter-", "")] = attr.value;
      }
    }
    return attributesObject;
  }
  function delegateClick(e) {
    const clickedElement = e.target;
    if (!(clickedElement instanceof Element) || clickedElement.tagName !== "A") return;
    const actionAttribute = clickedElement.getAttribute("data-action");
    if (actionAttribute && typeof availableActions.value[actionAttribute] === "function") {
      e.preventDefault();
      const elementAttributes = getElementAttributes(clickedElement);
      availableActions.value[actionAttribute](elementAttributes);
    }
  }
  function reload() {
    if (window.top) {
      window.top.location.reload();
    } else {
      window.location.reload();
    }
  }
  const availableActions = computed(() => ({
    reload,
    ...state.customActions
  }));
  onMounted(() => {
    if (state.delegatedClickHandler) return;
    state.delegatedClickHandler = delegateClick;
    window.addEventListener("click", delegateClick);
    globalLinkActionsEventBus.on("registerGlobalLinkAction", registerCustomAction);
  });
  onUnmounted(() => {
    window.removeEventListener("click", delegateClick);
    state.delegatedClickHandler = null;
    globalLinkActionsEventBus.off("registerGlobalLinkAction", registerCustomAction);
  });
  return {
    registerCustomAction,
    unregisterCustomAction
  };
}
function useCanvasMouseSelect() {
  const selectActive = ref(false);
  const selectBox = ref(document.createElement("span"));
  const { isTouchDevice, isCtrlKeyPressed } = useDeviceSupport();
  const uiStore = useUIStore();
  const canvasStore = useCanvasStore();
  const workflowsStore = useWorkflowsStore();
  const { isOpen: isContextMenuOpen } = useContextMenu();
  function _setSelectBoxStyle(styles) {
    Object.assign(selectBox.value.style, styles);
  }
  function _showSelectBox(event) {
    const [x, y] = getMousePositionWithinNodeView(event);
    selectBox.value = Object.assign(selectBox.value, { x, y });
    _setSelectBoxStyle({
      left: selectBox.value.x + "px",
      top: selectBox.value.y + "px",
      visibility: "visible"
    });
    selectActive.value = true;
  }
  function _updateSelectBox(event) {
    const selectionBox = _getSelectionBox(event);
    _setSelectBoxStyle({
      left: selectionBox.x + "px",
      top: selectionBox.y + "px",
      width: selectionBox.width + "px",
      height: selectionBox.height + "px"
    });
  }
  function _hideSelectBox() {
    selectBox.value.x = 0;
    selectBox.value.y = 0;
    _setSelectBoxStyle({
      visibility: "hidden",
      left: "0px",
      top: "0px",
      width: "0px",
      height: "0px"
    });
    selectActive.value = false;
  }
  function _getSelectionBox(event) {
    const [x, y] = getMousePositionWithinNodeView(event);
    return {
      x: Math.min(x, selectBox.value.x),
      y: Math.min(y, selectBox.value.y),
      width: Math.abs(x - selectBox.value.x),
      height: Math.abs(y - selectBox.value.y)
    };
  }
  function _getNodesInSelection(event) {
    const returnNodes = [];
    const selectionBox = _getSelectionBox(event);
    workflowsStore.allNodes.forEach((node2) => {
      if (node2.position[0] < selectionBox.x || node2.position[0] > selectionBox.x + selectionBox.width) {
        return;
      }
      if (node2.position[1] < selectionBox.y || node2.position[1] > selectionBox.y + selectionBox.height) {
        return;
      }
      returnNodes.push(node2);
    });
    return returnNodes;
  }
  function _createSelectBox() {
    selectBox.value.id = "select-box";
    _setSelectBoxStyle({
      margin: "0px auto",
      border: "2px dotted #FF0000",
      // Positioned absolutely within #node-view. This is consistent with how nodes are positioned.
      position: "absolute",
      zIndex: "100",
      visibility: "hidden"
    });
    selectBox.value.addEventListener("mouseup", mouseUpMouseSelect);
    const nodeViewEl = document.querySelector("#node-view");
    nodeViewEl.appendChild(selectBox.value);
  }
  function _mouseMoveSelect(e) {
    if (e.buttons === 0) {
      mouseUpMouseSelect(e);
      return;
    }
    _updateSelectBox(e);
  }
  function mouseUpMouseSelect(e) {
    if ("button" in e && e.button === 2 || isContextMenuOpen.value) return;
    if (!selectActive.value) {
      if (isTouchDevice && e.target instanceof HTMLElement) {
        if (e.target && e.target.id.includes("node-view")) {
          deselectAllNodes();
        }
      }
      return;
    }
    document.removeEventListener("mousemove", _mouseMoveSelect);
    deselectAllNodes();
    const selectedNodes = _getNodesInSelection(e);
    selectedNodes.forEach((node2) => {
      nodeSelected(node2);
    });
    if (selectedNodes.length === 1) {
      uiStore.lastSelectedNode = selectedNodes[0].name;
    }
    _hideSelectBox();
  }
  function mouseDownMouseSelect(e, moveButtonPressed) {
    if (isCtrlKeyPressed(e) || moveButtonPressed || e.button === 2) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    _showSelectBox(e);
    document.addEventListener("mousemove", _mouseMoveSelect);
  }
  function getMousePositionWithinNodeView(event) {
    const mousePosition = getMousePosition$1(event);
    const [relativeX, relativeY] = canvasStore.canvasPositionFromPagePosition(mousePosition);
    const nodeViewScale = canvasStore.nodeViewScale;
    const nodeViewOffsetPosition = uiStore.nodeViewOffsetPosition;
    return getRelativePosition(relativeX, relativeY, nodeViewScale, nodeViewOffsetPosition);
  }
  function nodeDeselected(node2) {
    uiStore.removeNodeFromSelection(node2);
    instance.value.removeFromDragSelection(instance.value.getManagedElement(node2 == null ? void 0 : node2.id));
  }
  function nodeSelected(node2) {
    uiStore.addSelectedNode(node2);
    instance.value.addToDragSelection(instance.value.getManagedElement(node2 == null ? void 0 : node2.id));
  }
  function deselectAllNodes() {
    instance.value.clearDragSelection();
    uiStore.resetSelectedNodes();
    uiStore.lastSelectedNode = null;
    uiStore.lastSelectedNodeOutputIndex = null;
    canvasStore.newNodeInsertPosition = null;
    canvasStore.setLastSelectedConnection(void 0);
  }
  const instance = computed(() => canvasStore.jsPlumbInstance);
  function initializeCanvasMouseSelect() {
    _createSelectBox();
  }
  return {
    selectActive,
    getMousePositionWithinNodeView,
    mouseUpMouseSelect,
    mouseDownMouseSelect,
    nodeDeselected,
    nodeSelected,
    deselectAllNodes,
    initializeCanvasMouseSelect
  };
}
function useUniqueNodeName() {
  function numberSuffixedNames() {
    return useNodeTypesStore().allNodeTypes.reduce((acc, nodeType) => {
      if (typeof nodeType.defaults.name !== "string") {
        throw new Error("Expected node name default to be a string");
      }
      if (/\d$/.test(nodeType.defaults.name)) acc.push(nodeType.defaults.name);
      return acc;
    }, []);
  }
  function uniqueNodeName(originalName, extraNames = []) {
    var _a, _b;
    const { canvasNames } = useWorkflowsStore();
    const isUnique = !canvasNames.has(originalName) && !extraNames.includes(originalName);
    if (isUnique) return originalName;
    const nsn = numberSuffixedNames().find((nsn2) => originalName.startsWith(nsn2));
    if (nsn) {
      let unique2 = "";
      let index2 = 1;
      const remainder = originalName.split(nsn).pop();
      const lastChar = remainder == null ? void 0 : remainder[remainder.length - 1];
      if (lastChar && Number.isInteger(Number(lastChar))) {
        index2 = parseInt(lastChar, 10);
        originalName = originalName.slice(0, -1);
      }
      unique2 = originalName;
      while (canvasNames.has(unique2) || extraNames.includes(unique2)) {
        unique2 = originalName + index2++;
      }
      return unique2;
    }
    if (/^\d+-?\d*$/.test(originalName)) {
      let unique2 = "";
      let index2 = 1;
      const match2 = originalName.match(/(?<base>\d+)-?(?<suffix>\d*)/);
      if (!(match2 == null ? void 0 : match2.groups)) {
        throw new Error("Failed to find match for unique name");
      }
      if (((_a = match2 == null ? void 0 : match2.groups) == null ? void 0 : _a.suffix) !== "") {
        index2 = parseInt(match2.groups.suffix, 10);
      }
      unique2 = match2.groups.base;
      while (canvasNames.has(unique2) || extraNames.includes(unique2)) {
        unique2 = match2.groups.base + "-" + index2++;
      }
      return unique2;
    }
    let unique = "";
    let index = 1;
    const match = originalName.match(/(?<base>.*\D+)(?<suffix>\d*)/);
    if (!(match == null ? void 0 : match.groups)) {
      throw new Error("Failed to find match for unique name");
    }
    if (((_b = match == null ? void 0 : match.groups) == null ? void 0 : _b.suffix) !== "") {
      index = parseInt(match.groups.suffix, 10);
    }
    unique = match.groups.base;
    while (canvasNames.has(unique) || extraNames.includes(unique)) {
      unique = match.groups.base + index++;
    }
    return unique;
  }
  return { uniqueNodeName };
}
const SEQUENTIAL_BONUS = 60;
const SEPARATOR_BONUS = 30;
const CAMEL_BONUS = 30;
const FIRST_LETTER_BONUS = 15;
const LEADING_LETTER_PENALTY = -20;
const MAX_LEADING_LETTER_PENALTY = -200;
const UNMATCHED_LETTER_PENALTY = -5;
function fuzzyMatchSimple(pattern, target2) {
  let patternIdx = 0;
  let strIdx = 0;
  while (patternIdx < pattern.length && strIdx < target2.length) {
    const patternChar = pattern.charAt(patternIdx).toLowerCase();
    const targetChar = target2.charAt(strIdx).toLowerCase();
    if (patternChar === targetChar) {
      patternIdx++;
    }
    ++strIdx;
  }
  return pattern.length !== 0 && target2.length !== 0 && patternIdx === pattern.length;
}
function fuzzyMatch(pattern, target2) {
  const recursionCount = 0;
  const recursionLimit = 5;
  const matches = [];
  const maxMatches = 256;
  return fuzzyMatchRecursive(
    pattern,
    target2,
    0,
    0,
    null,
    matches,
    maxMatches,
    0,
    recursionCount,
    recursionLimit
  );
}
function fuzzyMatchRecursive(pattern, target2, patternCurIndex, targetCurrIndex, targetMatches, matches, maxMatches, nextMatch, recursionCount, recursionLimit) {
  let outScore = 0;
  if (++recursionCount >= recursionLimit) {
    return { matched: false, outScore };
  }
  if (patternCurIndex === pattern.length || targetCurrIndex === target2.length) {
    return { matched: false, outScore };
  }
  let recursiveMatch = false;
  let bestRecursiveMatches = [];
  let bestRecursiveScore = 0;
  let firstMatch = true;
  while (patternCurIndex < pattern.length && targetCurrIndex < target2.length) {
    if (pattern[patternCurIndex].toLowerCase() === target2[targetCurrIndex].toLowerCase()) {
      if (nextMatch >= maxMatches) {
        return { matched: false, outScore };
      }
      if (firstMatch && targetMatches) {
        matches = [...targetMatches];
        firstMatch = false;
      }
      const recursiveMatches = [];
      const recursiveResult = fuzzyMatchRecursive(
        pattern,
        target2,
        patternCurIndex,
        targetCurrIndex + 1,
        matches,
        recursiveMatches,
        maxMatches,
        nextMatch,
        recursionCount,
        recursionLimit
      );
      const recursiveScore = recursiveResult.outScore;
      if (recursiveResult.matched) {
        if (!recursiveMatch || recursiveScore > bestRecursiveScore) {
          bestRecursiveMatches = [...recursiveMatches];
          bestRecursiveScore = recursiveScore;
        }
        recursiveMatch = true;
      }
      matches[nextMatch++] = targetCurrIndex;
      ++patternCurIndex;
    }
    ++targetCurrIndex;
  }
  const matched = patternCurIndex === pattern.length;
  if (matched) {
    outScore = 100;
    if (!target2.toLowerCase().startsWith("n8n")) {
      let penalty = LEADING_LETTER_PENALTY * matches[0];
      penalty = penalty < MAX_LEADING_LETTER_PENALTY ? MAX_LEADING_LETTER_PENALTY : penalty;
      outScore += penalty;
    }
    const unmatched = target2.length - nextMatch;
    outScore += UNMATCHED_LETTER_PENALTY * unmatched;
    for (let i = 0; i < nextMatch; i++) {
      const currIdx = matches[i];
      if (i > 0) {
        const prevIdx = matches[i - 1];
        if (currIdx === prevIdx + 1) {
          outScore += SEQUENTIAL_BONUS;
        }
      }
      if (currIdx > 0) {
        const neighbor = target2[currIdx - 1];
        const curr = target2[currIdx];
        if (neighbor !== neighbor.toUpperCase() && curr !== curr.toLowerCase()) {
          outScore += CAMEL_BONUS;
        }
        const isNeighbourSeparator = neighbor === "_" || neighbor === " ";
        if (isNeighbourSeparator) {
          outScore += SEPARATOR_BONUS;
        }
      } else {
        outScore += FIRST_LETTER_BONUS;
      }
    }
    if (recursiveMatch && (!matched || bestRecursiveScore > outScore)) {
      matches = [...bestRecursiveMatches];
      outScore = bestRecursiveScore;
      return { matched: true, outScore };
    } else if (matched) {
      return { matched: true, outScore };
    } else {
      return { matched: false, outScore };
    }
  }
  return { matched: false, outScore };
}
function getValue(obj, prop) {
  if (obj.hasOwnProperty(prop)) {
    return obj[prop];
  }
  const segments = prop.split(".");
  let result = obj;
  let i = 0;
  while (result && i < segments.length) {
    const key = segments[i];
    result = result[key];
    i++;
  }
  return result;
}
function sublimeSearch(filter2, data, keys) {
  const results = data.reduce((accu, item) => {
    let values = [];
    keys.forEach(({ key, weight }) => {
      const value = getValue(item, key);
      if (Array.isArray(value)) {
        values = values.concat(value.map((v) => ({ value: v, weight })));
      } else if (typeof value === "string") {
        values.push({
          value,
          weight
        });
      }
    });
    const itemMatch = values.reduce(
      (accu2, { value, weight }) => {
        if (!fuzzyMatchSimple(filter2, value)) {
          return accu2;
        }
        const match = fuzzyMatch(filter2, value);
        match.outScore *= weight;
        const { matched, outScore } = match;
        if (!accu2 && matched) {
          return match;
        }
        if (matched && accu2 && outScore > accu2.outScore) {
          return match;
        }
        return accu2;
      },
      null
    );
    if (itemMatch) {
      accu.push({
        score: itemMatch.outScore,
        item
      });
    }
    return accu;
  }, []);
  results.sort((a, b) => {
    return b.score - a.score;
  });
  return results;
}
const SPLIT_LOWER_UPPER_RE = new RegExp("([\\p{Ll}\\d])(\\p{Lu})", "gu");
const SPLIT_UPPER_UPPER_RE = new RegExp("(\\p{Lu})([\\p{Lu}][\\p{Ll}])", "gu");
const SPLIT_SEPARATE_NUMBER_RE = new RegExp("(\\d)\\p{Ll}|(\\p{L})\\d", "u");
const DEFAULT_STRIP_REGEXP = /[^\p{L}\d]+/giu;
const SPLIT_REPLACE_VALUE = "$1\0$2";
const DEFAULT_PREFIX_SUFFIX_CHARACTERS = "";
function split(value) {
  let result = value.trim();
  result = result.replace(SPLIT_LOWER_UPPER_RE, SPLIT_REPLACE_VALUE).replace(SPLIT_UPPER_UPPER_RE, SPLIT_REPLACE_VALUE);
  result = result.replace(DEFAULT_STRIP_REGEXP, "\0");
  let start2 = 0;
  let end = result.length;
  while (result.charAt(start2) === "\0")
    start2++;
  if (start2 === end)
    return [];
  while (result.charAt(end - 1) === "\0")
    end--;
  return result.slice(start2, end).split(/\0/g);
}
function splitSeparateNumbers(value) {
  const words = split(value);
  for (let i = 0; i < words.length; i++) {
    const word = words[i];
    const match = SPLIT_SEPARATE_NUMBER_RE.exec(word);
    if (match) {
      const offset = match.index + (match[1] ?? match[2]).length;
      words.splice(i, 1, word.slice(0, offset), word.slice(offset));
    }
  }
  return words;
}
function noCase(input, options) {
  const [prefix, words, suffix] = splitPrefixSuffix(input, options);
  return prefix + words.map(lowerFactory(options == null ? void 0 : options.locale)).join(" ") + suffix;
}
function lowerFactory(locale) {
  return locale === false ? (input) => input.toLowerCase() : (input) => input.toLocaleLowerCase(locale);
}
function splitPrefixSuffix(input, options = {}) {
  const splitFn = options.split ?? (options.separateNumbers ? splitSeparateNumbers : split);
  const prefixCharacters = options.prefixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  const suffixCharacters = options.suffixCharacters ?? DEFAULT_PREFIX_SUFFIX_CHARACTERS;
  let prefixIndex = 0;
  let suffixIndex = input.length;
  while (prefixIndex < input.length) {
    const char = input.charAt(prefixIndex);
    if (!prefixCharacters.includes(char))
      break;
    prefixIndex++;
  }
  while (suffixIndex > prefixIndex) {
    const index = suffixIndex - 1;
    const char = input.charAt(index);
    if (!suffixCharacters.includes(char))
      break;
    suffixIndex = index;
  }
  return [
    input.slice(0, prefixIndex),
    splitFn(input.slice(prefixIndex, suffixIndex)),
    input.slice(suffixIndex)
  ];
}
function transformNodeType(node2, subcategory, type = "node") {
  var _a, _b, _c;
  const createElement = {
    uuid: v4(),
    key: node2.name,
    subcategory: subcategory ?? ((_c = (_b = (_a = node2.codex) == null ? void 0 : _a.subcategories) == null ? void 0 : _b[CORE_NODES_CATEGORY]) == null ? void 0 : _c[0]) ?? DEFAULT_SUBCATEGORY,
    properties: {
      ...node2
    },
    type
  };
  return type === "action" ? createElement : createElement;
}
function subcategorizeItems(items) {
  const WHITE_LISTED_SUBCATEGORIES = [CORE_NODES_CATEGORY, AI_SUBCATEGORY];
  return items.reduce((acc, item) => {
    let subcategories = [DEFAULT_SUBCATEGORY];
    WHITE_LISTED_SUBCATEGORIES.forEach((category) => {
      var _a, _b, _c, _d;
      if ((_b = (_a = item.codex) == null ? void 0 : _a.categories) == null ? void 0 : _b.includes(category)) {
        subcategories = ((_d = (_c = item.codex) == null ? void 0 : _c.subcategories) == null ? void 0 : _d[category]) ?? [];
      }
    });
    subcategories.forEach((subcategory) => {
      if (!acc[subcategory]) {
        acc[subcategory] = [];
      }
      acc[subcategory].push(transformNodeType(item, subcategory));
    });
    return acc;
  }, {});
}
function sortNodeCreateElements(nodes) {
  return nodes.sort((a, b) => {
    var _a, _b, _c, _d;
    if (a.type !== "node" || b.type !== "node") return 0;
    const displayNameA = ((_b = (_a = a.properties) == null ? void 0 : _a.displayName) == null ? void 0 : _b.toLowerCase()) || a.key;
    const displayNameB = ((_d = (_c = b.properties) == null ? void 0 : _c.displayName) == null ? void 0 : _d.toLowerCase()) || b.key;
    return displayNameA.localeCompare(displayNameB, void 0, { sensitivity: "base" });
  });
}
function searchNodes(searchFilter, items) {
  const askAiEnabled = useSettingsStore().isAskAiEnabled;
  if (!askAiEnabled) {
    items = items.filter((item) => item.key !== AI_TRANSFORM_NODE_TYPE);
  }
  const trimmedFilter = searchFilter.toLowerCase().replace("trigger", "").trimEnd();
  const result = (sublimeSearch(trimmedFilter, items, [
    { key: "properties.displayName", weight: 1.3 },
    { key: "properties.codex.alias", weight: 1 }
  ]) || []).map(({ item }) => item);
  return result;
}
function flattenCreateElements(items) {
  return items.map((item) => item.type === "section" ? item.children : item).flat();
}
function isAINode(node2) {
  var _a, _b, _c, _d, _e;
  const isNode2 = node2.type === "node";
  if (!isNode2) return false;
  if ((_b = (_a = node2.properties.codex) == null ? void 0 : _a.categories) == null ? void 0 : _b.includes(AI_SUBCATEGORY)) {
    const isAgentSubcategory = (_e = (_d = (_c = node2.properties.codex) == null ? void 0 : _c.subcategories) == null ? void 0 : _d[AI_SUBCATEGORY]) == null ? void 0 : _e.includes(AI_CATEGORY_AGENTS);
    return !isAgentSubcategory;
  }
  return false;
}
function groupItemsInSections(items, sections, sortAlphabetically = true) {
  const filteredSections = sections.filter(
    (section) => typeof section === "object"
  );
  const itemsBySection = (items2) => items2.reduce((acc, item) => {
    const section = filteredSections.find((s) => s.items.includes(item.key));
    const key = (section == null ? void 0 : section.key) ?? "other";
    if (key) {
      acc[key] = [...acc[key] ?? [], item];
    }
    return acc;
  }, {});
  const mapNewSections = (newSections, children2) => newSections.map(
    (section) => ({
      type: "section",
      key: section.key,
      title: section.title,
      children: sortAlphabetically ? sortNodeCreateElements(children2[section.key] ?? []) : children2[section.key] ?? []
    })
  );
  const nonAINodes = items.filter((item) => !isAINode(item));
  const AINodes = items.filter((item) => isAINode(item));
  const nonAINodesBySection = itemsBySection(nonAINodes);
  const nonAINodesSections = mapNewSections(filteredSections, nonAINodesBySection);
  const AINodesBySection = itemsBySection(AINodes);
  const AINodesSections = mapNewSections(sortBy(filteredSections, ["title"]), AINodesBySection);
  const result = [...nonAINodesSections, ...AINodesSections].concat({
    type: "section",
    key: "other",
    title: i18n.baseText("nodeCreator.sectionNames.other"),
    children: sortNodeCreateElements(nonAINodesBySection.other ?? [])
  }).filter((section) => section.type !== "section" || section.children.length > 0);
  result.sort((a, b) => {
    if (a.key.toLowerCase().includes("recommended")) return -1;
    if (b.key.toLowerCase().includes("recommended")) return 1;
    return 0;
  });
  if (result.length <= 1) {
    return items;
  }
  return result;
}
const formatTriggerActionName = (actionPropertyName) => {
  let name = actionPropertyName;
  if (actionPropertyName.includes(".")) {
    name = actionPropertyName.split(".").join(" ");
  }
  return noCase(name);
};
function getAiNodesBySubcategory(nodes, subcategory) {
  return nodes.filter(
    (node2) => {
      var _a, _b, _c;
      return !node2.hidden && ((_c = (_b = (_a = node2.codex) == null ? void 0 : _a.subcategories) == null ? void 0 : _b[AI_SUBCATEGORY]) == null ? void 0 : _c.includes(subcategory));
    }
  ).map((node2) => ({
    key: node2.name,
    type: "node",
    properties: {
      group: [],
      name: node2.name,
      displayName: node2.displayName,
      title: node2.displayName,
      description: node2.description,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      icon: node2.icon,
      iconUrl: node2.iconUrl
    }
  })).sort((a, b) => a.properties.displayName.localeCompare(b.properties.displayName));
}
function AIView(_nodes) {
  const i18n2 = useI18n();
  const nodeTypesStore = useNodeTypesStore();
  const templatesStore = useTemplatesStore();
  const chainNodes = getAiNodesBySubcategory(nodeTypesStore.allLatestNodeTypes, AI_CATEGORY_CHAINS);
  const agentNodes = getAiNodesBySubcategory(nodeTypesStore.allLatestNodeTypes, AI_CATEGORY_AGENTS);
  return {
    value: AI_NODE_CREATOR_VIEW,
    title: i18n2.baseText("nodeCreator.aiPanel.aiNodes"),
    subtitle: i18n2.baseText("nodeCreator.aiPanel.selectAiNode"),
    items: [
      {
        key: "ai_templates_root",
        type: "link",
        properties: {
          title: i18n2.baseText("nodeCreator.aiPanel.linkItem.title"),
          icon: "box-open",
          description: i18n2.baseText("nodeCreator.aiPanel.linkItem.description"),
          name: "ai_templates_root",
          url: templatesStore.getWebsiteCategoryURL(void 0, "AdvancedAI"),
          tag: {
            type: "info",
            text: i18n2.baseText("nodeCreator.triggerHelperPanel.manualTriggerTag")
          }
        }
      },
      ...agentNodes,
      ...chainNodes,
      {
        key: AI_OTHERS_NODE_CREATOR_VIEW,
        type: "view",
        properties: {
          title: i18n2.baseText("nodeCreator.aiPanel.aiOtherNodes"),
          icon: "robot",
          description: i18n2.baseText("nodeCreator.aiPanel.aiOtherNodesDescription")
        }
      }
    ]
  };
}
function AINodesView(_nodes) {
  const i18n2 = useI18n();
  function getAISubcategoryProperties(nodeConnectionType) {
    return {
      connectionType: nodeConnectionType,
      iconProps: {
        color: `var(--node-type-${nodeConnectionType}-color)`
      },
      panelClass: `nodes-list-panel-${nodeConnectionType}`
    };
  }
  function getSubcategoryInfo(subcategory) {
    const localeKey = `nodeCreator.subcategoryInfos.${camelCase(subcategory)}`;
    const info = i18n2.baseText(localeKey);
    if (info === localeKey) return void 0;
    return info;
  }
  return {
    value: AI_OTHERS_NODE_CREATOR_VIEW,
    title: i18n2.baseText("nodeCreator.aiPanel.aiOtherNodes"),
    subtitle: i18n2.baseText("nodeCreator.aiPanel.selectAiNode"),
    items: [
      {
        key: AI_CATEGORY_DOCUMENT_LOADERS,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_DOCUMENT_LOADERS,
          info: getSubcategoryInfo(AI_CATEGORY_DOCUMENT_LOADERS),
          icon: "file-import",
          ...getAISubcategoryProperties(NodeConnectionType.AiDocument)
        }
      },
      {
        key: AI_CATEGORY_LANGUAGE_MODELS,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_LANGUAGE_MODELS,
          info: getSubcategoryInfo(AI_CATEGORY_LANGUAGE_MODELS),
          icon: "language",
          ...getAISubcategoryProperties(NodeConnectionType.AiLanguageModel)
        }
      },
      {
        key: AI_CATEGORY_MEMORY,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_MEMORY,
          info: getSubcategoryInfo(AI_CATEGORY_MEMORY),
          icon: "brain",
          ...getAISubcategoryProperties(NodeConnectionType.AiMemory)
        }
      },
      {
        key: AI_CATEGORY_OUTPUTPARSER,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_OUTPUTPARSER,
          info: getSubcategoryInfo(AI_CATEGORY_OUTPUTPARSER),
          icon: "list",
          ...getAISubcategoryProperties(NodeConnectionType.AiOutputParser)
        }
      },
      {
        key: AI_CATEGORY_RETRIEVERS,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_RETRIEVERS,
          info: getSubcategoryInfo(AI_CATEGORY_RETRIEVERS),
          icon: "search",
          ...getAISubcategoryProperties(NodeConnectionType.AiRetriever)
        }
      },
      {
        key: AI_CATEGORY_TEXT_SPLITTERS,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_TEXT_SPLITTERS,
          info: getSubcategoryInfo(AI_CATEGORY_TEXT_SPLITTERS),
          icon: "grip-lines-vertical",
          ...getAISubcategoryProperties(NodeConnectionType.AiTextSplitter)
        }
      },
      {
        type: "subcategory",
        key: AI_CATEGORY_TOOLS,
        category: CORE_NODES_CATEGORY,
        properties: {
          title: AI_CATEGORY_TOOLS,
          info: getSubcategoryInfo(AI_CATEGORY_TOOLS),
          icon: "tools",
          ...getAISubcategoryProperties(NodeConnectionType.AiTool),
          sections: [
            {
              key: "popular",
              title: i18n2.baseText("nodeCreator.sectionNames.popular"),
              items: [AI_WORKFLOW_TOOL_LANGCHAIN_NODE_TYPE, AI_CODE_TOOL_LANGCHAIN_NODE_TYPE]
            }
          ]
        }
      },
      {
        key: AI_CATEGORY_EMBEDDING,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_EMBEDDING,
          info: getSubcategoryInfo(AI_CATEGORY_EMBEDDING),
          icon: "vector-square",
          ...getAISubcategoryProperties(NodeConnectionType.AiEmbedding)
        }
      },
      {
        key: AI_CATEGORY_VECTOR_STORES,
        type: "subcategory",
        properties: {
          title: AI_CATEGORY_VECTOR_STORES,
          info: getSubcategoryInfo(AI_CATEGORY_VECTOR_STORES),
          icon: "project-diagram",
          ...getAISubcategoryProperties(NodeConnectionType.AiVectorStore)
        }
      },
      {
        key: AI_UNCATEGORIZED_CATEGORY,
        type: "subcategory",
        properties: {
          title: AI_UNCATEGORIZED_CATEGORY,
          icon: "code"
        }
      }
    ]
  };
}
function TriggerView() {
  const i18n2 = useI18n();
  const view = {
    value: TRIGGER_NODE_CREATOR_VIEW,
    title: i18n2.baseText("nodeCreator.triggerHelperPanel.selectATrigger"),
    subtitle: i18n2.baseText("nodeCreator.triggerHelperPanel.selectATriggerDescription"),
    items: [
      {
        key: MANUAL_TRIGGER_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: MANUAL_TRIGGER_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.manualTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.manualTriggerDescription"),
          icon: "fa:mouse-pointer"
        }
      },
      {
        key: DEFAULT_SUBCATEGORY,
        type: "subcategory",
        properties: {
          forceIncludeNodes: [WEBHOOK_NODE_TYPE, EMAIL_IMAP_NODE_TYPE],
          title: "App Trigger Nodes",
          icon: "satellite-dish"
        }
      },
      {
        key: SCHEDULE_TRIGGER_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: SCHEDULE_TRIGGER_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.scheduleTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.scheduleTriggerDescription"),
          icon: "fa:clock"
        }
      },
      {
        key: WEBHOOK_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: WEBHOOK_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.webhookTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.webhookTriggerDescription"),
          iconData: {
            type: "file",
            icon: "webhook",
            fileBuffer: "/static/webhook-icon.svg"
          }
        }
      },
      {
        key: FORM_TRIGGER_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: FORM_TRIGGER_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.formTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.formTriggerDescription"),
          iconData: {
            type: "file",
            icon: "form",
            fileBuffer: "/static/form-grey.svg"
          }
        }
      },
      {
        key: EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: EXECUTE_WORKFLOW_TRIGGER_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.workflowTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.workflowTriggerDescription"),
          icon: "fa:sign-out-alt"
        }
      },
      {
        key: MANUAL_CHAT_TRIGGER_NODE_TYPE,
        type: "node",
        category: [CORE_NODES_CATEGORY],
        properties: {
          group: [],
          name: MANUAL_CHAT_TRIGGER_NODE_TYPE,
          displayName: i18n2.baseText("nodeCreator.triggerHelperPanel.manualChatTriggerDisplayName"),
          description: i18n2.baseText("nodeCreator.triggerHelperPanel.manualChatTriggerDescription"),
          icon: "fa:comments"
        }
      },
      {
        type: "subcategory",
        key: OTHER_TRIGGER_NODES_SUBCATEGORY,
        category: CORE_NODES_CATEGORY,
        properties: {
          title: OTHER_TRIGGER_NODES_SUBCATEGORY,
          icon: "folder-open"
        }
      }
    ]
  };
  return view;
}
function RegularView(nodes) {
  const i18n2 = useI18n();
  const popularItemsSubcategory = [
    SET_NODE_TYPE,
    CODE_NODE_TYPE,
    DATETIME_NODE_TYPE,
    AI_TRANSFORM_NODE_TYPE
  ];
  const view = {
    value: REGULAR_NODE_CREATOR_VIEW,
    title: i18n2.baseText("nodeCreator.triggerHelperPanel.whatHappensNext"),
    items: [
      {
        key: DEFAULT_SUBCATEGORY,
        type: "subcategory",
        properties: {
          title: "App Regular Nodes",
          icon: "globe",
          forceIncludeNodes: [RSS_READ_NODE_TYPE, EMAIL_SEND_NODE_TYPE]
        }
      },
      {
        type: "subcategory",
        key: TRANSFORM_DATA_SUBCATEGORY,
        category: CORE_NODES_CATEGORY,
        properties: {
          title: TRANSFORM_DATA_SUBCATEGORY,
          icon: "pen",
          sections: [
            {
              key: "popular",
              title: i18n2.baseText("nodeCreator.sectionNames.popular"),
              items: popularItemsSubcategory
            },
            {
              key: "addOrRemove",
              title: i18n2.baseText("nodeCreator.sectionNames.transform.addOrRemove"),
              items: [
                FILTER_NODE_TYPE,
                REMOVE_DUPLICATES_NODE_TYPE,
                SPLIT_OUT_NODE_TYPE,
                LIMIT_NODE_TYPE
              ]
            },
            {
              key: "combine",
              title: i18n2.baseText("nodeCreator.sectionNames.transform.combine"),
              items: [SUMMARIZE_NODE_TYPE, AGGREGATE_NODE_TYPE, MERGE_NODE_TYPE]
            },
            {
              key: "convert",
              title: i18n2.baseText("nodeCreator.sectionNames.transform.convert"),
              items: [
                HTML_NODE_TYPE,
                MARKDOWN_NODE_TYPE,
                XML_NODE_TYPE,
                CRYPTO_NODE_TYPE,
                EXTRACT_FROM_FILE_NODE_TYPE,
                CONVERT_TO_FILE_NODE_TYPE,
                COMPRESSION_NODE_TYPE,
                EDIT_IMAGE_NODE_TYPE
              ]
            }
          ]
        }
      },
      {
        type: "subcategory",
        key: FLOWS_CONTROL_SUBCATEGORY,
        category: CORE_NODES_CATEGORY,
        properties: {
          title: FLOWS_CONTROL_SUBCATEGORY,
          icon: "code-branch",
          sections: [
            {
              key: "popular",
              title: i18n2.baseText("nodeCreator.sectionNames.popular"),
              items: [FILTER_NODE_TYPE, IF_NODE_TYPE, SPLIT_IN_BATCHES_NODE_TYPE, MERGE_NODE_TYPE]
            }
          ]
        }
      },
      {
        type: "subcategory",
        key: HELPERS_SUBCATEGORY,
        category: CORE_NODES_CATEGORY,
        properties: {
          title: HELPERS_SUBCATEGORY,
          icon: "toolbox",
          sections: [
            {
              key: "popular",
              title: i18n2.baseText("nodeCreator.sectionNames.popular"),
              items: [HTTP_REQUEST_NODE_TYPE, WEBHOOK_NODE_TYPE, CODE_NODE_TYPE]
            }
          ]
        }
      }
    ]
  };
  const hasAINodes = (nodes ?? []).some((node2) => {
    var _a, _b;
    return (_b = (_a = node2.codex) == null ? void 0 : _a.categories) == null ? void 0 : _b.includes(AI_SUBCATEGORY);
  });
  if (hasAINodes)
    view.items.push({
      key: AI_NODE_CREATOR_VIEW,
      type: "view",
      properties: {
        title: i18n2.baseText("nodeCreator.aiPanel.langchainAiNodes"),
        icon: "robot",
        description: i18n2.baseText("nodeCreator.aiPanel.nodesForAi"),
        tag: {
          type: "success",
          text: i18n2.baseText("nodeCreator.aiPanel.newTag")
        },
        borderless: true
      }
    });
  view.items.push({
    key: TRIGGER_NODE_CREATOR_VIEW,
    type: "view",
    properties: {
      title: i18n2.baseText("nodeCreator.triggerHelperPanel.addAnotherTrigger"),
      icon: "bolt",
      description: i18n2.baseText("nodeCreator.triggerHelperPanel.addAnotherTriggerDescription")
    }
  });
  return view;
}
const KEYBOARD_ID_ATTR = "data-keyboard-nav-id";
const WATCHED_KEYS = [
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Enter",
  "Escape",
  "Tab"
];
const useKeyboardNavigation = defineStore("nodeCreatorKeyboardNavigation", () => {
  const selectableItems = ref([]);
  const activeItemId = ref(null);
  const keysHooks = ref({});
  function getItemType(element) {
    return element == null ? void 0 : element.getAttribute("data-keyboard-nav-type");
  }
  function getElementId(element) {
    return (element == null ? void 0 : element.getAttribute(KEYBOARD_ID_ATTR)) || void 0;
  }
  async function refreshSelectableItems() {
    return await new Promise((resolve) => {
      cleanupSelectableItems();
      setTimeout(() => {
        selectableItems.value = Array.from(
          document.querySelectorAll("[data-keyboard-nav-type]")
        ).map((el) => new WeakRef(el));
        resolve();
      }, 0);
    });
  }
  function executeKeyHooks(keyboardKey, activeItem) {
    const flatHooks = Object.values(keysHooks.value);
    const hooks = flatHooks.filter((hook) => hook.keyboardKeys.includes(keyboardKey));
    hooks.forEach((hook) => {
      if (!activeItemId.value) return;
      const conditionPassed = hook.condition === void 0 || hook.condition(getItemType(activeItem) || "", activeItemId.value);
      if (conditionPassed && activeItemId.value) {
        hook.handler(activeItemId.value, keyboardKey);
      }
    });
  }
  async function onKeyDown2(e) {
    var _a, _b, _c;
    const pressedKey = e.key;
    if (!WATCHED_KEYS.includes(pressedKey)) return;
    e.preventDefault();
    e.stopPropagation();
    await refreshSelectableItems();
    const activeItemIndex = selectableItems.value.findIndex(
      (item) => getElementId(item == null ? void 0 : item.deref()) === activeItemId.value
    );
    const activeItem = (_a = selectableItems.value[activeItemIndex]) == null ? void 0 : _a.deref();
    const isArrowDown = pressedKey === "ArrowDown";
    const isArrowUp = pressedKey === "ArrowUp";
    if (!activeItem) return;
    if (isArrowDown) {
      const nextItemIndex = activeItemIndex < selectableItems.value.length - 1 ? activeItemIndex + 1 : 0;
      setActiveItem((_b = selectableItems.value[nextItemIndex]) == null ? void 0 : _b.deref());
    }
    if (isArrowUp) {
      const previousIndex = activeItemIndex > 0 ? activeItemIndex - 1 : selectableItems.value.length - 1;
      setActiveItem((_c = selectableItems.value[previousIndex]) == null ? void 0 : _c.deref());
    }
    executeKeyHooks(pressedKey, activeItem);
  }
  function setActiveItemId(id2) {
    activeItemId.value = id2;
  }
  function setActiveItem(item) {
    const itemId = getElementId(item);
    if (!itemId) return;
    setActiveItemId(itemId);
    if (item == null ? void 0 : item.scrollIntoView) {
      item == null ? void 0 : item.scrollIntoView({ block: "center" });
    }
  }
  async function setActiveItemIndex(index) {
    var _a;
    await refreshSelectableItems();
    setActiveItem((_a = selectableItems.value[index]) == null ? void 0 : _a.deref());
  }
  function attachKeydownEvent() {
    document.addEventListener("keydown", onKeyDown2, { capture: true });
  }
  function detachKeydownEvent() {
    cleanupSelectableItems();
    document.removeEventListener("keydown", onKeyDown2, { capture: true });
  }
  function registerKeyHook(name, hook) {
    hook.keyboardKeys.forEach((keyboardKey) => {
      if (WATCHED_KEYS.includes(keyboardKey)) {
        keysHooks.value = { ...keysHooks.value, [name]: hook };
      } else {
        throw new Error(`Key ${keyboardKey} is not supported`);
      }
    });
  }
  function cleanupSelectableItems() {
    selectableItems.value = [];
  }
  function getActiveItemIndex() {
    return selectableItems.value.findIndex(
      (item) => getElementId(item == null ? void 0 : item.deref()) === activeItemId.value
    );
  }
  return {
    activeItemId,
    attachKeydownEvent,
    refreshSelectableItems,
    detachKeydownEvent,
    registerKeyHook,
    getActiveItemIndex,
    setActiveItemId,
    setActiveItemIndex
  };
});
const useViewStacks = defineStore("nodeCreatorViewStacks", () => {
  const nodeCreatorStore = useNodeCreatorStore();
  const { getActiveItemIndex } = useKeyboardNavigation();
  const i18n2 = useI18n();
  const settingsStore = useSettingsStore();
  const viewStacks = ref([]);
  const activeStackItems = computed(() => {
    const stack = getLastActiveStack();
    if (!(stack == null ? void 0 : stack.baselineItems)) {
      return stack.items ? extendItemsWithUUID(stack.items) : [];
    }
    if (stack.search && searchBaseItems.value) {
      let searchBase = searchBaseItems.value;
      const canvasHasAINodes = useCanvasStore().aiNodes.length > 0;
      if (searchBaseItems.value.length === 0) {
        searchBase = flattenCreateElements(stack.baselineItems ?? []);
      }
      if (
        // Filter-out AI sub-nodes if canvas has no AI nodes and the root view is not AI
        !(isAiRootView(stack) || canvasHasAINodes) || // or if the source is a plus endpoint or a node connection drop and the root view is not AI subcategory
        ["plus_endpoint", "node_connection_drop"].includes(nodeCreatorStore.openSource) && !isAiSubcategoryView(stack)
      ) {
        searchBase = filterOutAiNodes(searchBase);
      }
      const searchResults = extendItemsWithUUID(searchNodes(stack.search || "", searchBase));
      const groupedNodes = groupIfAiNodes(searchResults, false) ?? searchResults;
      stack.activeIndex = groupedNodes.some((node2) => node2.type === "section") ? 1 : 0;
      return groupedNodes;
    }
    return extendItemsWithUUID(groupIfAiNodes(stack.baselineItems, true));
  });
  const activeViewStack = computed(() => {
    const stack = getLastActiveStack();
    if (!stack) return {};
    const flatBaselineItems = flattenCreateElements(stack.baselineItems ?? []);
    return {
      ...stack,
      items: activeStackItems.value,
      hasSearch: flatBaselineItems.length > 8 || (stack == null ? void 0 : stack.hasSearch)
    };
  });
  const activeViewStackMode = computed(
    () => activeViewStack.value.mode || TRIGGER_NODE_CREATOR_VIEW
  );
  const searchBaseItems = computed(() => {
    const stack = getLastActiveStack();
    if (!(stack == null ? void 0 : stack.searchItems)) return [];
    return stack.searchItems.map((item) => transformNodeType(item, stack.subcategory));
  });
  function isAiSubcategoryView(stack) {
    return stack.rootView === AI_OTHERS_NODE_CREATOR_VIEW;
  }
  function getLastActiveStack() {
    return viewStacks.value[viewStacks.value.length - 1];
  }
  const globalSearchItemsDiff = computed(() => {
    const stack = getLastActiveStack();
    if (!(stack == null ? void 0 : stack.search) || isAiSubcategoryView(stack)) return [];
    const allNodes = nodeCreatorStore.mergedNodes.map((item) => transformNodeType(item));
    const filteredNodes = isAiRootView(stack) ? allNodes : filterOutAiNodes(allNodes);
    let globalSearchResult = extendItemsWithUUID(
      searchNodes(stack.search || "", filteredNodes)
    );
    if (isAiRootView(stack)) {
      globalSearchResult = groupIfAiNodes(globalSearchResult);
    }
    const filteredItems = globalSearchResult.filter((item) => {
      return !activeStackItems.value.find((activeItem) => {
        if (activeItem.type === "section") {
          const matchingSectionItem = activeItem.children.some(
            (sectionItem) => sectionItem.key === item.key
          );
          return matchingSectionItem;
        }
        return activeItem.key === item.key;
      });
    });
    const filteredSections = filteredItems.filter((item) => {
      if (item.type === "section") {
        const hasVisibleChildren = item.children.some(
          (child) => activeStackItems.value.some((filteredItem) => filteredItem.key === child.key)
        );
        return hasVisibleChildren;
      }
      return true;
    });
    return filteredSections;
  });
  const itemsBySubcategory = computed(() => subcategorizeItems(nodeCreatorStore.mergedNodes));
  function isAiRootView(stack) {
    return stack.rootView === AI_NODE_CREATOR_VIEW;
  }
  function filterAiRootNodes(items) {
    return items.filter((node2) => {
      var _a, _b;
      if (node2.type !== "node") return false;
      return (_b = (_a = node2.properties.codex) == null ? void 0 : _a.subcategories) == null ? void 0 : _b[AI_SUBCATEGORY].includes(
        AI_CATEGORY_ROOT_NODES
      );
    });
  }
  function groupIfAiNodes(items, sortAlphabetically = true) {
    const aiNodes = items.filter((node2) => isAINode(node2));
    const canvasHasAINodes = useCanvasStore().aiNodes.length > 0;
    if (aiNodes.length > 0 && (canvasHasAINodes || isAiRootView(getLastActiveStack()))) {
      const sectionsMap = /* @__PURE__ */ new Map();
      const aiRootNodes = filterAiRootNodes(aiNodes);
      const aiSubNodes = difference(aiNodes, aiRootNodes);
      aiSubNodes.forEach((node2) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const section = (_c = (_b = (_a = node2.properties.codex) == null ? void 0 : _a.subcategories) == null ? void 0 : _b[AI_SUBCATEGORY]) == null ? void 0 : _c[0];
        if (section) {
          const subSection = (_f = (_e = (_d = node2.properties.codex) == null ? void 0 : _d.subcategories) == null ? void 0 : _e[section]) == null ? void 0 : _f[0];
          const sectionKey = subSection ?? section;
          const currentItems = ((_g = sectionsMap.get(sectionKey)) == null ? void 0 : _g.items) ?? [];
          const isSubnodesSection = !((_i = (_h = node2.properties.codex) == null ? void 0 : _h.subcategories) == null ? void 0 : _i[AI_SUBCATEGORY].includes(
            AI_CATEGORY_ROOT_NODES
          ));
          let title2 = section;
          if (isSubnodesSection) {
            title2 = `${section} (${i18n2.baseText("nodeCreator.subnodes")})`;
          }
          if (subSection) {
            title2 = subSection;
          }
          sectionsMap.set(sectionKey, {
            key: sectionKey,
            title: title2,
            items: [...currentItems, node2.key]
          });
        }
      });
      const nonAiNodes = difference(items, aiNodes);
      const sections = Array.from(sectionsMap.values());
      return [
        ...nonAiNodes,
        ...aiRootNodes,
        ...groupItemsInSections(aiSubNodes, sections, sortAlphabetically)
      ];
    }
    return items;
  }
  function filterOutAiNodes(items) {
    const filteredSearchBase = items.filter((item) => {
      var _a, _b, _c, _d, _e;
      if (item.type === "node") {
        const isAICategory = ((_b = (_a = item.properties.codex) == null ? void 0 : _a.categories) == null ? void 0 : _b.includes(AI_SUBCATEGORY)) === true;
        if (!isAICategory) return true;
        const isRootNodeSubcategory = (_e = (_d = (_c = item.properties.codex) == null ? void 0 : _c.subcategories) == null ? void 0 : _d[AI_SUBCATEGORY]) == null ? void 0 : _e.includes(AI_CATEGORY_ROOT_NODES);
        return isRootNodeSubcategory;
      }
      return true;
    });
    return filteredSearchBase;
  }
  async function gotoCompatibleConnectionView(connectionType2, isOutput, filter2) {
    var _a, _b;
    let nodesByConnectionType;
    let relatedAIView;
    if (isOutput === true) {
      nodesByConnectionType = useNodeTypesStore().visibleNodeTypesByInputConnectionTypeNames;
      relatedAIView = {
        properties: {
          title: i18n2.baseText("nodeCreator.aiPanel.aiNodes"),
          icon: "robot"
        }
      };
    } else {
      nodesByConnectionType = useNodeTypesStore().visibleNodeTypesByOutputConnectionTypeNames;
      relatedAIView = AINodesView().items.find(
        (item) => item.properties.connectionType === connectionType2
      );
    }
    let extendedInfo = {};
    if (!((_a = filter2 == null ? void 0 : filter2.nodes) == null ? void 0 : _a.length) && (relatedAIView == null ? void 0 : relatedAIView.properties.info)) {
      extendedInfo = { info: relatedAIView == null ? void 0 : relatedAIView.properties.info };
    }
    await nextTick();
    pushViewStack({
      title: relatedAIView == null ? void 0 : relatedAIView.properties.title,
      ...extendedInfo,
      rootView: AI_OTHERS_NODE_CREATOR_VIEW,
      mode: "nodes",
      items: nodeCreatorStore.allNodeCreatorNodes,
      nodeIcon: {
        iconType: "icon",
        icon: relatedAIView == null ? void 0 : relatedAIView.properties.icon,
        color: (_b = relatedAIView == null ? void 0 : relatedAIView.properties.iconProps) == null ? void 0 : _b.color
      },
      panelClass: relatedAIView == null ? void 0 : relatedAIView.properties.panelClass,
      baseFilter: (i) => {
        var _a2;
        if (i.key === AI_CODE_NODE_TYPE) return false;
        const displayNode = nodesByConnectionType[connectionType2].includes(i.key);
        if (displayNode && ((_a2 = filter2 == null ? void 0 : filter2.nodes) == null ? void 0 : _a2.length)) {
          return filter2.nodes.includes(i.key);
        }
        return displayNode;
      },
      itemsMapper(item) {
        return {
          ...item,
          subcategory: connectionType2
        };
      },
      hideActions: true,
      preventBack: true
    });
  }
  function setStackBaselineItems() {
    const stack = getLastActiveStack();
    if (!stack || !activeViewStack.value.uuid) return;
    let stackItems = (stack == null ? void 0 : stack.items) ?? [];
    if (!(stack == null ? void 0 : stack.items)) {
      const subcategory = (stack == null ? void 0 : stack.subcategory) ?? DEFAULT_SUBCATEGORY;
      let itemsInSubcategory = itemsBySubcategory.value[subcategory];
      const isAskAiEnabled = settingsStore.isAskAiEnabled;
      if (!isAskAiEnabled) {
        itemsInSubcategory = itemsInSubcategory.filter(
          (item) => item.key !== AI_TRANSFORM_NODE_TYPE$1
        );
      }
      const sections = stack.sections;
      if (sections) {
        stackItems = groupItemsInSections(itemsInSubcategory, sections);
      } else {
        stackItems = itemsInSubcategory;
      }
    }
    if ((stack.forceIncludeNodes ?? []).length > 0) {
      const matchedNodes = nodeCreatorStore.mergedNodes.filter((item) => {
        var _a;
        return (_a = stack.forceIncludeNodes) == null ? void 0 : _a.includes(item.name);
      }).map((item) => transformNodeType(item, stack.subcategory));
      stackItems.push(...matchedNodes);
    }
    if (stack.baseFilter) {
      stackItems = stackItems.filter(stack.baseFilter);
    }
    if (stack.itemsMapper) {
      stackItems = stackItems.map(stack.itemsMapper);
    }
    if (!stack.items) {
      stackItems = sortNodeCreateElements(stackItems);
    }
    updateCurrentViewStack({ baselineItems: stackItems });
  }
  function extendItemsWithUUID(items) {
    return items.map((item) => ({
      ...item,
      uuid: `${item.key}-${v4()}`
    }));
  }
  function pushViewStack(stack) {
    if (activeViewStack.value.uuid) {
      updateCurrentViewStack({ activeIndex: getActiveItemIndex() });
    }
    const newStackUuid = v4();
    viewStacks.value.push({
      ...stack,
      uuid: newStackUuid,
      transitionDirection: "in",
      activeIndex: 0
    });
    setStackBaselineItems();
  }
  function popViewStack() {
    if (activeViewStack.value.uuid) {
      viewStacks.value.pop();
      updateCurrentViewStack({ transitionDirection: "out" });
    }
  }
  function updateCurrentViewStack(stack) {
    const currentStack = getLastActiveStack();
    const matchedIndex = viewStacks.value.findIndex((s) => s.uuid === currentStack.uuid);
    if (!currentStack) return;
    Object.keys(stack).forEach((key) => {
      const typedKey = key;
      viewStacks.value[matchedIndex] = {
        ...viewStacks.value[matchedIndex],
        [key]: stack[typedKey]
      };
    });
  }
  function resetViewStacks() {
    viewStacks.value = [];
  }
  return {
    viewStacks,
    activeViewStack,
    activeViewStackMode,
    globalSearchItemsDiff,
    isAiSubcategoryView,
    gotoCompatibleConnectionView,
    resetViewStacks,
    updateCurrentViewStack,
    pushViewStack,
    popViewStack
  };
});
function mapLegacyConnectionsToCanvasConnections(legacyConnections, nodes) {
  const mappedConnections = [];
  Object.keys(legacyConnections).forEach((fromNodeName) => {
    var _a;
    const fromId = ((_a = nodes.find((node2) => node2.name === fromNodeName)) == null ? void 0 : _a.id) ?? "";
    const fromConnectionTypes = Object.keys(
      legacyConnections[fromNodeName]
    );
    fromConnectionTypes.forEach((fromConnectionType) => {
      const fromPorts = legacyConnections[fromNodeName][fromConnectionType];
      fromPorts.forEach((toPorts, fromIndex) => {
        toPorts.forEach((toPort) => {
          var _a2;
          const toId = ((_a2 = nodes.find((node2) => node2.name === toPort.node)) == null ? void 0 : _a2.id) ?? "";
          const toConnectionType = toPort.type;
          const toIndex = toPort.index;
          const sourceHandle = createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Output,
            type: fromConnectionType,
            index: fromIndex
          });
          const targetHandle = createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Input,
            type: toConnectionType,
            index: toIndex
          });
          const connectionId = createCanvasConnectionId({
            source: fromId,
            sourceHandle,
            target: toId,
            targetHandle
          });
          if (fromId && toId) {
            mappedConnections.push({
              id: connectionId,
              source: fromId,
              target: toId,
              sourceHandle,
              targetHandle,
              data: {
                fromNodeName,
                source: {
                  index: fromIndex,
                  type: fromConnectionType
                },
                target: {
                  index: toIndex,
                  type: toConnectionType
                }
              }
            });
          }
        });
      });
    });
  });
  return mappedConnections;
}
function mapLegacyConnectionToCanvasConnection(sourceNode, targetNode, legacyConnection) {
  const source = sourceNode.id;
  const sourceHandle = createCanvasConnectionHandleString({
    mode: CanvasConnectionMode.Output,
    type: legacyConnection[0].type,
    index: legacyConnection[0].index
  });
  const target2 = targetNode.id;
  const targetHandle = createCanvasConnectionHandleString({
    mode: CanvasConnectionMode.Input,
    type: legacyConnection[1].type,
    index: legacyConnection[1].index
  });
  return {
    source,
    sourceHandle,
    target: target2,
    targetHandle
  };
}
function parseCanvasConnectionHandleString(handle2) {
  const [mode, type, index] = (handle2 ?? "").split("/");
  const resolvedMode = isValidCanvasConnectionMode(mode) ? mode : CanvasConnectionMode.Output;
  const resolvedType = isValidNodeConnectionType(type) ? type : NodeConnectionType.Main;
  let resolvedIndex = parseInt(index, 10);
  if (isNaN(resolvedIndex)) {
    resolvedIndex = 0;
  }
  return {
    mode: resolvedMode,
    type: resolvedType,
    index: resolvedIndex
  };
}
function createCanvasConnectionHandleString({
  mode,
  type = NodeConnectionType.Main,
  index = 0
}) {
  return `${mode}/${type}/${index}`;
}
function createCanvasConnectionId(connection) {
  return `[${connection.source}/${connection.sourceHandle}][${connection.target}/${connection.targetHandle}]`;
}
function mapCanvasConnectionToLegacyConnection(sourceNode, targetNode, connection) {
  const sourceNodeName = (sourceNode == null ? void 0 : sourceNode.name) ?? "";
  const { type: sourceType, index: sourceIndex } = parseCanvasConnectionHandleString(
    connection.sourceHandle
  );
  const targetNodeName = (targetNode == null ? void 0 : targetNode.name) ?? "";
  const { type: targetType, index: targetIndex } = parseCanvasConnectionHandleString(
    connection.targetHandle
  );
  return [
    {
      node: sourceNodeName,
      type: sourceType,
      index: sourceIndex
    },
    {
      node: targetNodeName,
      type: targetType,
      index: targetIndex
    }
  ];
}
function mapLegacyEndpointsToCanvasConnectionPort(endpoints, endpointNames = []) {
  if (typeof endpoints === "string") {
    console.warn("Node endpoints have not been evaluated", endpoints);
    return [];
  }
  return endpoints.map((endpoint, endpointIndex) => {
    const typeValue = typeof endpoint === "string" ? endpoint : endpoint.type;
    const type = isValidNodeConnectionType(typeValue) ? typeValue : NodeConnectionType.Main;
    const label2 = typeof endpoint === "string" ? endpointNames[endpointIndex] : endpoint.displayName;
    const index = endpoints.slice(0, endpointIndex + 1).filter((e) => (typeof e === "string" ? e : e.type) === type).length - 1;
    const required2 = typeof endpoint === "string" ? false : endpoint.required;
    const maxConnections = typeof endpoint === "string" ? void 0 : endpoint.maxConnections;
    return {
      type,
      index,
      label: label2,
      ...maxConnections ? { maxConnections } : {},
      ...required2 ? { required: required2 } : {}
    };
  });
}
function checkOverlap(node1, node2) {
  return !// node1 is completely to the left of node2
  (node1.x + node1.width <= node2.x || // node2 is completely to the left of node1
  node2.x + node2.width <= node1.x || // node1 is completely above node2
  node1.y + node1.height <= node2.y || // node2 is completely above node1
  node2.y + node2.height <= node1.y);
}
const useNodeCreatorStore = defineStore(STORES.NODE_CREATOR, () => {
  const workflowsStore = useWorkflowsStore();
  const ndvStore = useNDVStore();
  const uiStore = useUIStore();
  const nodeTypesStore = useNodeTypesStore();
  const externalHooks = useExternalHooks();
  const telemetry = useTelemetry();
  const selectedView = ref(TRIGGER_NODE_CREATOR_VIEW);
  const mergedNodes = ref([]);
  const actions2 = ref({});
  const showScrim = ref(false);
  const openSource = ref("");
  const allNodeCreatorNodes = computed(
    () => Object.values(mergedNodes.value).map((i) => transformNodeType(i))
  );
  function setMergeNodes(nodes) {
    mergedNodes.value = nodes;
  }
  function setActions(nodes) {
    actions2.value = nodes;
  }
  function setShowScrim(isVisible) {
    showScrim.value = isVisible;
  }
  function setSelectedView(view) {
    selectedView.value = view;
  }
  function setOpenSource(view) {
    openSource.value = view;
  }
  function openSelectiveNodeCreator({
    connectionType: connectionType2,
    node: node2,
    creatorView
  }) {
    const nodeName = node2 ?? ndvStore.activeNodeName;
    const nodeData = nodeName ? workflowsStore.getNodeByName(nodeName) : null;
    ndvStore.activeNodeName = null;
    setTimeout(() => {
      if (creatorView) {
        setNodeCreatorState({
          createNodeActive: true,
          nodeCreatorView: creatorView
        });
      } else if (connectionType2 && nodeData) {
        openNodeCreatorForConnectingNode({
          connection: {
            source: nodeData.id,
            sourceHandle: createCanvasConnectionHandleString({
              mode: "inputs",
              type: connectionType2,
              index: 0
            })
          },
          eventSource: NODE_CREATOR_OPEN_SOURCES.NOTICE_ERROR_MESSAGE
        });
      }
    });
  }
  function setNodeCreatorState({
    source,
    createNodeActive,
    nodeCreatorView
  }) {
    if (createNodeActive === uiStore.isCreateNodeActive) {
      return;
    }
    if (!nodeCreatorView) {
      nodeCreatorView = workflowsStore.workflowTriggerNodes.length > 0 ? REGULAR_NODE_CREATOR_VIEW : TRIGGER_NODE_CREATOR_VIEW;
    }
    setSelectedView(nodeCreatorView);
    let mode;
    switch (selectedView.value) {
      case AI_NODE_CREATOR_VIEW:
        mode = "ai";
        break;
      case REGULAR_NODE_CREATOR_VIEW:
        mode = "regular";
        break;
      default:
        mode = "regular";
    }
    uiStore.isCreateNodeActive = createNodeActive;
    if (createNodeActive && source) {
      setOpenSource(source);
    }
    void externalHooks.run("nodeView.createNodeActiveChanged", {
      source,
      mode,
      createNodeActive
    });
    trackNodesPanelActiveChanged({
      source,
      mode,
      createNodeActive,
      workflowId: workflowsStore.workflowId
    });
  }
  function trackNodesPanelActiveChanged({
    source,
    mode,
    createNodeActive,
    workflowId
  }) {
    telemetry.trackNodesPanel("nodeView.createNodeActiveChanged", {
      source,
      mode,
      createNodeActive,
      workflow_id: workflowId
    });
  }
  function openNodeCreatorForConnectingNode({
    connection,
    eventSource,
    nodeCreatorView
  }) {
    const sourceNode = workflowsStore.getNodeById(connection.source);
    if (!sourceNode) {
      return;
    }
    const { type, index, mode } = parseCanvasConnectionHandleString(connection.sourceHandle);
    uiStore.lastSelectedNode = sourceNode.name;
    uiStore.lastSelectedNodeEndpointUuid = connection.sourceHandle ?? null;
    uiStore.lastSelectedNodeOutputIndex = index;
    if (isVueFlowConnection(connection)) {
      uiStore.lastInteractedWithNodeConnection = connection;
    }
    uiStore.lastInteractedWithNodeHandle = connection.sourceHandle ?? null;
    uiStore.lastInteractedWithNodeId = sourceNode.id;
    setNodeCreatorState({
      source: eventSource,
      createNodeActive: true,
      nodeCreatorView
    });
    const isOutput = mode === CanvasConnectionMode.Output;
    const isScopedConnection = type !== NodeConnectionType.Main && nodeConnectionTypes.includes(type);
    if (isScopedConnection) {
      useViewStacks().gotoCompatibleConnectionView(type, isOutput, getNodeCreatorFilter(sourceNode.name, type)).catch(() => {
      });
    }
  }
  function openNodeCreatorForTriggerNodes(source) {
    ndvStore.activeNodeName = null;
    setSelectedView(TRIGGER_NODE_CREATOR_VIEW);
    setShowScrim(true);
    setNodeCreatorState({
      source,
      createNodeActive: true,
      nodeCreatorView: TRIGGER_NODE_CREATOR_VIEW
    });
  }
  function getNodeCreatorFilter(nodeName, outputType) {
    let filter2;
    const workflow = workflowsStore.getCurrentWorkflow();
    const workflowNode = workflow.getNode(nodeName);
    if (!workflowNode) return { nodes: [] };
    const nodeType = nodeTypesStore.getNodeType(workflowNode == null ? void 0 : workflowNode.type, workflowNode.typeVersion);
    if (nodeType) {
      const inputs2 = getNodeInputs(workflow, workflowNode, nodeType);
      const filterFound = inputs2.filter((input) => {
        if (typeof input === "string" || input.type !== outputType || !input.filter) {
          return false;
        }
        return true;
      });
      if (filterFound.length) {
        filter2 = filterFound[0].filter;
      }
    }
    return filter2;
  }
  return {
    openSource,
    selectedView,
    showScrim,
    mergedNodes,
    actions: actions2,
    setShowScrim,
    setSelectedView,
    setOpenSource,
    setActions,
    setMergeNodes,
    setNodeCreatorState,
    openSelectiveNodeCreator,
    openNodeCreatorForConnectingNode,
    openNodeCreatorForTriggerNodes,
    allNodeCreatorNodes
  };
});
const _hoisted_1$d = ["textContent"];
const _sfc_main$D = /* @__PURE__ */ defineComponent({
  __name: "CanvasAddButton",
  props: {
    showTooltip: { type: Boolean },
    position: {}
  },
  setup(__props) {
    const props = __props;
    const nodeCreatorStore = useNodeCreatorStore();
    const containerCssVars = computed(() => ({
      "--trigger-placeholder-left-position": `${props.position[0]}px`,
      "--trigger-placeholder-top-position": `${props.position[1]}px`
    }));
    return (_ctx, _cache) => {
      const _component_font_awesome_icon = resolveComponent("font-awesome-icon");
      const _component_n8n_tooltip = resolveComponent("n8n-tooltip");
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass(_ctx.$style.canvasAddButton),
        style: normalizeStyle(containerCssVars.value),
        "data-test-id": "canvas-add-button"
      }, [
        createVNode(_component_n8n_tooltip, {
          placement: "top",
          visible: _ctx.showTooltip,
          disabled: unref(nodeCreatorStore).showScrim,
          "popper-class": _ctx.$style.tooltip,
          "show-after": 700
        }, {
          content: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeView.canvasAddButton.addATriggerNodeBeforeExecuting")), 1)
          ]),
          default: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(_ctx.$style.button),
              "data-test-id": "canvas-plus-button",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("click"))
            }, [
              createVNode(_component_font_awesome_icon, {
                icon: "plus",
                size: "lg"
              })
            ], 2)
          ]),
          _: 1
        }, 8, ["visible", "disabled", "popper-class"]),
        createBaseVNode("p", {
          class: normalizeClass(_ctx.$style.label),
          textContent: toDisplayString(_ctx.$locale.baseText("nodeView.canvasAddButton.addFirstStep"))
        }, null, 10, _hoisted_1$d)
      ], 6);
    };
  }
});
const canvasAddButton = "_canvasAddButton_1easi_1";
const button$1 = "_button_1easi_13";
const label$6 = "_label_1easi_34";
const style0$n = {
  canvasAddButton,
  button: button$1,
  label: label$6
};
const cssModules$o = {
  "$style": style0$n
};
const CanvasAddButton = /* @__PURE__ */ _export_sfc$1(_sfc_main$D, [["__cssModules", cssModules$o]]);
function useCanvasPanning(elementRef, options = {}) {
  const uiStore = useUIStore();
  const moveLastPosition = ref([0, 0]);
  const deviceSupport = useDeviceSupport();
  function panCanvas(e) {
    const offsetPosition = uiStore.nodeViewOffsetPosition;
    const [x, y] = getMousePosition$1(e);
    const nodeViewOffsetPositionX = offsetPosition[0] + (x - moveLastPosition.value[0]);
    const nodeViewOffsetPositionY = offsetPosition[1] + (y - moveLastPosition.value[1]);
    uiStore.nodeViewOffsetPosition = [nodeViewOffsetPositionX, nodeViewOffsetPositionY];
    moveLastPosition.value = [x, y];
    return [nodeViewOffsetPositionX, nodeViewOffsetPositionY];
  }
  function onMouseDown(e, moveButtonPressed) {
    if (!(deviceSupport.isCtrlKeyPressed(e) || moveButtonPressed)) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    if (e.button !== MOUSE_EVENT_BUTTON.MIDDLE) {
      uiStore.nodeViewMoveInProgress = true;
    }
    const [x, y] = getMousePosition$1(e);
    moveLastPosition.value = [x, y];
    const element = unref(elementRef);
    element == null ? void 0 : element.addEventListener("mousemove", onMouseMove);
  }
  function onMouseUp() {
    if (!uiStore.nodeViewMoveInProgress) {
      return;
    }
    const element = unref(elementRef);
    element == null ? void 0 : element.removeEventListener("mousemove", onMouseMove);
    uiStore.nodeViewMoveInProgress = false;
  }
  function onMouseMove(e) {
    const element = unref(elementRef);
    if (e.target && !(element === e.target || (element == null ? void 0 : element.contains(e.target)))) {
      return;
    }
    if (uiStore.isActionActive["dragActive"]) {
      return;
    }
    if (e instanceof MouseEvent && e.buttons === MOUSE_EVENT_BUTTONS.MIDDLE) {
      uiStore.nodeViewMoveInProgress = true;
    }
    if (e instanceof MouseEvent && e.buttons === MOUSE_EVENT_BUTTONS.NONE) {
      const onMouseMoveEnd = unref(options.onMouseMoveEnd);
      onMouseMoveEnd == null ? void 0 : onMouseMoveEnd(e);
      return;
    }
    panCanvas(e);
  }
  return {
    moveLastPosition,
    onMouseDown,
    onMouseUp,
    onMouseMove,
    panCanvas
  };
}
const _hoisted_1$c = { "data-action": "reload" };
const _hoisted_2$8 = {
  href: "https://docs.n8n.io/integrations/builtin/core-nodes/n8n-nodes-base.wait/",
  target: "_blank"
};
const _sfc_main$C = /* @__PURE__ */ defineComponent({
  __name: "NodeViewUnfinishedWorkflowMessage",
  setup(__props) {
    const i18 = useI18n();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createBaseVNode("a", _hoisted_1$c, toDisplayString(unref(i18).baseText("nodeView.refresh")), 1),
        createTextVNode(" " + toDisplayString(unref(i18).baseText("nodeView.toSeeTheLatestStatus")) + ". ", 1),
        _cache[0] || (_cache[0] = createBaseVNode("br", null, null, -1)),
        createBaseVNode("a", _hoisted_2$8, toDisplayString(unref(i18).baseText("nodeView.moreInfo")), 1)
      ]);
    };
  }
});
const LazyNodeCreation = defineAsyncComponent(
  async () => await __vitePreload(() => import("./NodeCreation-CH8QZkmg.js").then((n) => n.N), true ? __vite__mapDeps([16,1,2,17]) : void 0)
);
const LazyCanvasControls = defineAsyncComponent(
  async () => await __vitePreload(() => import("./CanvasControls-Bh28om35.js"), true ? __vite__mapDeps([18,1,2,19]) : void 0)
);
const LazySetupWorkflowCredentialsButton = defineAsyncComponent(
  async () => await __vitePreload(() => import("./SetupWorkflowCredentialsButton-DrA_a2OJ.js"), true ? __vite__mapDeps([20,1,2]) : void 0)
);
const _sfc_main$B = defineComponent({
  name: "NodeView",
  components: {
    NodeDetailsView: __unplugin_components_2,
    Node: __unplugin_components_0$6,
    Sticky: __unplugin_components_1,
    CanvasAddButton,
    KeyboardShortcutTooltip,
    LazyNodeCreation,
    LazyCanvasControls,
    ContextMenu,
    LazySetupWorkflowCredentialsButton
  },
  setup() {
    const nodeViewRootRef = ref(null);
    const nodeViewRef = ref(null);
    const onMouseMoveEnd = ref(null);
    const router = useRouter();
    const route = useRoute();
    const ndvStore = useNDVStore();
    const externalHooks = useExternalHooks();
    const locale = useI18n();
    const contextMenu2 = useContextMenu();
    const dataSchema = useDataSchema();
    const nodeHelpers = useNodeHelpers();
    const clipboard = useClipboard();
    const { activeNode } = storeToRefs(ndvStore);
    const pinnedData2 = usePinnedData(activeNode);
    const deviceSupport = useDeviceSupport();
    const { callDebounced } = useDebounce();
    const canvasPanning = useCanvasPanning(nodeViewRootRef, { onMouseMoveEnd });
    const workflowHelpers = useWorkflowHelpers({ router });
    const { runWorkflow, stopCurrentExecution, runWorkflowResolvePending } = useRunWorkflow({
      router
    });
    const { addBeforeUnloadEventBindings, removeBeforeUnloadEventBindings } = useBeforeUnload({
      route
    });
    return {
      locale,
      contextMenu: contextMenu2,
      dataSchema,
      nodeHelpers,
      externalHooks,
      clipboard,
      pinnedData: pinnedData2,
      deviceSupport,
      canvasPanning,
      nodeViewRootRef,
      nodeViewRef,
      onMouseMoveEnd,
      workflowHelpers,
      runWorkflow,
      runWorkflowResolvePending,
      stopCurrentExecution,
      callDebounced,
      ...useCanvasMouseSelect(),
      ...useGlobalLinkActions(),
      documentTitle: useDocumentTitle(),
      ...useToast(),
      ...useMessage(),
      ...useUniqueNodeName(),
      ...useExecutionDebugging(),
      addBeforeUnloadEventBindings,
      removeBeforeUnloadEventBindings
    };
  },
  data() {
    return {
      GRID_SIZE,
      STICKY_NODE_TYPE,
      createNodeActive: false,
      lastClickPosition: [450, 450],
      ctrlKeyPressed: false,
      moveCanvasKeyPressed: false,
      stopExecutionInProgress: false,
      blankRedirect: false,
      pullConnActive: false,
      dropPrevented: false,
      connectionDragScope: {
        type: null,
        connection: null
      },
      renamingActive: false,
      showStickyButton: false,
      isExecutionPreview: false,
      showTriggerMissingTooltip: false,
      workflowData: null,
      activeConnection: null,
      enterTimer: void 0,
      exitTimer: void 0,
      readOnlyNotification: null,
      // jsplumb automatically deletes all loose connections which is in turn recorded
      // in undo history as a user action.
      // This should prevent automatically removed connections from populating undo stack
      suspendRecordingDetachedConnections: false,
      NODE_CREATOR_OPEN_SOURCES,
      eventsAttached: false,
      canOpenNDV: true,
      hideNodeIssues: false
    };
  },
  computed: {
    ...mapStores(
      useCanvasStore,
      useTagsStore,
      useCredentialsStore,
      useNodeCreatorStore,
      useNodeTypesStore,
      useNDVStore,
      useRootStore,
      useSettingsStore,
      useTemplatesStore,
      useUIStore,
      useWorkflowsStore,
      useUsersStore,
      useNodeCreatorStore,
      useEnvironmentsStore,
      useWorkflowsEEStore,
      useHistoryStore,
      useExternalSecretsStore,
      usePushConnectionStore,
      useSourceControlStore,
      useExecutionsStore,
      useProjectsStore,
      useNpsSurveyStore
    ),
    nativelyNumberSuffixedDefaults() {
      return this.nodeTypesStore.nativelyNumberSuffixedDefaults;
    },
    currentUser() {
      return this.usersStore.currentUser;
    },
    activeNode() {
      return this.ndvStore.activeNode;
    },
    executionWaitingForWebhook() {
      return this.workflowsStore.executionWaitingForWebhook;
    },
    isDemo() {
      return this.$route.name === VIEWS.DEMO;
    },
    showCanvasAddButton() {
      return !this.isLoading && !this.containsTrigger && !this.isDemo && !this.readOnlyEnv && !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
    },
    lastSelectedNode() {
      return this.uiStore.getLastSelectedNode;
    },
    nodes() {
      return this.workflowsStore.allNodes;
    },
    nodesToRender() {
      return this.workflowsStore.allNodes.filter((node2) => node2.type !== STICKY_NODE_TYPE);
    },
    stickiesToRender() {
      return this.workflowsStore.allNodes.filter((node2) => node2.type === STICKY_NODE_TYPE);
    },
    runButtonText() {
      if (!this.workflowRunning) {
        return this.$locale.baseText("nodeView.runButtonText.executeWorkflow");
      }
      if (this.executionWaitingForWebhook) {
        return this.$locale.baseText("nodeView.runButtonText.waitingForTriggerEvent");
      }
      return this.$locale.baseText("nodeView.runButtonText.executingWorkflow");
    },
    workflowStyle() {
      const offsetPosition = this.uiStore.nodeViewOffsetPosition;
      return {
        left: offsetPosition[0] + "px",
        top: offsetPosition[1] + "px"
      };
    },
    canvasAddButtonStyle() {
      return {
        "pointer-events": this.createNodeActive ? "none" : "all"
      };
    },
    backgroundStyle() {
      return getBackgroundStyles(
        this.nodeViewScale,
        this.uiStore.nodeViewOffsetPosition,
        this.isExecutionPreview || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
      );
    },
    workflowClasses() {
      const returnClasses = [];
      if (this.ctrlKeyPressed || this.moveCanvasKeyPressed) {
        if (this.uiStore.nodeViewMoveInProgress) {
          returnClasses.push("move-in-process");
        } else {
          returnClasses.push("move-active");
        }
      }
      if (this.selectActive || this.ctrlKeyPressed || this.moveCanvasKeyPressed) {
        returnClasses.push("do-not-select");
      }
      if (this.connectionDragScope.type) {
        returnClasses.push("connection-drag-scope-active");
        returnClasses.push(`connection-drag-scope-active-type-${this.connectionDragScope.type}`);
        returnClasses.push(
          `connection-drag-scope-active-connection-${this.connectionDragScope.connection}`
        );
      }
      return returnClasses;
    },
    workflowExecution() {
      return this.workflowsStore.getWorkflowExecution;
    },
    workflowRunning() {
      return this.workflowsStore.isWorkflowRunning;
    },
    currentWorkflow() {
      var _a;
      return ((_a = this.$route.params.name) == null ? void 0 : _a.toString()) || this.workflowsStore.workflowId;
    },
    workflowName() {
      return this.workflowsStore.workflowName;
    },
    allTriggersDisabled() {
      const disabledTriggerNodes = this.triggerNodes.filter((node2) => node2.disabled);
      return disabledTriggerNodes.length === this.triggerNodes.length;
    },
    triggerNodes() {
      return this.nodes.filter(
        (node2) => node2.type === START_NODE_TYPE || this.nodeTypesStore.isTriggerNode(node2.type)
      );
    },
    containsTrigger() {
      return this.triggerNodes.length > 0;
    },
    containsChatNodes() {
      return !this.executionWaitingForWebhook && !!this.nodes.find(
        (node2) => [MANUAL_CHAT_TRIGGER_NODE_TYPE, CHAT_TRIGGER_NODE_TYPE].includes(node2.type) && node2.disabled !== true
      );
    },
    isManualChatOnly() {
      if (!this.canvasChatNode) return false;
      return this.containsChatNodes && this.triggerNodes.length === 1 && !this.pinnedChatNodeData;
    },
    canvasChatNode() {
      return this.nodes.find((node2) => node2.type === CHAT_TRIGGER_NODE_TYPE);
    },
    pinnedChatNodeData() {
      if (!this.canvasChatNode) return null;
      return this.workflowsStore.pinDataByNodeName(this.canvasChatNode.name);
    },
    isExecutionDisabled() {
      if (this.containsChatNodes && this.triggerNodes.every((node2) => node2.disabled || node2.type === CHAT_TRIGGER_NODE_TYPE) && !this.pinnedChatNodeData) {
        return true;
      }
      return !this.containsTrigger || this.allTriggersDisabled;
    },
    getNodeViewOffsetPosition() {
      return this.uiStore.nodeViewOffsetPosition;
    },
    nodeViewScale() {
      return this.canvasStore.nodeViewScale;
    },
    instance() {
      return this.canvasStore.jsPlumbInstance;
    },
    isLoading() {
      return this.canvasStore.isLoading;
    },
    currentWorkflowObject() {
      return this.workflowsStore.getCurrentWorkflow();
    },
    readOnlyEnv() {
      return this.sourceControlStore.preferences.branchReadOnly;
    },
    isReadOnlyRoute() {
      var _a, _b;
      return ((_b = (_a = this.$route) == null ? void 0 : _a.meta) == null ? void 0 : _b.readOnlyCanvas) === true;
    },
    isProductionExecutionPreview() {
      return this.nodeHelpers.isProductionExecutionPreview.value;
    },
    workflowPermissions() {
      var _a;
      return getResourcePermissions(
        (_a = this.workflowsStore.getWorkflowById(this.currentWorkflow)) == null ? void 0 : _a.scopes
      ).workflow;
    },
    projectPermissions() {
      var _a;
      const project = ((_a = this.$route.query) == null ? void 0 : _a.projectId) ? this.projectsStore.myProjects.find((p) => p.id === this.$route.query.projectId) : this.projectsStore.currentProject ?? this.projectsStore.personalProject;
      return getResourcePermissions(project == null ? void 0 : project.scopes);
    }
  },
  watch: {
    // Listen to route changes and load the workflow accordingly
    async $route(to, from) {
      await this.readOnlyEnvRouteCheck();
      const currentTab = getNodeViewTab(to);
      const nodeViewNotInitialized = !this.uiStore.nodeViewInitialized;
      let workflowChanged = from.params.name !== to.params.name && // Both 'new' and __EMPTY__ are new workflow names, so ignore them when detecting if wf changed
      !(from.params.name === "new" && this.currentWorkflow === PLACEHOLDER_EMPTY_WORKFLOW_ID) && !(from.name === VIEWS.NEW_WORKFLOW) && // Also ignore if workflow id changes when saving new workflow
      to.params.action !== "workflowSave";
      const isOpeningTemplate = to.name === VIEWS.TEMPLATE_IMPORT;
      if (currentTab === MAIN_HEADER_TABS.WORKFLOW || isOpeningTemplate) {
        if (workflowChanged || nodeViewNotInitialized || isOpeningTemplate) {
          this.canvasStore.startLoading();
          if (nodeViewNotInitialized) {
            const previousDirtyState = this.uiStore.stateIsDirty;
            this.resetWorkspace();
            this.uiStore.stateIsDirty = previousDirtyState;
          }
          await this.initView();
          this.canvasStore.stopLoading();
          if (this.blankRedirect) {
            this.blankRedirect = false;
          }
        }
        await this.checkAndInitDebugMode();
      }
      if (currentTab === MAIN_HEADER_TABS.EXECUTIONS) {
        workflowChanged = from.params.name !== to.params.name && !(to.params.name === "new" && from.params.name === void 0);
        if (workflowChanged) {
          this.uiStore.nodeViewInitialized = false;
        }
      }
    },
    activeNode() {
      this.createNodeActive = false;
    },
    containsTrigger(containsTrigger) {
      if (containsTrigger === false)
        this.canvasStore.setRecenteredCanvasAddButtonPosition(this.getNodeViewOffsetPosition);
    },
    nodeViewScale(newScale) {
      const elementRef = this.nodeViewRef;
      if (elementRef) {
        elementRef.style.transform = `scale(${newScale})`;
      }
    }
  },
  errorCaptured: (err) => {
    console.error("errorCaptured");
    console.error(err);
  },
  async mounted() {
    this.onMouseMoveEnd = this.mouseUp;
    this.initializeCanvasMouseSelect();
    this.resetWorkspace();
    if (!this.nodeViewRef) {
      this.showError(
        new Error("NodeView reference not found"),
        this.$locale.baseText("nodeView.showError.mounted1.title"),
        this.$locale.baseText("nodeView.showError.mounted1.message") + ":"
      );
      return;
    }
    this.canvasStore.initInstance(this.nodeViewRef);
    this.documentTitle.reset();
    window.addEventListener("message", this.onPostMessageReceived);
    this.clipboard.onPaste.value = this.onClipboardPasteEvent;
    this.canvasStore.startLoading();
    const loadPromises = (() => {
      if (this.settingsStore.isPreviewMode && this.isDemo) return [];
      const promises = [this.loadActiveWorkflows(), this.loadCredentialTypes()];
      if (this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Variables]) {
        promises.push(this.loadVariables());
      }
      if (this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.ExternalSecrets]) {
        promises.push(this.loadSecrets());
      }
      return promises;
    })();
    if (this.nodeTypesStore.allNodeTypes.length === 0) {
      loadPromises.push(this.loadNodeTypes());
    }
    try {
      await Promise.all(loadPromises);
    } catch (error2) {
      this.showError(
        error2,
        this.$locale.baseText("nodeView.showError.mounted1.title"),
        this.$locale.baseText("nodeView.showError.mounted1.message") + ":"
      );
      return;
    }
    ready$1(async () => {
      try {
        try {
          this.bindCanvasEvents();
        } catch {
        }
        await this.initView();
        if (window.parent) {
          window.parent.postMessage(
            JSON.stringify({ command: "n8nReady", version: this.rootStore.versionCli }),
            "*"
          );
        }
      } catch (error2) {
        this.showError(
          error2,
          this.$locale.baseText("nodeView.showError.mounted2.title"),
          this.$locale.baseText("nodeView.showError.mounted2.message") + ":"
        );
      }
      this.canvasStore.stopLoading();
      setTimeout(() => {
        void this.usersStore.showPersonalizationSurvey();
        this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
      }, 0);
    });
    void this.externalHooks.run("nodeView.mount").catch(() => {
    });
    sourceControlEventBus.on("pull", this.onSourceControlPull);
    this.registerCustomAction({
      key: "openNodeDetail",
      action: ({ node: node2 }) => {
        this.nodeSelectedByName(node2, true);
      }
    });
    this.registerCustomAction({
      key: "openSelectiveNodeCreator",
      action: this.openSelectiveNodeCreator
    });
    this.registerCustomAction({
      key: "showNodeCreator",
      action: () => {
        this.ndvStore.activeNodeName = null;
        void this.$nextTick(() => {
          this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TAB);
        });
      }
    });
    await this.readOnlyEnvRouteCheck();
    this.canvasStore.isDemo = this.isDemo;
  },
  activated() {
    const openSideMenu = this.uiStore.addFirstStepOnLoad;
    if (openSideMenu) {
      this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
    }
    this.uiStore.addFirstStepOnLoad = false;
    this.bindCanvasEvents();
    document.addEventListener("keydown", this.keyDown);
    document.addEventListener("keyup", this.keyUp);
    window.addEventListener("message", this.onPostMessageReceived);
    window.addEventListener("pageshow", this.onPageShow);
    nodeViewEventBus.on("newWorkflow", this.newWorkflow);
    nodeViewEventBus.on("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.on("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    nodeViewEventBus.on("openChat", this.onOpenChat);
    historyBus.on("nodeMove", this.onMoveNode);
    historyBus.on("revertAddNode", this.onRevertAddNode);
    historyBus.on("revertRemoveNode", this.onRevertRemoveNode);
    historyBus.on("revertAddConnection", this.onRevertAddConnection);
    historyBus.on("revertRemoveConnection", this.onRevertRemoveConnection);
    historyBus.on("revertRenameNode", this.onRevertNameChange);
    historyBus.on("enableNodeToggle", this.onRevertEnableToggle);
    dataPinningEventBus.on("pin-data", this.nodeHelpers.addPinDataConnections);
    dataPinningEventBus.on("unpin-data", this.nodeHelpers.removePinDataConnections);
    nodeViewEventBus.on("saveWorkflow", this.saveCurrentWorkflowExternal);
    this.canvasStore.isDemo = this.isDemo;
    this.addBeforeUnloadEventBindings();
  },
  deactivated() {
    this.unbindCanvasEvents();
    document.removeEventListener("keydown", this.keyDown);
    document.removeEventListener("keyup", this.keyUp);
    window.removeEventListener("message", this.onPostMessageReceived);
    window.removeEventListener("pageshow", this.onPageShow);
    nodeViewEventBus.off("newWorkflow", this.newWorkflow);
    nodeViewEventBus.off("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.off("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    nodeViewEventBus.off("openChat", this.onOpenChat);
    historyBus.off("nodeMove", this.onMoveNode);
    historyBus.off("revertAddNode", this.onRevertAddNode);
    historyBus.off("revertRemoveNode", this.onRevertRemoveNode);
    historyBus.off("revertAddConnection", this.onRevertAddConnection);
    historyBus.off("revertRemoveConnection", this.onRevertRemoveConnection);
    historyBus.off("revertRenameNode", this.onRevertNameChange);
    historyBus.off("enableNodeToggle", this.onRevertEnableToggle);
    dataPinningEventBus.off("pin-data", this.nodeHelpers.addPinDataConnections);
    dataPinningEventBus.off("unpin-data", this.nodeHelpers.removePinDataConnections);
    nodeViewEventBus.off("saveWorkflow", this.saveCurrentWorkflowExternal);
    this.removeBeforeUnloadEventBindings();
  },
  beforeMount() {
    if (!this.isDemo) {
      this.pushStore.pushConnect();
    }
  },
  beforeUnmount() {
    document.removeEventListener("keydown", this.keyDown);
    document.removeEventListener("keyup", this.keyUp);
    this.unregisterCustomAction("showNodeCreator");
    this.unregisterCustomAction("openNodeDetail");
    this.unregisterCustomAction("openSelectiveNodeCreator");
    if (!this.isDemo) {
      this.pushStore.pushDisconnect();
    }
    this.resetWorkspace();
    this.instance.unbind();
    this.instance.destroy();
    this.uiStore.stateIsDirty = false;
    this.workflowsStore.resetChatMessages();
    window.removeEventListener("message", this.onPostMessageReceived);
    nodeViewEventBus.off("newWorkflow", this.newWorkflow);
    nodeViewEventBus.off("importWorkflowData", this.onImportWorkflowDataEvent);
    nodeViewEventBus.off("importWorkflowUrl", this.onImportWorkflowUrlEvent);
    this.workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
    sourceControlEventBus.off("pull", this.onSourceControlPull);
  },
  methods: {
    async openSelectiveNodeCreator({
      connectiontype,
      node: node2,
      creatorview
    }) {
      const nodeName = node2 ?? this.ndvStore.activeNodeName;
      const nodeData = nodeName ? this.workflowsStore.getNodeByName(nodeName) : null;
      this.ndvStore.activeNodeName = null;
      await this.redrawNode(node2);
      setTimeout(() => {
        if (creatorview) {
          this.onToggleNodeCreator({
            createNodeActive: true,
            nodeCreatorView: creatorview
          });
        } else if (connectiontype && nodeData) {
          this.insertNodeAfterSelected({
            index: 0,
            endpointUuid: `${nodeData.id}-input${connectiontype}0`,
            eventSource: NODE_CREATOR_OPEN_SOURCES.NOTICE_ERROR_MESSAGE,
            outputType: connectiontype,
            sourceId: nodeData.id
          });
        }
      });
    },
    editAllowedCheck() {
      if (this.readOnlyNotification) {
        return false;
      }
      if (this.isReadOnlyRoute || this.readOnlyEnv) {
        this.readOnlyNotification = this.showMessage({
          title: this.$locale.baseText(
            this.readOnlyEnv ? `readOnlyEnv.showMessage.${this.isReadOnlyRoute ? "executions" : "workflows"}.title` : "readOnly.showMessage.executions.title"
          ),
          message: this.$locale.baseText(
            this.readOnlyEnv ? `readOnlyEnv.showMessage.${this.isReadOnlyRoute ? "executions" : "workflows"}.message` : "readOnly.showMessage.executions.message"
          ),
          type: "info",
          dangerouslyUseHTMLString: true,
          onClose: () => {
            this.readOnlyNotification = null;
          }
        });
        return false;
      }
      return !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
    },
    showTriggerMissingToltip(isVisible) {
      this.showTriggerMissingTooltip = isVisible;
    },
    onRunNode(nodeName, source) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      const telemetryPayload = {
        node_type: node2 ? node2.type : null,
        workflow_id: this.workflowsStore.workflowId,
        source: "canvas",
        push_ref: this.ndvStore.pushRef
      };
      this.$telemetry.track("User clicked execute node button", telemetryPayload);
      void this.externalHooks.run("nodeView.onRunNode", telemetryPayload);
      if (!this.isExecutionPreview && this.workflowsStore.isWaitingExecution) {
        void this.runWorkflowResolvePending({ destinationNode: nodeName, source });
      } else {
        void this.runWorkflow({ destinationNode: nodeName, source });
      }
    },
    async onOpenChat() {
      const telemetryPayload = {
        workflow_id: this.workflowsStore.workflowId
      };
      this.$telemetry.track("User clicked chat open button", telemetryPayload);
      void this.externalHooks.run("nodeView.onOpenChat", telemetryPayload);
      this.uiStore.openModal(WORKFLOW_LM_CHAT_MODAL_KEY);
    },
    async onRunWorkflow() {
      void this.workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const telemetryPayload = {
          workflow_id: this.workflowsStore.workflowId,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              this.workflowHelpers.getNodeTypes(),
              { isCloudDeployment: this.settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        this.$telemetry.track("User clicked execute workflow button", telemetryPayload);
        void this.externalHooks.run("nodeView.onRunWorkflow", telemetryPayload);
      });
      if (!this.isExecutionPreview && this.workflowsStore.isWaitingExecution) {
        void this.runWorkflowResolvePending({});
      } else {
        void this.runWorkflow({});
      }
      this.refreshEndpointsErrorsState();
    },
    resetEndpointsErrors() {
      const allEndpoints = Object.values(this.instance.getManagedElements()).flatMap(
        (el) => el.endpoints
      );
      allEndpoints.filter((endpoint) => (endpoint == null ? void 0 : endpoint.endpoint.type) === N8nAddInputEndpointType).forEach((endpoint) => {
        const n8nAddInputEndpoint = endpoint == null ? void 0 : endpoint.endpoint;
        if (n8nAddInputEndpoint && ((endpoint == null ? void 0 : endpoint.connections) ?? []).length > 0) {
          n8nAddInputEndpoint.resetError();
        }
      });
    },
    refreshEndpointsErrorsState() {
      const nodeIssues = this.workflowsStore.allNodes.filter((n) => n.issues);
      this.resetEndpointsErrors();
      nodeIssues.forEach((node2) => {
        var _a;
        const managedNode = this.instance.getManagedElement(node2.id);
        const endpoints = this.instance.getEndpoints(managedNode);
        Object.keys(((_a = node2 == null ? void 0 : node2.issues) == null ? void 0 : _a.input) ?? {}).forEach((connectionType2) => {
          const inputEndpointsWithIssues = endpoints.filter(
            (e) => e._defaultType.scope === connectionType2
          );
          inputEndpointsWithIssues.forEach((endpoint) => {
            const n8nAddInputEndpoint = endpoint == null ? void 0 : endpoint.endpoint;
            if (n8nAddInputEndpoint) {
              n8nAddInputEndpoint.setError();
            }
          });
        });
      });
    },
    onRunContainerClick() {
      if (this.containsTrigger && !this.allTriggersDisabled) return;
      const message = this.containsTrigger && this.allTriggersDisabled ? this.$locale.baseText("nodeView.addOrEnableTriggerNode") : this.$locale.baseText("nodeView.addATriggerNodeFirst");
      const notice = this.showMessage({
        type: "info",
        title: this.$locale.baseText("nodeView.cantExecuteNoTrigger"),
        message,
        duration: 3e3,
        onClick: () => setTimeout(() => {
          if (this.createNodeActive) notice.close();
        }, 0),
        dangerouslyUseHTMLString: true
      });
    },
    async clearExecutionData() {
      this.workflowsStore.workflowExecutionData = null;
      this.nodeHelpers.updateNodesExecutionIssues();
    },
    async onSaveKeyboardShortcut(e) {
      let saved = await this.workflowHelpers.saveCurrentWorkflow();
      if (saved) {
        await this.npsSurveyStore.fetchPromptsData();
        if (this.$route.name === VIEWS.EXECUTION_DEBUG) {
          await this.$router.replace({
            name: VIEWS.WORKFLOW,
            params: { name: this.currentWorkflow }
          });
        }
      }
      if (this.activeNode) {
        if (e.target instanceof HTMLInputElement) {
          saved = e.target.readOnly;
        } else {
          saved = true;
        }
        if (saved) {
          this.showMessage({
            title: this.$locale.baseText("generic.workflowSaved"),
            type: "success"
          });
        }
      }
    },
    async onCanvasAddButtonCLick() {
      this.showTriggerCreator(NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON);
    },
    showTriggerCreator(source) {
      if (this.createNodeActive) return;
      this.ndvStore.activeNodeName = null;
      this.nodeCreatorStore.setSelectedView(TRIGGER_NODE_CREATOR_VIEW);
      this.nodeCreatorStore.setShowScrim(true);
      this.onToggleNodeCreator({
        source,
        createNodeActive: true,
        nodeCreatorView: TRIGGER_NODE_CREATOR_VIEW
      });
    },
    async openExecution(executionId) {
      var _a, _b;
      this.canvasStore.startLoading();
      this.resetWorkspace();
      let data;
      try {
        data = await this.workflowsStore.getExecution(executionId);
      } catch (error2) {
        this.showError(error2, this.$locale.baseText("nodeView.showError.openExecution.title"));
        return;
      }
      if (data === void 0) {
        throw new Error(`Execution with id "${executionId}" could not be found!`);
      }
      this.workflowsStore.setWorkflowName({
        newName: data.workflowData.name,
        setStateDirty: false
      });
      this.workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
      this.workflowsStore.setWorkflowExecutionData(data);
      if (data.workflowData.pinData && data.mode === "manual") {
        this.workflowsStore.setWorkflowPinData(data.workflowData.pinData);
      }
      if (data.workflowData.sharedWithProjects) {
        this.workflowsEEStore.setWorkflowSharedWith({
          workflowId: data.workflowData.id,
          sharedWithProjects: data.workflowData.sharedWithProjects
        });
      }
      if (data.workflowData.usedCredentials) {
        this.workflowsStore.setUsedCredentials(data.workflowData.usedCredentials);
      }
      await this.nodeHelpers.addNodes(
        deepCopy(data.workflowData.nodes),
        deepCopy(data.workflowData.connections)
      );
      await this.$nextTick();
      this.canvasStore.zoomToFit();
      this.uiStore.stateIsDirty = false;
      void this.externalHooks.run("execution.open", {
        workflowId: data.workflowData.id,
        workflowName: data.workflowData.name,
        executionId
      });
      this.$telemetry.track("User opened read-only execution", {
        workflow_id: data.workflowData.id,
        execution_mode: data.mode,
        execution_finished: data.finished
      });
      if (!data.finished && ((_b = (_a = data.data) == null ? void 0 : _a.resultData) == null ? void 0 : _b.error)) {
        let nodeErrorFound = false;
        if (data.data.resultData.runData) {
          const runData2 = data.data.resultData.runData;
          errorCheck: for (const nodeName of Object.keys(runData2)) {
            for (const taskData of runData2[nodeName]) {
              if (taskData.error) {
                nodeErrorFound = true;
                break errorCheck;
              }
            }
          }
        }
        if (!nodeErrorFound && (data.data.resultData.error.stack || data.data.resultData.error.message)) {
          console.error(`Execution ${executionId} error:`);
          console.error(data.data.resultData.error.stack);
          this.showMessage({
            title: this.$locale.baseText("nodeView.showError.workflowError"),
            message: data.data.resultData.error.message,
            type: "error",
            duration: 0
          });
        }
      }
      if (data.waitTill) {
        this.showMessage({
          title: this.$locale.baseText("nodeView.thisExecutionHasntFinishedYet"),
          message: h(_sfc_main$C),
          type: "warning",
          duration: 0
        });
      }
      this.canvasStore.stopLoading();
    },
    async importWorkflowExact(data) {
      if (!data.workflow.nodes || !data.workflow.connections) {
        throw new Error("Invalid workflow object");
      }
      this.resetWorkspace();
      data.workflow.nodes = getFixedNodesList(data.workflow.nodes);
      await this.nodeHelpers.addNodes(data.workflow.nodes, data.workflow.connections);
      if (data.workflow.pinData) {
        this.workflowsStore.setWorkflowPinData(data.workflow.pinData);
      }
      await this.$nextTick();
      this.canvasStore.zoomToFit();
    },
    async openWorkflowTemplate(templateId) {
      this.canvasStore.startLoading();
      this.canvasStore.setLoadingText(this.$locale.baseText("nodeView.loadingTemplate"));
      this.resetWorkspace();
      this.workflowsStore.currentWorkflowExecutions = [];
      this.executionsStore.activeExecution = null;
      let data;
      try {
        void this.externalHooks.run("template.requested", { templateId });
        data = await this.templatesStore.getFixedWorkflowTemplate(templateId);
        if (!data) {
          throw new Error(
            this.$locale.baseText("nodeView.workflowTemplateWithIdCouldNotBeFound", {
              interpolate: { templateId }
            })
          );
        }
      } catch (error2) {
        this.showError(error2, this.$locale.baseText("nodeView.couldntImportWorkflow"));
        await this.$router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      this.$telemetry.track(
        "User inserted workflow template",
        {
          source: "workflow",
          template_id: tryToParseNumber(templateId),
          wf_template_repo_session_id: this.templatesStore.previousSessionId
        },
        {
          withPostHog: true
        }
      );
      this.blankRedirect = true;
      await this.$router.replace({ name: VIEWS.NEW_WORKFLOW, query: { templateId } });
      const convertedNodes = data.workflow.nodes.map(
        this.workflowsStore.convertTemplateNodeToNodeUi
      );
      await this.nodeHelpers.addNodes(convertedNodes, data.workflow.connections);
      this.workflowData = await this.workflowsStore.getNewWorkflowData(
        data.name,
        this.projectsStore.currentProjectId
      ) || {};
      this.workflowsStore.addToWorkflowMetadata({ templateId });
      await this.$nextTick();
      this.canvasStore.zoomToFit();
      this.uiStore.stateIsDirty = true;
      void this.externalHooks.run("template.open", {
        templateId,
        templateName: data.name,
        workflow: data.workflow
      });
      this.canvasStore.stopLoading();
    },
    async openWorkflow(workflow) {
      this.canvasStore.startLoading();
      const selectedExecution = this.executionsStore.activeExecution;
      this.resetWorkspace();
      this.workflowHelpers.initState(workflow);
      if (workflow.sharedWithProjects) {
        this.workflowsEEStore.setWorkflowSharedWith({
          workflowId: workflow.id,
          sharedWithProjects: workflow.sharedWithProjects
        });
      }
      if (workflow.usedCredentials) {
        this.workflowsStore.setUsedCredentials(workflow.usedCredentials);
      }
      await this.nodeHelpers.addNodes(workflow.nodes, workflow.connections);
      if (!this.nodeHelpers.credentialsUpdated.value) {
        this.uiStore.stateIsDirty = false;
      }
      this.canvasStore.zoomToFit();
      void this.externalHooks.run("workflow.open", {
        workflowId: workflow.id,
        workflowName: workflow.name
      });
      if ((selectedExecution == null ? void 0 : selectedExecution.workflowId) !== workflow.id) {
        this.executionsStore.activeExecution = null;
        this.workflowsStore.currentWorkflowExecutions = [];
      } else {
        this.executionsStore.activeExecution = selectedExecution;
      }
      this.canvasStore.stopLoading();
    },
    touchTap(e) {
      if (this.deviceSupport.isTouchDevice) {
        this.mouseDown(e);
      }
    },
    mouseDown(e) {
      this.lastClickPosition = this.getMousePositionWithinNodeView(e);
      if (e instanceof MouseEvent && e.button === 1) {
        this.moveCanvasKeyPressed = true;
      }
      this.mouseDownMouseSelect(e, this.moveCanvasKeyPressed);
      this.canvasPanning.onMouseDown(e, this.moveCanvasKeyPressed);
      this.createNodeActive = false;
    },
    mouseUp(e) {
      if (e instanceof MouseEvent && e.button === 1) {
        this.moveCanvasKeyPressed = false;
      }
      this.mouseUpMouseSelect(e);
      this.canvasPanning.onMouseUp();
    },
    keyUp(e) {
      if (e.key === this.deviceSupport.controlKeyCode) {
        this.ctrlKeyPressed = false;
      }
      if (e.key === " ") {
        this.moveCanvasKeyPressed = false;
      }
    },
    async keyDown(e) {
      this.contextMenu.close();
      const ctrlModifier = this.deviceSupport.isCtrlKeyPressed(e) && !e.shiftKey && !e.altKey;
      const shiftModifier = e.shiftKey && !e.altKey && !this.deviceSupport.isCtrlKeyPressed(e);
      const ctrlAltModifier = this.deviceSupport.isCtrlKeyPressed(e) && e.altKey && !e.shiftKey;
      const noModifierKeys = !this.deviceSupport.isCtrlKeyPressed(e) && !e.shiftKey && !e.altKey;
      const readOnly = this.isReadOnlyRoute || this.readOnlyEnv || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
      if (e.key === "s" && ctrlModifier && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        const workflowIsSaved = !this.uiStore.stateIsDirty;
        if (workflowIsSaved) {
          return;
        }
        void this.callDebounced(this.onSaveKeyboardShortcut, { debounceTime: 1e3 }, e);
        return;
      }
      const path = (e == null ? void 0 : e.composedPath()) ?? [];
      for (const element of path) {
        if (element instanceof HTMLElement && element.className && typeof element.className === "string" && element.className.includes("ignore-key-press")) {
          return;
        }
      }
      if (window.document.body.classList.contains("el-popup-parent--hidden")) {
        return;
      }
      if (e.key === "Escape" && noModifierKeys) {
        this.createNodeActive = false;
        if (this.activeNode) {
          void this.externalHooks.run("dataDisplay.nodeEditingFinished");
          this.ndvStore.activeNodeName = null;
        }
        return;
      }
      if (this.activeNode) {
        return;
      }
      const selectedNodes = this.uiStore.getSelectedNodes.map((node2) => node2 && this.workflowsStore.getNodeByName(node2.name)).filter((node2) => !!node2);
      if (e.key === "d" && noModifierKeys && !readOnly) {
        void this.callDebounced(this.toggleActivationNodes, { debounceTime: 350 }, selectedNodes);
      } else if (e.key === "d" && ctrlModifier && !readOnly) {
        if (selectedNodes.length > 0) {
          e.preventDefault();
          void this.duplicateNodes(selectedNodes);
        }
      } else if (e.key === "p" && noModifierKeys && !readOnly) {
        if (selectedNodes.length > 0) {
          e.preventDefault();
          this.togglePinNodes(selectedNodes, "keyboard-shortcut");
        }
      } else if ((e.key === "Delete" || e.key === "Backspace") && noModifierKeys && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.deleteNodes, { debounceTime: 500 }, selectedNodes);
      } else if (e.key === "Tab" && noModifierKeys && !readOnly) {
        this.onToggleNodeCreator({
          source: NODE_CREATOR_OPEN_SOURCES.TAB,
          createNodeActive: !this.createNodeActive && !this.isReadOnlyRoute && !this.readOnlyEnv
        });
      } else if (e.key === "Enter" && ctrlModifier && !readOnly && !this.isExecutionDisabled) {
        void this.onRunWorkflow();
      } else if (e.key === "S" && shiftModifier && !readOnly) {
        void this.onAddNodes({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
      } else if (e.key === this.deviceSupport.controlKeyCode) {
        this.ctrlKeyPressed = true;
      } else if (e.key === " ") {
        this.moveCanvasKeyPressed = true;
      } else if (e.key === "F2" && noModifierKeys && !readOnly) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode !== null && lastSelectedNode.type !== STICKY_NODE_TYPE) {
          void this.callDebounced(
            this.renameNodePrompt,
            { debounceTime: 1500 },
            lastSelectedNode.name
          );
        }
      } else if (e.key === "a" && ctrlModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectAllNodes, { debounceTime: 1e3 });
      } else if (e.key === "c" && ctrlModifier) {
        void this.callDebounced(this.copyNodes, { debounceTime: 1e3 }, selectedNodes);
      } else if (e.key === "x" && ctrlModifier && !readOnly) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.cutNodes, { debounceTime: 1e3 }, selectedNodes);
      } else if (e.key === "n" && ctrlAltModifier) {
        e.stopPropagation();
        e.preventDefault();
        if (this.isDemo) {
          return;
        }
        if (this.$router.currentRoute.value.name === VIEWS.NEW_WORKFLOW) {
          nodeViewEventBus.emit("newWorkflow");
        } else {
          void this.$router.push({ name: VIEWS.NEW_WORKFLOW });
        }
        this.showMessage({
          title: this.$locale.baseText("nodeView.showMessage.keyDown.title"),
          type: "success"
        });
      } else if (e.key === "Enter" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode !== null) {
          if (lastSelectedNode.type === STICKY_NODE_TYPE && (this.isReadOnlyRoute || this.readOnlyEnv || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update))) {
            return;
          }
          this.ndvStore.activeNodeName = lastSelectedNode.name;
        }
      } else if (e.key === "ArrowRight" && shiftModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectDownstreamNodes, {
          debounceTime: 1e3
        });
      } else if (e.key === "ArrowRight" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const connections2 = this.workflowsStore.outgoingConnectionsByNodeName(
          lastSelectedNode.name
        );
        if (connections2.main === void 0 || connections2.main.length === 0) {
          return;
        }
        void this.callDebounced(
          this.nodeSelectedByName,
          { debounceTime: 100 },
          connections2.main[0][0].node,
          false,
          true
        );
      } else if (e.key === "ArrowLeft" && shiftModifier) {
        e.stopPropagation();
        e.preventDefault();
        void this.callDebounced(this.selectUpstreamNodes, {
          debounceTime: 1e3
        });
      } else if (e.key === "ArrowLeft" && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        if (!workflow.connectionsByDestinationNode.hasOwnProperty(lastSelectedNode.name)) {
          return;
        }
        const connections2 = workflow.connectionsByDestinationNode[lastSelectedNode.name];
        if (connections2.main === void 0 || connections2.main.length === 0) {
          return;
        }
        void this.callDebounced(
          this.nodeSelectedByName,
          { debounceTime: 100 },
          connections2.main[0][0].node,
          false,
          true
        );
      } else if (["ArrowUp", "ArrowDown"].includes(e.key) && noModifierKeys) {
        const lastSelectedNode = this.lastSelectedNode;
        if (lastSelectedNode === null) {
          return;
        }
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        if (!workflow.connectionsByDestinationNode.hasOwnProperty(lastSelectedNode.name)) {
          return;
        }
        const connections2 = workflow.connectionsByDestinationNode[lastSelectedNode.name];
        if (!Array.isArray(connections2.main) || !connections2.main.length) {
          return;
        }
        const parentNode = connections2.main[0][0].node;
        const connectionsParent = this.workflowsStore.outgoingConnectionsByNodeName(parentNode);
        if (!Array.isArray(connectionsParent.main) || !connectionsParent.main.length) {
          return;
        }
        let siblingNode;
        let lastCheckedNodePosition = e.key === "ArrowUp" ? -99999999 : 99999999;
        let nextSelectNode = null;
        for (const ouputConnections of connectionsParent.main) {
          for (const ouputConnection of ouputConnections) {
            if (ouputConnection.node === lastSelectedNode.name) {
              continue;
            }
            siblingNode = this.workflowsStore.getNodeByName(ouputConnection.node);
            if (siblingNode) {
              if (e.key === "ArrowUp") {
                if (siblingNode.position[1] <= lastSelectedNode.position[1] && siblingNode.position[1] > lastCheckedNodePosition) {
                  nextSelectNode = siblingNode.name;
                  lastCheckedNodePosition = siblingNode.position[1];
                }
              } else {
                if (siblingNode.position[1] >= lastSelectedNode.position[1] && siblingNode.position[1] < lastCheckedNodePosition) {
                  nextSelectNode = siblingNode.name;
                  lastCheckedNodePosition = siblingNode.position[1];
                }
              }
            }
          }
        }
        if (nextSelectNode !== null) {
          void this.callDebounced(
            this.nodeSelectedByName,
            { debounceTime: 100 },
            nextSelectNode,
            false,
            true
          );
        }
      }
    },
    toggleActivationNodes(nodes) {
      if (!this.editAllowedCheck()) {
        return;
      }
      this.nodeHelpers.disableNodes(nodes, { trackHistory: true, trackBulk: true });
    },
    togglePinNodes(nodes, source) {
      if (!this.editAllowedCheck()) {
        return;
      }
      this.historyStore.startRecordingUndo();
      const nextStatePinned = nodes.some(
        (node2) => !this.workflowsStore.pinDataByNodeName(node2.name)
      );
      for (const node2 of nodes) {
        const pinnedDataForNode = usePinnedData(node2);
        if (nextStatePinned) {
          const dataToPin = this.dataSchema.getInputDataWithPinned(node2);
          if (dataToPin.length !== 0) {
            pinnedDataForNode.setData(dataToPin, source);
          }
        } else {
          pinnedDataForNode.unsetData(source);
        }
      }
      this.historyStore.stopRecordingUndo();
    },
    deleteNodes(nodes) {
      this.historyStore.startRecordingUndo();
      nodes.forEach((node2) => {
        this.removeNode(node2.name, true, false);
      });
      setTimeout(() => {
        this.historyStore.stopRecordingUndo();
      }, 200);
    },
    selectAllNodes() {
      this.nodes.forEach((node2) => {
        this.nodeSelectedByName(node2.name);
      });
    },
    selectUpstreamNodes() {
      const lastSelectedNode = this.lastSelectedNode;
      if (lastSelectedNode === null) {
        return;
      }
      this.deselectAllNodes();
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "upstream",
        workflow,
        lastSelectedNode.name
      );
      for (const nodeName of checkNodes) {
        this.nodeSelectedByName(nodeName);
      }
      this.nodeSelectedByName(lastSelectedNode.name);
    },
    selectDownstreamNodes() {
      const lastSelectedNode = this.lastSelectedNode;
      if (lastSelectedNode === null) {
        return;
      }
      this.deselectAllNodes();
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "downstream",
        workflow,
        lastSelectedNode.name
      );
      for (const nodeName of checkNodes) {
        this.nodeSelectedByName(nodeName);
      }
      this.nodeSelectedByName(lastSelectedNode.name);
    },
    pushDownstreamNodes(sourceNodeName, margin, recordHistory = false) {
      const sourceNode = this.workflowsStore.nodesByName[sourceNodeName];
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const checkNodes = this.workflowHelpers.getConnectedNodes(
        "downstream",
        workflow,
        sourceNodeName
      );
      for (const nodeName of checkNodes) {
        const node2 = this.workflowsStore.nodesByName[nodeName];
        const oldPosition = node2.position;
        if (node2.position[0] < sourceNode.position[0]) {
          continue;
        }
        const updateInformation = {
          name: nodeName,
          properties: {
            position: [node2.position[0] + margin, node2.position[1]]
          }
        };
        this.workflowsStore.updateNodeProperties(updateInformation);
        this.onNodeMoved(node2);
        if (recordHistory && oldPosition[0] !== updateInformation.properties.position[0] || oldPosition[1] !== updateInformation.properties.position[1]) {
          this.historyStore.pushCommandToUndo(
            new MoveNodeCommand(nodeName, oldPosition, updateInformation.properties.position),
            recordHistory
          );
        }
      }
    },
    cutNodes(nodes) {
      const deleteCopiedNodes = !this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update);
      this.copyNodes(nodes, deleteCopiedNodes);
      if (deleteCopiedNodes) {
        this.deleteNodes(nodes);
      }
    },
    copyNodes(nodes, isCut = false) {
      void this.getNodesToSave(nodes).then((data) => {
        const workflowToCopy = {
          meta: {
            ...this.workflowsStore.workflow.meta,
            instanceId: this.rootStore.instanceId
          },
          ...data
        };
        delete workflowToCopy.meta.templateCredsSetupCompleted;
        this.workflowHelpers.removeForeignCredentialsFromWorkflow(
          workflowToCopy,
          this.credentialsStore.allCredentials
        );
        const nodeData = JSON.stringify(workflowToCopy, null, 2);
        void this.clipboard.copy(nodeData);
        if (data.nodes.length > 0) {
          if (!isCut) {
            this.showMessage({
              title: "Copied!",
              message: "",
              type: "success"
            });
          }
          this.$telemetry.track("User copied nodes", {
            node_types: data.nodes.map((node2) => node2.type),
            workflow_id: this.workflowsStore.workflowId
          });
        }
      });
    },
    async stopExecution() {
      const executionId = this.workflowsStore.activeExecutionId;
      if (executionId === null) {
        return;
      }
      try {
        this.stopExecutionInProgress = true;
        await this.executionsStore.stopCurrentExecution(executionId);
      } catch (error2) {
        const execution = await this.workflowsStore.getExecution(executionId);
        if (execution === void 0) {
          this.workflowsStore.finishActiveExecution({
            executionId,
            data: { finished: true, stoppedAt: /* @__PURE__ */ new Date() }
          });
          this.workflowsStore.executingNode.length = 0;
          this.uiStore.removeActiveAction("workflowRunning");
          this.workflowHelpers.setDocumentTitle(this.workflowsStore.workflowName, "IDLE");
          this.showMessage({
            title: this.$locale.baseText("nodeView.showMessage.stopExecutionCatch.unsaved.title"),
            message: this.$locale.baseText(
              "nodeView.showMessage.stopExecutionCatch.unsaved.message"
            ),
            type: "success"
          });
        } else if (execution == null ? void 0 : execution.finished) {
          const executedData = {
            data: execution.data,
            finished: execution.finished,
            mode: execution.mode,
            startedAt: execution.startedAt,
            stoppedAt: execution.stoppedAt
          };
          const pushData = {
            data: executedData,
            executionId,
            retryOf: execution.retryOf
          };
          this.workflowsStore.finishActiveExecution(pushData);
          this.workflowHelpers.setDocumentTitle(execution.workflowData.name, "IDLE");
          this.workflowsStore.executingNode.length = 0;
          this.workflowsStore.setWorkflowExecutionData(executedData);
          this.uiStore.removeActiveAction("workflowRunning");
          this.showMessage({
            title: this.$locale.baseText("nodeView.showMessage.stopExecutionCatch.title"),
            message: this.$locale.baseText("nodeView.showMessage.stopExecutionCatch.message"),
            type: "success"
          });
        } else {
          this.showError(error2, this.$locale.baseText("nodeView.showError.stopExecution.title"));
        }
      }
      this.stopExecutionInProgress = false;
      void this.workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const trackProps = {
          workflow_id: this.workflowsStore.workflowId,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              this.workflowHelpers.getNodeTypes(),
              { isCloudDeployment: this.settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        this.$telemetry.track("User clicked stop workflow execution", trackProps);
      });
    },
    async stopWaitingForWebhook() {
      try {
        await this.workflowsStore.removeTestWebhook(this.workflowsStore.workflowId);
      } catch (error2) {
        this.showError(
          error2,
          this.$locale.baseText("nodeView.showError.stopWaitingForWebhook.title")
        );
        return;
      }
    },
    /**
     * This method gets called when data got pasted into the window
     */
    async onClipboardPasteEvent(plainTextData) {
      if (this.readOnlyEnv || this.isReadOnlyRoute || !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
        return;
      }
      const currentTab = getNodeViewTab(this.$route);
      if (currentTab === MAIN_HEADER_TABS.WORKFLOW) {
        let workflowData;
        if (!this.editAllowedCheck()) {
          return;
        }
        if (plainTextData.match(VALID_WORKFLOW_IMPORT_URL_REGEX)) {
          if (!this.editAllowedCheck()) {
            return;
          }
          const importConfirm = await this.confirm(
            this.$locale.baseText("nodeView.confirmMessage.onClipboardPasteEvent.message", {
              interpolate: { plainTextData }
            }),
            this.$locale.baseText("nodeView.confirmMessage.onClipboardPasteEvent.headline"),
            {
              type: "warning",
              confirmButtonText: this.$locale.baseText(
                "nodeView.confirmMessage.onClipboardPasteEvent.confirmButtonText"
              ),
              cancelButtonText: this.$locale.baseText(
                "nodeView.confirmMessage.onClipboardPasteEvent.cancelButtonText"
              ),
              dangerouslyUseHTMLString: true
            }
          );
          if (importConfirm !== MODAL_CONFIRM) {
            return;
          }
          workflowData = await this.getWorkflowDataFromUrl(plainTextData);
          if (workflowData === void 0) {
            return;
          }
        } else {
          try {
            workflowData = JSON.parse(plainTextData);
            if (!this.editAllowedCheck()) {
              return;
            }
          } catch (e) {
            return;
          }
        }
        if (!workflowData) {
          return;
        }
        return await this.importWorkflowData(workflowData, "paste", false);
      }
    },
    // Returns the workflow data from a given URL. If no data gets found or
    // data is invalid it returns undefined and displays an error message by itself.
    async getWorkflowDataFromUrl(url) {
      let workflowData;
      this.canvasStore.startLoading();
      try {
        workflowData = await this.workflowsStore.getWorkflowFromUrl(url);
      } catch (error2) {
        this.canvasStore.stopLoading();
        this.showError(
          error2,
          this.$locale.baseText("nodeView.showError.getWorkflowDataFromUrl.title")
        );
        return;
      }
      this.canvasStore.stopLoading();
      return workflowData;
    },
    // Imports the given workflow data into the current workflow
    async importWorkflowData(workflowData, source, importTags = true) {
      if (!workflowData.hasOwnProperty("nodes") || !workflowData.hasOwnProperty("connections")) {
        return;
      }
      try {
        const nodeIdMap = {};
        if (workflowData.nodes) {
          const nodeNames = workflowData.nodes.map((node2) => node2.name);
          workflowData.nodes.forEach((node2) => {
            if (!node2.name) {
              const nodeType = this.nodeTypesStore.getNodeType(node2.type);
              const newName = this.uniqueNodeName((nodeType == null ? void 0 : nodeType.displayName) ?? node2.type, nodeNames);
              node2.name = newName;
              nodeNames.push(newName);
            }
            if (node2.webhookId && UPDATE_WEBHOOK_ID_NODE_TYPES.includes(node2.type)) {
              const isDuplicate = Object.values(
                this.workflowHelpers.getCurrentWorkflow().nodes
              ).some((n) => n.webhookId === node2.webhookId);
              if (isDuplicate) {
                node2.webhookId = v4();
              }
            }
            if (node2.id) {
              const newId2 = v4();
              nodeIdMap[newId2] = node2.id;
              node2.id = newId2;
            } else {
              node2.id = v4();
            }
          });
        }
        this.removeUnknownCredentials(workflowData);
        const currInstanceId = this.rootStore.instanceId;
        const nodeGraph = JSON.stringify(
          generateNodesGraph(
            workflowData,
            this.workflowHelpers.getNodeTypes(),
            {
              nodeIdMap,
              sourceInstanceId: workflowData.meta && workflowData.meta.instanceId !== currInstanceId ? workflowData.meta.instanceId : "",
              isCloudDeployment: this.settingsStore.isCloudDeployment
            }
          ).nodeGraph
        );
        if (source === "paste") {
          this.$telemetry.track("User pasted nodes", {
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        } else if (source === "duplicate") {
          this.$telemetry.track("User duplicated nodes", {
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        } else {
          this.$telemetry.track("User imported workflow", {
            source,
            workflow_id: this.workflowsStore.workflowId,
            node_graph_string: nodeGraph
          });
        }
        this.deselectAllNodes();
        this.workflowHelpers.updateNodePositions(
          workflowData,
          getNewNodePosition(this.nodes, this.lastClickPosition)
        );
        const data = await this.addNodesToWorkflow(workflowData);
        setTimeout(() => {
          ((data == null ? void 0 : data.nodes) ?? []).forEach((node2) => {
            this.nodeSelectedByName(node2.name);
          });
        });
        const tagsEnabled = this.settingsStore.areTagsEnabled;
        if (importTags && tagsEnabled && Array.isArray(workflowData.tags)) {
          const allTags = await this.tagsStore.fetchAll();
          const tagNames = new Set(allTags.map((tag) => tag.name));
          const workflowTags = workflowData.tags;
          const notFound = workflowTags.filter((tag) => !tagNames.has(tag.name));
          const creatingTagPromises = [];
          for (const tag of notFound) {
            const creationPromise = this.tagsStore.create(tag.name).then((tag2) => {
              allTags.push(tag2);
              return tag2;
            });
            creatingTagPromises.push(creationPromise);
          }
          await Promise.all(creatingTagPromises);
          const tagIds = workflowTags.reduce((accu, imported) => {
            const tag = allTags.find((tag2) => tag2.name === imported.name);
            if (tag) {
              accu.push(tag.id);
            }
            return accu;
          }, []);
          this.workflowsStore.addWorkflowTagIds(tagIds);
          setTimeout(() => {
            this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
          });
        }
      } catch (error2) {
        this.showError(error2, this.$locale.baseText("nodeView.showError.importWorkflowData.title"));
      }
    },
    removeUnknownCredentials(workflow) {
      if (!(workflow == null ? void 0 : workflow.nodes)) return;
      for (const node2 of workflow.nodes) {
        if (!node2.credentials) continue;
        for (const [name, credential] of Object.entries(node2.credentials)) {
          if (typeof credential === "string" || credential.id === null) continue;
          if (!this.credentialsStore.getCredentialById(credential.id)) {
            delete node2.credentials[name];
          }
        }
      }
    },
    onDragOver(event) {
      event.preventDefault();
    },
    async onDrop(event) {
      if (!event.dataTransfer) {
        return;
      }
      const dropData = jsonParse(
        event.dataTransfer.getData(DRAG_EVENT_DATA_KEY)
      );
      if (dropData) {
        const mousePosition = this.getMousePositionWithinNodeView(event);
        const insertNodePosition = [
          mousePosition[0] - NODE_SIZE / 2 + GRID_SIZE,
          mousePosition[1] - NODE_SIZE / 2
        ];
        await this.onAddNodes(dropData, true, insertNodePosition);
        this.createNodeActive = false;
      }
    },
    nodeDeselectedByName(nodeName) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeDeselected(node2);
      }
    },
    nodeSelectedByName(nodeName, setActive = false, deselectAllOthers) {
      if (deselectAllOthers === true) {
        this.deselectAllNodes();
      }
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeSelected(node2);
        this.uiStore.lastSelectedNode = node2.name;
        this.uiStore.lastSelectedNodeOutputIndex = null;
        this.uiStore.lastSelectedNodeEndpointUuid = null;
        this.canvasStore.newNodeInsertPosition = null;
        this.canvasStore.setLastSelectedConnection(void 0);
        if (setActive) {
          this.ndvStore.activeNodeName = node2.name;
        }
      }
    },
    showMaxNodeTypeError(nodeTypeData) {
      const maxNodes = nodeTypeData.maxNodes;
      this.showMessage({
        title: this.$locale.baseText("nodeView.showMessage.showMaxNodeTypeError.title"),
        message: this.$locale.baseText("nodeView.showMessage.showMaxNodeTypeError.message", {
          adjustToNumber: maxNodes,
          interpolate: { nodeTypeDataDisplayName: nodeTypeData.displayName }
        }),
        type: "error",
        duration: 0
      });
    },
    async getNewNodeWithDefaultCredential(nodeTypeData, overrides) {
      var _a, _b, _c, _d;
      let nodeVersion = nodeTypeData.defaultVersion;
      if (nodeVersion === void 0) {
        nodeVersion = Array.isArray(nodeTypeData.version) ? nodeTypeData.version.slice(-1)[0] : nodeTypeData.version;
      }
      const newNodeData = {
        id: v4(),
        name: overrides.name ?? nodeTypeData.defaults.name,
        type: nodeTypeData.name,
        typeVersion: nodeVersion,
        position: [0, 0],
        parameters: {}
      };
      const credentialPerType = (_a = nodeTypeData.credentials) == null ? void 0 : _a.map((type) => this.credentialsStore.getUsableCredentialByType(type.name)).flat();
      if (credentialPerType && credentialPerType.length === 1) {
        const defaultCredential = credentialPerType[0];
        const selectedCredentials = this.credentialsStore.getCredentialById(defaultCredential.id);
        const selected2 = { id: selectedCredentials.id, name: selectedCredentials.name };
        const credentials = {
          [defaultCredential.type]: selected2
        };
        await this.nodeHelpers.loadNodesProperties(
          [newNodeData].map((node2) => ({ name: node2.type, version: node2.typeVersion }))
        );
        const nodeType = this.nodeTypesStore.getNodeType(newNodeData.type, newNodeData.typeVersion);
        const nodeParameters = getNodeParameters(
          (nodeType == null ? void 0 : nodeType.properties) || [],
          {},
          true,
          false,
          newNodeData
        );
        if (nodeTypeData.credentials) {
          const authentication = nodeTypeData.credentials.find(
            (type) => type.name === defaultCredential.type
          );
          if ((_b = authentication == null ? void 0 : authentication.displayOptions) == null ? void 0 : _b.hide) {
            return newNodeData;
          }
          const authDisplayOptions = (_c = authentication == null ? void 0 : authentication.displayOptions) == null ? void 0 : _c.show;
          if (!authDisplayOptions) {
            newNodeData.credentials = credentials;
            return newNodeData;
          }
          if (Object.keys(authDisplayOptions).length === 1 && authDisplayOptions.authentication) {
            newNodeData.credentials = credentials;
            let parameters = {};
            for (const displayOption of Object.keys(authDisplayOptions)) {
              if (nodeParameters && !nodeParameters[displayOption]) {
                parameters = {};
                newNodeData.credentials = void 0;
                break;
              }
              const optionValue = (_d = authDisplayOptions[displayOption]) == null ? void 0 : _d[0];
              if (optionValue && typeof optionValue === "string") {
                parameters[displayOption] = optionValue;
              }
              newNodeData.parameters = {
                ...newNodeData.parameters,
                ...parameters
              };
            }
          }
        }
      }
      return newNodeData;
    },
    async injectNode(nodeTypeName, options = {}, showDetail = true, trackHistory = false, isAutoAdd = false) {
      var _a, _b;
      const nodeTypeData = this.nodeTypesStore.getNodeType(nodeTypeName);
      if (nodeTypeData === null) {
        this.showMessage({
          title: this.$locale.baseText("nodeView.showMessage.addNodeButton.title"),
          message: this.$locale.baseText("nodeView.showMessage.addNodeButton.message", {
            interpolate: { nodeTypeName }
          }),
          type: "error"
        });
        return;
      }
      if (nodeTypeData.maxNodes !== void 0 && this.workflowHelpers.getNodeTypeCount(nodeTypeName) >= nodeTypeData.maxNodes) {
        this.showMaxNodeTypeError(nodeTypeData);
        return;
      }
      const newNodeData = await this.getNewNodeWithDefaultCredential(nodeTypeData, {
        name: options.name
      });
      const lastSelectedNode = this.lastSelectedNode;
      if (options.position) {
        newNodeData.position = getNewNodePosition(
          this.canvasStore.getNodesWithPlaceholderNode(),
          options.position
        );
      } else if (lastSelectedNode) {
        const lastSelectedConnection = this.canvasStore.lastSelectedConnection;
        if (lastSelectedConnection) {
          const [diffX] = getConnectorLengths(lastSelectedConnection);
          if (diffX <= MAX_X_TO_PUSH_DOWNSTREAM_NODES) {
            this.pushDownstreamNodes(
              lastSelectedNode.name,
              PUSH_NODES_OFFSET,
              trackHistory
            );
          }
        }
        if (this.canvasStore.newNodeInsertPosition) {
          newNodeData.position = getNewNodePosition(this.nodes, [
            this.canvasStore.newNodeInsertPosition[0] + GRID_SIZE,
            this.canvasStore.newNodeInsertPosition[1] - NODE_SIZE / 2
          ]);
          this.canvasStore.newNodeInsertPosition = null;
        } else {
          let yOffset = 0;
          const workflow = this.workflowHelpers.getCurrentWorkflow();
          if (lastSelectedConnection) {
            const sourceNodeType = this.nodeTypesStore.getNodeType(
              lastSelectedNode.type,
              lastSelectedNode.typeVersion
            );
            if (sourceNodeType) {
              const sourceNodeOutputs = getNodeOutputs(
                workflow,
                lastSelectedNode,
                sourceNodeType
              );
              const sourceNodeOutputTypes = getConnectionTypes(sourceNodeOutputs);
              const sourceNodeOutputMainOutputs = sourceNodeOutputTypes.filter(
                (output) => output === NodeConnectionType.Main
              );
              if (sourceNodeOutputMainOutputs.length > 1) {
                const offset = generateOffsets(
                  sourceNodeOutputMainOutputs.length,
                  NODE_SIZE,
                  GRID_SIZE
                );
                const sourceOutputIndex = lastSelectedConnection.__meta ? lastSelectedConnection.__meta.sourceOutputIndex : 0;
                yOffset = offset[sourceOutputIndex];
              }
            }
          }
          let outputs2 = [];
          try {
            outputs2 = getNodeOutputs(workflow, newNodeData, nodeTypeData);
          } catch (e) {
          }
          const outputTypes = getConnectionTypes(outputs2);
          const lastSelectedNodeType = this.nodeTypesStore.getNodeType(
            lastSelectedNode.type,
            lastSelectedNode.typeVersion
          );
          const lastSelectedNodeWorkflow = workflow.getNode(lastSelectedNode.name);
          if (!lastSelectedNodeWorkflow || !lastSelectedNodeType) {
            console.error("Could not find last selected node or node type");
            return;
          }
          if (outputTypes.length > 0 && outputTypes.every((outputName) => outputName !== NodeConnectionType.Main)) {
            const lastSelectedInputs = getNodeInputs(
              workflow,
              lastSelectedNodeWorkflow,
              lastSelectedNodeType
            );
            const lastSelectedInputTypes = getConnectionTypes(lastSelectedInputs);
            const scopedConnectionIndex = (lastSelectedInputTypes || []).filter((input) => input !== NodeConnectionType.Main).findIndex((inputType) => outputs2[0] === inputType);
            newNodeData.position = getNewNodePosition(
              this.nodes,
              [
                lastSelectedNode.position[0] + NODE_SIZE / (Math.max(((_a = lastSelectedNodeType == null ? void 0 : lastSelectedNodeType.inputs) == null ? void 0 : _a.length) ?? 1), 1) * scopedConnectionIndex,
                lastSelectedNode.position[1] + PUSH_NODES_OFFSET
              ],
              [100, 0]
            );
          } else {
            const inputs2 = getNodeInputs(
              workflow,
              lastSelectedNode,
              lastSelectedNodeType
            );
            const inputsTypes = getConnectionTypes(inputs2);
            let pushOffset = PUSH_NODES_OFFSET;
            if (!!inputsTypes.find((input) => input !== NodeConnectionType.Main)) {
              pushOffset += 150;
            }
            newNodeData.position = getNewNodePosition(
              this.nodes,
              [lastSelectedNode.position[0] + pushOffset, lastSelectedNode.position[1] + yOffset],
              [100, 0]
            );
          }
        }
      } else {
        const position2 = this.nodeTypesStore.isTriggerNode(nodeTypeName) && !this.containsTrigger ? this.canvasStore.canvasAddButtonPosition : (
          // If no node is active find a free spot
          this.lastClickPosition
        );
        newNodeData.position = getNewNodePosition(this.nodes, position2);
      }
      const localizedName = this.locale.localizeNodeName(newNodeData.name, newNodeData.type);
      newNodeData.name = this.uniqueNodeName(localizedName);
      if ((_b = nodeTypeData.webhooks) == null ? void 0 : _b.length) {
        newNodeData.webhookId = v4();
      }
      await this.nodeHelpers.addNodes([newNodeData], void 0, trackHistory);
      this.workflowsStore.setNodePristine(newNodeData.name, true);
      this.uiStore.stateIsDirty = true;
      if (nodeTypeName === STICKY_NODE_TYPE) {
        this.$telemetry.trackNodesPanel("nodeView.addSticky", {
          workflow_id: this.workflowsStore.workflowId
        });
      } else {
        void this.externalHooks.run("nodeView.addNodeButton", { nodeTypeName });
        const trackProperties = {
          node_type: nodeTypeName,
          node_version: newNodeData.typeVersion,
          is_auto_add: isAutoAdd,
          workflow_id: this.workflowsStore.workflowId,
          drag_and_drop: options.dragAndDrop
        };
        if (lastSelectedNode) {
          trackProperties.input_node_type = lastSelectedNode.type;
        }
        this.$telemetry.trackNodesPanel("nodeView.addNodeButton", trackProperties);
      }
      if (trackHistory && !isAutoAdd) {
        this.deselectAllNodes();
        setTimeout(() => {
          this.nodeSelectedByName(
            newNodeData.name,
            showDetail && nodeTypeName !== STICKY_NODE_TYPE
          );
        });
      }
      return newNodeData;
    },
    getConnection(sourceNodeName, sourceNodeOutputIndex, targetNodeName, targetNodeOuputIndex, type) {
      const nodeConnections = this.workflowsStore.outgoingConnectionsByNodeName(sourceNodeName)[type];
      if (nodeConnections) {
        const connections2 = nodeConnections[sourceNodeOutputIndex];
        if (connections2) {
          return connections2.find(
            (connection) => connection.node === targetNodeName && connection.index === targetNodeOuputIndex
          );
        }
      }
      return void 0;
    },
    connectTwoNodes(sourceNodeName, sourceNodeOutputIndex, targetNodeName, targetNodeOutputIndex, type) {
      this.uiStore.stateIsDirty = true;
      const sourceNode = this.workflowsStore.getNodeByName(sourceNodeName);
      const targetNode = this.workflowsStore.getNodeByName(targetNodeName);
      if (sourceNode && targetNode && !this.checkNodeConnectionAllowed(sourceNode, targetNode, type)) {
        return;
      }
      if (this.getConnection(
        sourceNodeName,
        sourceNodeOutputIndex,
        targetNodeName,
        targetNodeOutputIndex,
        type
      )) {
        return;
      }
      const connectionData = [
        {
          node: sourceNodeName,
          type,
          index: sourceNodeOutputIndex
        },
        {
          node: targetNodeName,
          type,
          index: targetNodeOutputIndex
        }
      ];
      this.nodeHelpers.addConnection(connectionData);
    },
    async addNode(nodeTypeName, options = {}, showDetail = true, trackHistory = false, isAutoAdd = false) {
      var _a;
      if (!this.editAllowedCheck()) {
        return;
      }
      const lastSelectedNode = this.lastSelectedNode;
      const lastSelectedNodeOutputIndex = this.uiStore.lastSelectedNodeOutputIndex;
      const lastSelectedNodeEndpointUuid = this.uiStore.lastSelectedNodeEndpointUuid;
      const lastSelectedConnection = this.canvasStore.lastSelectedConnection;
      this.historyStore.startRecordingUndo();
      const newNodeData = await this.injectNode(
        nodeTypeName,
        options,
        showDetail,
        trackHistory,
        isAutoAdd
      );
      if (!newNodeData) {
        return;
      }
      const outputIndex = lastSelectedNodeOutputIndex || 0;
      const targetEndpoint = lastSelectedNodeEndpointUuid || "";
      if (lastSelectedNodeEndpointUuid && !isAutoAdd && lastSelectedNode) {
        const lastSelectedEndpoint = this.instance.getEndpoint(lastSelectedNodeEndpointUuid);
        if (lastSelectedEndpoint && this.checkNodeConnectionAllowed(
          lastSelectedNode,
          newNodeData,
          lastSelectedEndpoint.scope
        )) {
          const connectionType2 = lastSelectedEndpoint.scope;
          const newNodeElement = this.instance.getManagedElement(newNodeData.id);
          const newNodeConnections = this.instance.getEndpoints(newNodeElement);
          const viableConnection = newNodeConnections.find((conn) => {
            return conn.scope === connectionType2 && lastSelectedEndpoint.parameters.connection !== conn.parameters.connection;
          });
          (_a = this.instance) == null ? void 0 : _a.connect({
            uuids: [targetEndpoint, (viableConnection == null ? void 0 : viableConnection.uuid) || ""],
            detachable: !this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
          });
          this.historyStore.stopRecordingUndo();
          return;
        }
      }
      if (lastSelectedNode && !isAutoAdd) {
        await this.$nextTick();
        if (lastSelectedConnection == null ? void 0 : lastSelectedConnection.__meta) {
          this.nodeHelpers.deleteJSPlumbConnection(lastSelectedConnection, trackHistory);
          const targetNodeName = lastSelectedConnection.__meta.targetNodeName;
          const targetOutputIndex = lastSelectedConnection.__meta.targetOutputIndex;
          this.connectTwoNodes(
            newNodeData.name,
            0,
            targetNodeName,
            targetOutputIndex,
            NodeConnectionType.Main
          );
        }
        this.connectTwoNodes(
          lastSelectedNode.name,
          outputIndex,
          newNodeData.name,
          0,
          NodeConnectionType.Main
        );
      }
      this.historyStore.stopRecordingUndo();
    },
    getNodeCreatorFilter(nodeName, outputType) {
      let filter2;
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const workflowNode = workflow.getNode(nodeName);
      if (!workflowNode) return { nodes: [] };
      const nodeType = this.nodeTypesStore.getNodeType(
        workflowNode == null ? void 0 : workflowNode.type,
        workflowNode.typeVersion
      );
      if (nodeType) {
        const inputs2 = getNodeInputs(workflow, workflowNode, nodeType);
        const filterFound = inputs2.filter((input) => {
          if (typeof input === "string" || input.type !== outputType || !input.filter) {
            return false;
          }
          return true;
        });
        if (filterFound.length) {
          filter2 = filterFound[0].filter;
        }
      }
      return filter2;
    },
    insertNodeAfterSelected(info) {
      var _a, _b, _c;
      const type = info.outputType ?? NodeConnectionType.Main;
      const sourceNode = this.workflowsStore.getNodeById(info.sourceId);
      if (!sourceNode) {
        return;
      }
      this.uiStore.lastSelectedNode = sourceNode.name;
      this.uiStore.lastSelectedNodeEndpointUuid = info.endpointUuid ?? ((_b = (_a = info.connection) == null ? void 0 : _a.target.jtk) == null ? void 0 : _b.endpoint.uuid);
      this.uiStore.lastSelectedNodeOutputIndex = info.index;
      this.canvasStore.newNodeInsertPosition = null;
      if (info.connection) {
        this.canvasStore.setLastSelectedConnection(info.connection);
      }
      this.onToggleNodeCreator({
        source: info.eventSource,
        createNodeActive: true,
        nodeCreatorView: info.nodeCreatorView
      });
      const isOutput = ((_c = info.connection) == null ? void 0 : _c.endpoints[0].parameters.connection) === "source";
      const isScopedConnection = type !== NodeConnectionType.Main && nodeConnectionTypes.includes(type);
      if (isScopedConnection) {
        useViewStacks().gotoCompatibleConnectionView(
          type,
          isOutput,
          this.getNodeCreatorFilter(sourceNode.name, type)
        ).catch(() => {
        });
      }
    },
    async onEventConnectionAbort(connection) {
      var _a, _b;
      try {
        if (this.dropPrevented) {
          this.dropPrevented = false;
          return;
        }
        if (this.nodeHelpers.pullConnActiveNodeName.value) {
          const sourceNode = this.workflowsStore.getNodeById(connection.parameters.nodeId);
          const connectionType2 = connection.parameters.type ?? NodeConnectionType.Main;
          const overrideTargetEndpoint = (_a = connection == null ? void 0 : connection.connector) == null ? void 0 : _a.overrideTargetEndpoint;
          if (sourceNode) {
            const isTarget = connection.parameters.connection === "target";
            const sourceNodeName = isTarget ? this.nodeHelpers.pullConnActiveNodeName.value : sourceNode.name;
            const targetNodeName = isTarget ? sourceNode.name : this.nodeHelpers.pullConnActiveNodeName.value;
            const outputIndex = connection.parameters.index;
            resetConnectionAfterPull(connection);
            await this.$nextTick();
            this.connectTwoNodes(
              sourceNodeName,
              outputIndex,
              targetNodeName,
              ((_b = overrideTargetEndpoint == null ? void 0 : overrideTargetEndpoint.parameters) == null ? void 0 : _b.index) ?? 0,
              connectionType2
            );
            this.nodeHelpers.pullConnActiveNodeName.value = null;
            this.dropPrevented = false;
          }
          return;
        }
        this.insertNodeAfterSelected({
          sourceId: connection.parameters.nodeId,
          index: connection.parameters.index,
          eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_DROP,
          connection,
          outputType: connection.parameters.type
        });
      } catch (e) {
        console.error(e);
      }
    },
    checkNodeConnectionAllowed(sourceNode, targetNode, targetInfoType) {
      var _a;
      const targetNodeType = this.nodeTypesStore.getNodeType(
        targetNode.type,
        targetNode.typeVersion
      );
      if ((_a = targetNodeType == null ? void 0 : targetNodeType.inputs) == null ? void 0 : _a.length) {
        const workflow = this.workflowHelpers.getCurrentWorkflow();
        const workflowNode = workflow.getNode(targetNode.name);
        let inputs2 = [];
        if (targetNodeType && workflowNode) {
          inputs2 = getNodeInputs(workflow, workflowNode, targetNodeType);
        }
        for (const input of inputs2 || []) {
          if (typeof input === "string" || input.type !== targetInfoType || !input.filter) {
            continue;
          }
          if (input.filter.nodes.length) {
            if (!input.filter.nodes.includes(sourceNode.type)) {
              this.dropPrevented = true;
              this.showToast({
                title: this.$locale.baseText("nodeView.showError.nodeNodeCompatible.title"),
                message: this.$locale.baseText("nodeView.showError.nodeNodeCompatible.message", {
                  interpolate: { sourceNodeName: sourceNode.name, targetNodeName: targetNode.name }
                }),
                type: "error",
                duration: 5e3
              });
              return false;
            }
          }
        }
      }
      return true;
    },
    onInterceptBeforeDrop(info) {
      try {
        let sourceInfo;
        let targetInfo;
        if (info.connection.endpoints[0].parameters.connection === "target") {
          sourceInfo = info.dropEndpoint.parameters;
          targetInfo = info.connection.endpoints[0].parameters;
        } else {
          sourceInfo = info.connection.endpoints[0].parameters;
          targetInfo = info.dropEndpoint.parameters;
        }
        if (sourceInfo.type !== targetInfo.type || sourceInfo.connection === targetInfo.connection) {
          this.dropPrevented = true;
          return false;
        }
        const sourceNode = this.workflowsStore.getNodeById(sourceInfo.nodeId);
        const targetNode = this.workflowsStore.getNodeById(targetInfo.nodeId);
        const sourceNodeName = (sourceNode == null ? void 0 : sourceNode.name) || "";
        const targetNodeName = (targetNode == null ? void 0 : targetNode.name) || "";
        if (sourceNode && targetNode) {
          if (!this.checkNodeConnectionAllowed(sourceNode, targetNode, targetInfo.type)) {
            return false;
          }
        }
        if (this.getConnection(
          sourceNodeName,
          sourceInfo.index,
          targetNodeName,
          targetInfo.index,
          sourceInfo.type
        )) {
          this.dropPrevented = true;
          this.nodeHelpers.pullConnActiveNodeName.value = null;
          return false;
        }
        return true;
      } catch (e) {
        console.error(e);
        return true;
      }
    },
    onEventConnection(info) {
      var _a, _b;
      try {
        if (info.sourceEndpoint.parameters.connection === "target") {
          const tempEndpoint = info.sourceEndpoint;
          info.sourceEndpoint = info.targetEndpoint;
          info.targetEndpoint = tempEndpoint;
        }
        const sourceInfo = info.sourceEndpoint.parameters;
        const targetInfo = info.targetEndpoint.parameters;
        const sourceNodeName = (_a = this.workflowsStore.getNodeById(sourceInfo.nodeId)) == null ? void 0 : _a.name;
        const targetNodeName = (_b = this.workflowsStore.getNodeById(targetInfo.nodeId)) == null ? void 0 : _b.name;
        if (sourceNodeName && targetNodeName) {
          info.connection.__meta = {
            sourceNodeName,
            sourceOutputIndex: sourceInfo.index,
            targetNodeName,
            targetOutputIndex: targetInfo.index
          };
        }
        resetConnection(info.connection);
        moveBackInputLabelPosition(info.targetEndpoint);
        if (!sourceNodeName || !targetNodeName) {
          console.error("Could not find source or target node name");
          return;
        }
        const connectionData = [
          {
            node: sourceNodeName,
            type: sourceInfo.type,
            index: sourceInfo.index
          },
          {
            node: targetNodeName,
            type: targetInfo.type,
            index: targetInfo.index
          }
        ];
        this.dropPrevented = true;
        this.workflowsStore.addConnection({ connection: connectionData });
        if (!this.isReadOnlyRoute && !this.readOnlyEnv && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
          hideOutputNameLabel(info.sourceEndpoint);
          addConnectionActionsOverlay(
            info.connection,
            () => {
              this.activeConnection = null;
              this.nodeHelpers.deleteJSPlumbConnection(info.connection);
            },
            () => {
              this.insertNodeAfterSelected({
                sourceId: info.sourceEndpoint.parameters.nodeId,
                index: sourceInfo.index,
                connection: info.connection,
                eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION
              });
            }
          );
          const endpointArrow = getOverlay(
            info.connection,
            OVERLAY_ENDPOINT_ARROW_ID
          );
          if (sourceInfo.type !== NodeConnectionType.Main) {
            info.connection.setPaintStyle(
              getConnectorPaintStyleData(info.connection, info.sourceEndpoint.parameters.category)
            );
            endpointArrow == null ? void 0 : endpointArrow.setVisible(false);
          }
        }
        this.dropPrevented = false;
        if (!this.isLoading) {
          this.uiStore.stateIsDirty = true;
          if (!this.suspendRecordingDetachedConnections) {
            this.historyStore.pushCommandToUndo(new AddConnectionCommand(connectionData));
          }
          if (!this.nodeHelpers.isInsertingNodes.value) {
            this.nodeHelpers.updateNodesInputIssues();
            this.resetEndpointsErrors();
            setTimeout(() => {
              var _a2, _b2;
              addConnectionTestData(
                info.source,
                info.target,
                ((_b2 = (_a2 = info.connection) == null ? void 0 : _a2.connector) == null ? void 0 : _b2.hasOwnProperty("canvas")) ? info.connection.connector.canvas : void 0
              );
            }, 0);
          }
        }
      } catch (e) {
        console.error(e);
      }
    },
    onDragMove() {
      const totalNodes = this.nodes.length;
      void this.callDebounced(this.updateConnectionsOverlays, {
        debounceTime: totalNodes > 20 ? 200 : 0
      });
    },
    updateConnectionsOverlays() {
      var _a;
      (_a = this.instance) == null ? void 0 : _a.connections.forEach((connection) => {
        showOrHideItemsLabel(connection);
        showOrHideMidpointArrow(connection);
        Object.values(connection.overlays).forEach((overlay) => {
          var _a2;
          if (!overlay.canvas) return;
          (_a2 = this.instance) == null ? void 0 : _a2.repaint(overlay.canvas);
        });
      });
    },
    isConnectionActive(connection) {
      var _a, _b;
      if (!(connection == null ? void 0 : connection.id) || !((_a = this.activeConnection) == null ? void 0 : _a.id)) return false;
      return ((_b = this.activeConnection) == null ? void 0 : _b.id) === connection.id;
    },
    onConnectionMouseOver(connection) {
      try {
        if (this.exitTimer !== void 0) {
          clearTimeout(this.exitTimer);
          this.exitTimer = void 0;
        }
        if (
          // @ts-expect-error Deprecated file
          // eslint-disable-next-line no-constant-binary-expression
          !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
        )
          return;
        this.enterTimer = setTimeout(() => {
          if (this.activeConnection && !this.isConnectionActive(connection) && isJSPlumbConnection(this.activeConnection)) {
            hideConnectionActions(this.activeConnection);
          }
          this.enterTimer = void 0;
          if (connection) {
            showConnectionActions(connection);
            this.activeConnection = connection;
          }
        }, 150);
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionMouseOut(connection) {
      try {
        if (this.exitTimer) return;
        if (this.enterTimer) {
          clearTimeout(this.enterTimer);
          this.enterTimer = void 0;
        }
        if (
          // @ts-expect-error Deprecated file
          // eslint-disable-next-line no-constant-binary-expression
          !(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
        )
          return;
        this.exitTimer = setTimeout(() => {
          this.exitTimer = void 0;
          if (connection && this.isConnectionActive(connection) && isJSPlumbConnection(this.activeConnection)) {
            hideConnectionActions(this.activeConnection);
            this.activeConnection = null;
          }
        }, 500);
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionMoved(info) {
      var _a, _b;
      try {
        resetInputLabelPosition(info.connection);
        const sourceInfo = info.connection.parameters;
        const targetInfo = info.originalEndpoint.parameters;
        const connectionInfo = [
          {
            node: ((_a = this.workflowsStore.getNodeById(sourceInfo.nodeId)) == null ? void 0 : _a.name) || "",
            type: sourceInfo.type,
            index: sourceInfo.index
          },
          {
            node: ((_b = this.workflowsStore.getNodeById(targetInfo.nodeId)) == null ? void 0 : _b.name) || "",
            type: targetInfo.type,
            index: targetInfo.index
          }
        ];
        this.nodeHelpers.removeConnection(connectionInfo, false);
      } catch (e) {
        console.error(e);
      }
    },
    onEndpointMouseOver(endpoint, mouse) {
      if (!endpoint.isTarget || mouse.target !== endpoint.endpoint.canvas) return;
      this.instance.setHover(endpoint, true);
    },
    onEndpointMouseOut(endpoint) {
      if (!endpoint.isTarget) return;
      this.instance.setHover(endpoint, false);
    },
    async onConnectionDetached(info) {
      var _a;
      try {
        if (info.sourceEndpoint.parameters.connection === "target") {
          const tempEndpoint = info.sourceEndpoint;
          info.sourceEndpoint = info.targetEndpoint;
          info.targetEndpoint = tempEndpoint;
        }
        const connectionInfo = getConnectionInfo(info);
        resetInputLabelPosition(info.targetEndpoint);
        showOutputNameLabel(info.sourceEndpoint, info.connection);
        info.connection.removeOverlays();
        this.nodeHelpers.removeConnectionByConnectionInfo(info, false, false);
        if (this.nodeHelpers.pullConnActiveNodeName.value) {
          this.historyStore.startRecordingUndo();
          const sourceNode = this.workflowsStore.getNodeById(info.connection.parameters.nodeId);
          if (!sourceNode) {
            throw new Error("Could not find source node");
          }
          const sourceNodeName = sourceNode.name;
          const outputIndex = info.connection.parameters.index;
          const overrideTargetEndpoint = info.connection.connector.overrideTargetEndpoint;
          if (connectionInfo) {
            this.historyStore.pushCommandToUndo(new RemoveConnectionCommand(connectionInfo));
          }
          this.connectTwoNodes(
            sourceNodeName,
            outputIndex,
            this.nodeHelpers.pullConnActiveNodeName.value,
            ((_a = overrideTargetEndpoint == null ? void 0 : overrideTargetEndpoint.parameters) == null ? void 0 : _a.index) ?? 0,
            NodeConnectionType.Main
          );
          this.nodeHelpers.pullConnActiveNodeName.value = null;
          await this.$nextTick();
          this.historyStore.stopRecordingUndo();
        } else if (!this.historyStore.bulkInProgress && !this.suspendRecordingDetachedConnections && connectionInfo) {
          const removeCommand = new RemoveConnectionCommand(connectionInfo);
          this.historyStore.pushCommandToUndo(removeCommand);
        }
        void this.nodeHelpers.updateNodesInputIssues();
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionDrag(connection) {
      var _a;
      (_a = connection.overlays["midpoint-arrow"]) == null ? void 0 : _a.setVisible(false);
      try {
        this.nodeHelpers.pullConnActiveNodeName.value = null;
        this.pullConnActive = true;
        this.canvasStore.newNodeInsertPosition = null;
        hideConnectionActions(connection);
        resetConnection(connection);
        const scope = connection.scope;
        const scopedEndpoints = Array.from(
          document.querySelectorAll(`[data-jtk-scope-${scope}=true]`)
        );
        const connectionType2 = connection.parameters.connection;
        const requiredType = connectionType2 === "source" ? "target" : "source";
        const filteredEndpoints = scopedEndpoints.filter((el) => {
          if (!isJSPlumbEndpointElement(el)) return false;
          const endpoint = el.jtk.endpoint;
          if (!endpoint) return false;
          const isSameNode = endpoint.parameters.nodeId === connection.parameters.nodeId;
          const endpointType = endpoint.parameters.connection;
          return !isSameNode && endpointType === requiredType;
        });
        const onMouseMove = (e) => {
          if (!connection) {
            return;
          }
          const intersectingEndpoints = filteredEndpoints.filter((element) => {
            if (!isJSPlumbEndpointElement(element)) return false;
            const endpoint = element.jtk.endpoint;
            if (element.classList.contains("jtk-floating-endpoint")) {
              return false;
            }
            const isEndpointIntersect = isElementIntersection(element, e, 50);
            const isNodeElementIntersect = isElementIntersection(
              endpoint.element,
              e,
              30
            );
            if (isEndpointIntersect || isNodeElementIntersect) {
              const node2 = this.workflowsStore.getNodeById(endpoint.parameters.nodeId);
              if (node2) {
                const nodeType = this.nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
                if (!nodeType) return false;
                return true;
              }
            }
            return false;
          }).sort((a, b) => {
            const aEndpointIntersect = calculateElementIntersection(a, e, 50);
            const bEndpointIntersect = calculateElementIntersection(b, e, 50);
            if (!(aEndpointIntersect == null ? void 0 : aEndpointIntersect.y) && !(bEndpointIntersect == null ? void 0 : bEndpointIntersect.y)) {
              return 0;
            }
            if (!(aEndpointIntersect == null ? void 0 : aEndpointIntersect.y)) return 1;
            if (!(bEndpointIntersect == null ? void 0 : bEndpointIntersect.y)) return -1;
            return bEndpointIntersect.y - aEndpointIntersect.y;
          });
          if (intersectingEndpoints.length > 0 && isJSPlumbEndpointElement(intersectingEndpoints[0])) {
            const intersectingEndpoint = intersectingEndpoints[0];
            const endpoint = intersectingEndpoint.jtk.endpoint;
            const node2 = this.workflowsStore.getNodeById(endpoint.parameters.nodeId);
            this.nodeHelpers.pullConnActiveNodeName.value = (node2 == null ? void 0 : node2.name) ?? null;
            showDropConnectionState(connection, endpoint);
          } else {
            showPullConnectionState(connection);
            this.nodeHelpers.pullConnActiveNodeName.value = null;
          }
        };
        const onMouseUp = (e) => {
          this.pullConnActive = false;
          this.canvasStore.newNodeInsertPosition = this.getMousePositionWithinNodeView(e);
          resetConnectionAfterPull(connection);
          window.removeEventListener("mousemove", onMouseMove);
          window.removeEventListener("mouseup", onMouseUp);
          this.connectionDragScope = {
            type: null,
            connection: null
          };
        };
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("touchmove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
        window.addEventListener("touchend", onMouseMove);
        this.connectionDragScope = {
          type: connection.parameters.type,
          connection: connection.parameters.connection
        };
      } catch (e) {
        console.error(e);
      }
    },
    onConnectionDragAbortDetached() {
      var _a;
      Object.values((_a = this.instance) == null ? void 0 : _a.endpointsByElement).flatMap((endpoints) => Object.values(endpoints)).filter((endpoint) => endpoint.endpoint.type === "N8nPlus").forEach((endpoint) => setTimeout(() => endpoint.instance.revalidate(endpoint.element), 0));
    },
    onPlusEndpointClick(endpoint) {
      this.insertNodeAfterSelected({
        sourceId: endpoint.__meta.nodeId,
        index: endpoint.__meta.index,
        eventSource: NODE_CREATOR_OPEN_SOURCES.PLUS_ENDPOINT,
        outputType: getEndpointScope(endpoint.scope),
        endpointUuid: endpoint.uuid
      });
    },
    onAddInputEndpointClick(endpoint) {
      if (endpoint == null ? void 0 : endpoint.__meta) {
        this.insertNodeAfterSelected({
          sourceId: endpoint.__meta.nodeId,
          index: endpoint.__meta.index,
          eventSource: NODE_CREATOR_OPEN_SOURCES.ADD_INPUT_ENDPOINT,
          nodeCreatorView: AI_NODE_CREATOR_VIEW,
          outputType: getEndpointScope(endpoint.scope),
          endpointUuid: endpoint.uuid
        });
      }
    },
    bindCanvasEvents() {
      if (this.eventsAttached) return;
      this.instance.bind(EVENT_CONNECTION_ABORT, this.onEventConnectionAbort);
      this.instance.bind(INTERCEPT_BEFORE_DROP, this.onInterceptBeforeDrop);
      this.instance.bind(EVENT_CONNECTION, this.onEventConnection);
      this.instance.bind(EVENT_DRAG_MOVE, this.onDragMove);
      this.instance.bind(EVENT_CONNECTION_MOUSEOVER, this.onConnectionMouseOver);
      this.instance.bind(EVENT_CONNECTION_MOUSEOUT, this.onConnectionMouseOut);
      this.instance.bind(EVENT_CONNECTION_MOVED, this.onConnectionMoved);
      this.instance.bind(EVENT_ENDPOINT_MOUSEOVER, this.onEndpointMouseOver);
      this.instance.bind(EVENT_ENDPOINT_MOUSEOUT, this.onEndpointMouseOut);
      this.instance.bind(EVENT_CONNECTION_DETACHED, this.onConnectionDetached);
      this.instance.bind(EVENT_CONNECTION_DRAG, this.onConnectionDrag);
      this.instance.bind(
        [EVENT_CONNECTION_DRAG, EVENT_CONNECTION_ABORT, EVENT_CONNECTION_DETACHED],
        this.onConnectionDragAbortDetached
      );
      this.instance.bind(EVENT_PLUS_ENDPOINT_CLICK, this.onPlusEndpointClick);
      this.instance.bind(EVENT_ADD_INPUT_ENDPOINT_CLICK, this.onAddInputEndpointClick);
      this.eventsAttached = true;
    },
    unbindCanvasEvents() {
      this.instance.unbind(EVENT_CONNECTION_ABORT, this.onEventConnectionAbort);
      this.instance.unbind(INTERCEPT_BEFORE_DROP, this.onInterceptBeforeDrop);
      this.instance.unbind(EVENT_CONNECTION, this.onEventConnection);
      this.instance.unbind(EVENT_DRAG_MOVE, this.onDragMove);
      this.instance.unbind(EVENT_CONNECTION_MOUSEOVER, this.onConnectionMouseOver);
      this.instance.unbind(EVENT_CONNECTION_MOUSEOUT, this.onConnectionMouseOut);
      this.instance.unbind(EVENT_CONNECTION_MOVED, this.onConnectionMoved);
      this.instance.unbind(EVENT_ENDPOINT_MOUSEOVER, this.onEndpointMouseOver);
      this.instance.unbind(EVENT_ENDPOINT_MOUSEOUT, this.onEndpointMouseOut);
      this.instance.unbind(EVENT_CONNECTION_DETACHED, this.onConnectionDetached);
      this.instance.unbind(EVENT_CONNECTION_DRAG, this.onConnectionDrag);
      this.instance.unbind(EVENT_CONNECTION_DRAG, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_CONNECTION_ABORT, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_CONNECTION_DETACHED, this.onConnectionDragAbortDetached);
      this.instance.unbind(EVENT_PLUS_ENDPOINT_CLICK, this.onPlusEndpointClick);
      this.instance.unbind(EVENT_ADD_INPUT_ENDPOINT_CLICK, this.onAddInputEndpointClick);
      this.eventsAttached = false;
    },
    unbindEndpointEventListeners() {
      if (this.instance) {
        const elements = this.instance.getManagedElements();
        for (const element of Object.values(elements)) {
          const endpoints = element.endpoints;
          for (const endpoint of endpoints || []) {
            const endpointInstance = endpoint == null ? void 0 : endpoint.endpoint;
            if (endpointInstance && endpointInstance.type === N8nPlusEndpointType) {
              endpointInstance.unbindEvents();
            }
          }
        }
      }
      this.eventsAttached = false;
    },
    makeNewWorkflowShareable() {
      const { currentProject, personalProject } = this.projectsStore;
      const homeProject = currentProject ?? personalProject ?? {};
      const scopes = (currentProject == null ? void 0 : currentProject.scopes) ?? (personalProject == null ? void 0 : personalProject.scopes) ?? [];
      this.workflowsStore.workflow.homeProject = homeProject;
      this.workflowsStore.workflow.scopes = scopes;
    },
    async newWorkflow() {
      const { getVariant } = usePostHog();
      this.canvasStore.startLoading();
      this.resetWorkspace();
      this.workflowData = await this.workflowsStore.getNewWorkflowData(
        void 0,
        this.projectsStore.currentProjectId
      );
      this.workflowsStore.currentWorkflowExecutions = [];
      this.executionsStore.activeExecution = null;
      this.uiStore.stateIsDirty = false;
      this.canvasStore.setZoomLevel(1, [0, 0]);
      this.canvasStore.zoomToFit();
      this.uiStore.nodeViewInitialized = true;
      this.historyStore.reset();
      this.executionsStore.activeExecution = null;
      this.makeNewWorkflowShareable();
      this.canvasStore.stopLoading();
      if (getVariant(CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT.name) === CANVAS_AUTO_ADD_MANUAL_TRIGGER_EXPERIMENT.variant) {
        const manualTriggerNode = this.canvasStore.getAutoAddManualTriggerNode();
        if (manualTriggerNode) {
          await this.nodeHelpers.addNodes([manualTriggerNode]);
          this.uiStore.lastSelectedNode = manualTriggerNode.name;
        }
      }
    },
    async initView() {
      var _a, _b;
      await this.loadCredentialsForWorkflow();
      if (this.$route.params.action === "workflowSave") {
        this.uiStore.stateIsDirty = false;
        return;
      }
      if (this.blankRedirect) {
        this.blankRedirect = false;
      } else if (this.$route.name === VIEWS.TEMPLATE_IMPORT) {
        const templateId = this.$route.params.id;
        await this.openWorkflowTemplate(templateId.toString());
      } else {
        if (this.uiStore.stateIsDirty && !this.readOnlyEnv && !this.isReadOnlyRoute && (this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
          const confirmModal = await this.confirm(
            this.$locale.baseText("generic.unsavedWork.confirmMessage.message"),
            {
              title: this.$locale.baseText("generic.unsavedWork.confirmMessage.headline"),
              type: "warning",
              confirmButtonText: this.$locale.baseText(
                "generic.unsavedWork.confirmMessage.confirmButtonText"
              ),
              cancelButtonText: this.$locale.baseText(
                "generic.unsavedWork.confirmMessage.cancelButtonText"
              ),
              showClose: true
            }
          );
          if (confirmModal === MODAL_CONFIRM) {
            const saved = await this.workflowHelpers.saveCurrentWorkflow();
            if (saved) await this.npsSurveyStore.fetchPromptsData();
          } else if (confirmModal === MODAL_CANCEL) {
            return;
          }
        }
        let workflowId = null;
        if (this.$route.params.name) {
          workflowId = this.$route.params.name.toString();
        }
        if (workflowId !== null) {
          let workflow = void 0;
          try {
            workflow = await this.workflowsStore.fetchWorkflow(workflowId);
          } catch (error2) {
            this.showError(error2, this.$locale.baseText("openWorkflow.workflowNotFoundError"));
            void this.$router.push({
              name: VIEWS.NEW_WORKFLOW
            });
          }
          if (workflow) {
            this.workflowHelpers.setDocumentTitle(workflow.name, "IDLE");
            await this.openWorkflow(workflow);
            await this.checkAndInitDebugMode();
            await this.projectsStore.setProjectNavActiveIdByWorkflowHomeProject(
              workflow.homeProject
            );
            if ((_a = workflow.meta) == null ? void 0 : _a.onboardingId) {
              this.$telemetry.track(
                `User opened workflow from onboarding template with ID ${workflow.meta.onboardingId}`,
                {
                  workflow_id: workflow.id
                },
                {
                  withPostHog: true
                }
              );
            }
          }
        } else if (((_b = this.$route.meta) == null ? void 0 : _b.nodeView) === true) {
          await this.newWorkflow();
        }
      }
      this.historyStore.reset();
      if (!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)) {
        this.canvasStore.setReadOnly(true);
      }
      this.uiStore.nodeViewInitialized = true;
      document.addEventListener("keydown", this.keyDown);
      document.addEventListener("keyup", this.keyUp);
      this.showNotificationForViews([VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW]);
    },
    async duplicateNodes(nodes) {
      if (!this.editAllowedCheck()) {
        return;
      }
      const workflowData = deepCopy(await this.getNodesToSave(nodes));
      await this.importWorkflowData(workflowData, "duplicate", false);
    },
    getIncomingOutgoingConnections(nodeName) {
      var _a, _b;
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        const nodeEl = document.getElementById(node2.id);
        if (!nodeEl) {
          return { incoming: [], outgoing: [] };
        }
        const outgoing = (_a = this.instance) == null ? void 0 : _a.getConnections({
          source: nodeEl
        });
        const incoming = (_b = this.instance) == null ? void 0 : _b.getConnections({
          target: nodeEl
        });
        return {
          incoming: Array.isArray(incoming) ? incoming : Object.values(incoming),
          outgoing: Array.isArray(outgoing) ? outgoing : Object.values(outgoing)
        };
      }
      return { incoming: [], outgoing: [] };
    },
    onNodeMoved(node2) {
      const { incoming, outgoing } = this.getIncomingOutgoingConnections(node2.name);
      [...incoming, ...outgoing].forEach((connection) => {
        showOrHideMidpointArrow(connection);
        showOrHideItemsLabel(connection);
      });
    },
    onNodeRun({
      name,
      data,
      waiting: waiting2
    }) {
      var _a;
      const pinData = this.workflowsStore.pinnedWorkflowData;
      if (pinData == null ? void 0 : pinData[name]) {
        const { outgoing } = this.getIncomingOutgoingConnections(name);
        outgoing.forEach((connection) => {
          var _a2;
          if (((_a2 = connection.__meta) == null ? void 0 : _a2.sourceNodeName) === name) {
            const hasRun = this.workflowsStore.getWorkflowResultDataByNodeName(name) !== null;
            addClassesToOverlays({
              connection,
              overlayIds: [OVERLAY_RUN_ITEMS_ID],
              classNames: hasRun ? ["has-run"] : [],
              includeConnector: true
            });
          }
        });
        return;
      }
      const sourceNodeName = name;
      const sourceNode = this.workflowsStore.getNodeByName(sourceNodeName);
      const sourceId = sourceNode !== null ? sourceNode.id : "";
      if (data === null || data.length === 0 || waiting2) {
        const sourceElement = document.getElementById(sourceId);
        if (!sourceElement) {
          return;
        }
        const outgoing = (_a = this.instance) == null ? void 0 : _a.getConnections({
          source: sourceElement
        });
        (Array.isArray(outgoing) ? outgoing : Object.values(outgoing)).forEach(
          (connection) => {
            resetConnection(connection);
          }
        );
        const endpoints = getJSPlumbEndpoints(sourceNode, this.instance);
        endpoints.forEach((endpoint) => {
          if (endpoint.endpoint.type === "N8nPlus") {
            endpoint.endpoint.clearSuccessOutput();
          }
        });
        return;
      }
      this.nodeHelpers.setSuccessOutput(data, sourceNode);
    },
    removeNode(nodeName, trackHistory = false, trackBulk = true) {
      if (!this.editAllowedCheck()) {
        return;
      }
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (!node2) {
        return;
      }
      if (trackHistory && trackBulk) {
        this.historyStore.startRecordingUndo();
      }
      const requiredNodeTypes = [];
      if (requiredNodeTypes.includes(node2.type)) {
        let deleteAllowed = false;
        for (const checkNode of this.nodes) {
          if (checkNode.name === node2.name) {
            continue;
          }
          if (requiredNodeTypes.includes(checkNode.type)) {
            deleteAllowed = true;
            break;
          }
        }
        if (!deleteAllowed) {
          return;
        }
      }
      if (node2.type === STICKY_NODE_TYPE) {
        this.$telemetry.track("User deleted workflow note", {
          workflow_id: this.workflowsStore.workflowId,
          is_welcome_note: node2.name === QUICKSTART_NOTE_NAME
        });
      } else {
        void this.externalHooks.run("node.deleteNode", { node: node2 });
        this.$telemetry.track("User deleted node", {
          node_type: node2.type,
          workflow_id: this.workflowsStore.workflowId
        });
      }
      let waitForNewConnection = false;
      const nodeType = this.nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const workflowNode = workflow.getNode(node2.name);
      let inputs2 = [];
      let outputs2 = [];
      if (nodeType && workflowNode) {
        inputs2 = getNodeInputs(workflow, workflowNode, nodeType);
        outputs2 = getNodeOutputs(workflow, workflowNode, nodeType);
      }
      if (outputs2.length === 1 && inputs2.length === 1) {
        const { incoming, outgoing } = this.getIncomingOutgoingConnections(node2.name);
        if (incoming.length === 1 && outgoing.length === 1) {
          const conn1 = incoming[0];
          const conn2 = outgoing[0];
          if (conn1.__meta && conn2.__meta) {
            waitForNewConnection = true;
            const sourceNodeName = conn1.__meta.sourceNodeName;
            const sourceNodeOutputIndex = conn1.__meta.sourceOutputIndex;
            const targetNodeName = conn2.__meta.targetNodeName;
            const targetNodeOuputIndex = conn2.__meta.targetOutputIndex;
            setTimeout(() => {
              var _a;
              this.connectTwoNodes(
                sourceNodeName,
                sourceNodeOutputIndex,
                targetNodeName,
                targetNodeOuputIndex,
                NodeConnectionType.Main
              );
              if (waitForNewConnection) {
                (_a = this.instance) == null ? void 0 : _a.setSuspendDrawing(false, true);
                waitForNewConnection = false;
              }
            }, 100);
          }
        }
      }
      void nextTick(() => {
        var _a, _b, _c;
        (_a = this.instance) == null ? void 0 : _a.setSuspendDrawing(true);
        (((_b = this.instance) == null ? void 0 : _b.endpointsByElement[node2.id]) || []).flat().forEach((endpoint) => {
          var _a2;
          return (_a2 = this.instance) == null ? void 0 : _a2.deleteEndpoint(endpoint);
        });
        this.workflowsStore.removeAllNodeConnection(node2);
        this.workflowsStore.removeNode(node2);
        this.workflowsStore.clearNodeExecutionData(node2.name);
        if (!waitForNewConnection) {
          (_c = this.instance) == null ? void 0 : _c.setSuspendDrawing(false, true);
        }
        this.uiStore.removeNodeFromSelection(node2);
        if (trackHistory) {
          this.historyStore.pushCommandToUndo(new RemoveNodeCommand(node2));
        }
      });
      if (trackHistory && trackBulk) {
        const recordingTimeout = waitForNewConnection ? 100 : 0;
        setTimeout(() => {
          this.historyStore.stopRecordingUndo();
        }, recordingTimeout);
      }
    },
    async onSwitchSelectedNode(nodeName) {
      this.nodeSelectedByName(nodeName, true, true);
    },
    async onOpenConnectionNodeCreator(node2, connectionType2) {
      await this.openSelectiveNodeCreator({
        connectiontype: connectionType2,
        node: node2
      });
    },
    async redrawNode(nodeName) {
      const tempName = "x____XXXX____x";
      await this.renameNode(nodeName, tempName);
      await this.renameNode(tempName, nodeName);
    },
    valueChanged(parameterData) {
      if (parameterData.name === "name" && parameterData.oldValue) {
        void this.renameNode(parameterData.oldValue, parameterData.value);
      }
    },
    async renameNodePrompt(currentName) {
      try {
        const promptResponsePromise = this.prompt(
          this.$locale.baseText("nodeView.prompt.newName") + ":",
          this.$locale.baseText("nodeView.prompt.renameNode") + `: ${currentName}`,
          {
            customClass: "rename-prompt",
            confirmButtonText: this.$locale.baseText("nodeView.prompt.rename"),
            cancelButtonText: this.$locale.baseText("nodeView.prompt.cancel"),
            inputErrorMessage: this.$locale.baseText("nodeView.prompt.invalidName"),
            inputValue: currentName,
            inputValidator: (value) => {
              if (!value.trim()) {
                return this.$locale.baseText("nodeView.prompt.invalidName");
              }
              return true;
            }
          }
        );
        await this.$nextTick();
        const nameInput = document.querySelector(".rename-prompt .el-input__inner");
        if (nameInput) {
          nameInput.focus();
          nameInput.select();
        }
        const promptResponse = await promptResponsePromise;
        if ((promptResponse == null ? void 0 : promptResponse.action) !== MODAL_CONFIRM) {
          return;
        }
        await this.renameNode(currentName, promptResponse.value, true);
      } catch (e) {
      }
    },
    async renameNode(currentName, newName, trackHistory = false) {
      var _a;
      if (currentName === newName) {
        return;
      }
      this.suspendRecordingDetachedConnections = true;
      if (trackHistory) {
        this.historyStore.startRecordingUndo();
      }
      const activeNodeName = (_a = this.activeNode) == null ? void 0 : _a.name;
      const isActive = activeNodeName === currentName;
      if (isActive) {
        this.renamingActive = true;
      }
      newName = this.uniqueNodeName(newName);
      const workflow = this.workflowHelpers.getCurrentWorkflow(true);
      workflow.renameNode(currentName, newName);
      if (trackHistory) {
        this.historyStore.pushCommandToUndo(new RenameNodeCommand(currentName, newName));
      }
      this.workflowsStore.renameNodeSelectedAndExecution({ old: currentName, new: newName });
      this.deleteEveryEndpoint();
      this.workflowsStore.removeAllConnections({ setStateDirty: false });
      this.workflowsStore.removeAllNodes({ removePinData: false, setStateDirty: true });
      await this.$nextTick();
      await this.nodeHelpers.addNodes(
        Object.values(workflow.nodes),
        workflow.connectionsBySourceNode,
        false
      );
      this.deselectAllNodes();
      this.nodeSelectedByName(newName);
      if (isActive) {
        this.ndvStore.activeNodeName = newName;
        this.renamingActive = false;
      }
      if (trackHistory) {
        this.historyStore.stopRecordingUndo();
      }
      this.suspendRecordingDetachedConnections = false;
    },
    deleteEveryEndpoint() {
      var _a, _b;
      if (this.instance) {
        (_a = this.instance) == null ? void 0 : _a.reset();
        Object.values((_b = this.instance) == null ? void 0 : _b.endpointsByElement).flatMap((endpoint) => endpoint).forEach((endpoint) => endpoint.destroy());
        this.instance.deleteEveryConnection({ fireEvent: true });
      }
    },
    async addNodesToWorkflow(data) {
      const nodeNameTable = {};
      const newNodeNames = [];
      if (!data.nodes) {
        throw new Error(this.$locale.baseText("nodeView.noNodesGivenToAdd"));
      }
      const nodeTypesCount = this.workflowHelpers.getNodeTypesMaxCount();
      let oldName;
      let newName;
      const createNodes = [];
      await this.nodeHelpers.loadNodesProperties(
        data.nodes.map((node2) => ({ name: node2.type, version: node2.typeVersion }))
      );
      data.nodes.forEach((node2) => {
        if (nodeTypesCount[node2.type] !== void 0) {
          if (nodeTypesCount[node2.type].exist >= nodeTypesCount[node2.type].max) {
            nodeNameTable[node2.name] = nodeTypesCount[node2.type].nodeNames[0];
            return;
          } else {
            nodeTypesCount[node2.type].exist += 1;
          }
        }
        oldName = node2.name;
        const localized = this.locale.localizeNodeName(node2.name, node2.type);
        newName = this.uniqueNodeName(localized, newNodeNames);
        newNodeNames.push(newName);
        nodeNameTable[oldName] = newName;
        createNodes.push(node2);
      });
      const newConnections = {};
      const currentConnections = data.connections;
      const createNodeNames = createNodes.map((node2) => node2.name);
      let sourceNode, type, sourceIndex, connectionIndex, connectionData;
      for (sourceNode of Object.keys(currentConnections)) {
        if (!createNodeNames.includes(sourceNode)) {
          continue;
        }
        const connection = {};
        for (type of Object.keys(currentConnections[sourceNode])) {
          connection[type] = [];
          for (sourceIndex = 0; sourceIndex < currentConnections[sourceNode][type].length; sourceIndex++) {
            const nodeSourceConnections = [];
            if (currentConnections[sourceNode][type][sourceIndex]) {
              for (connectionIndex = 0; connectionIndex < currentConnections[sourceNode][type][sourceIndex].length; connectionIndex++) {
                connectionData = currentConnections[sourceNode][type][sourceIndex][connectionIndex];
                if (!createNodeNames.includes(connectionData.node)) {
                  continue;
                }
                nodeSourceConnections.push(connectionData);
              }
            }
            connection[type].push(nodeSourceConnections);
          }
        }
        newConnections[sourceNode] = connection;
      }
      const tempWorkflow = this.workflowHelpers.getWorkflow(createNodes, newConnections);
      for (oldName in nodeNameTable) {
        if (oldName === nodeNameTable[oldName]) {
          continue;
        }
        tempWorkflow.renameNode(oldName, nodeNameTable[oldName]);
      }
      if (data.pinData) {
        let pinDataSuccess = true;
        for (const nodeName of Object.keys(data.pinData)) {
          if (!pinDataSuccess) {
            this.showError(
              new Error(this.$locale.baseText("ndv.pinData.error.tooLarge.description")),
              this.$locale.baseText("ndv.pinData.error.tooLarge.title")
            );
            continue;
          }
          const node2 = tempWorkflow.nodes[nodeNameTable[nodeName]];
          try {
            const pinnedDataForNode = usePinnedData(node2);
            pinnedDataForNode.setData(data.pinData[nodeName], "add-nodes");
            pinDataSuccess = true;
          } catch (error2) {
            pinDataSuccess = false;
            console.error(error2);
          }
        }
      }
      this.historyStore.startRecordingUndo();
      await this.nodeHelpers.addNodes(
        Object.values(tempWorkflow.nodes),
        tempWorkflow.connectionsBySourceNode,
        true
      );
      this.historyStore.stopRecordingUndo();
      this.uiStore.stateIsDirty = true;
      return {
        nodes: Object.values(tempWorkflow.nodes),
        connections: tempWorkflow.connectionsBySourceNode
      };
    },
    async getNodesToSave(nodes) {
      const data = {
        nodes: [],
        connections: {},
        pinData: {}
      };
      let nodeData;
      const exportNodeNames = [];
      for (const node2 of nodes) {
        nodeData = this.workflowHelpers.getNodeDataToSave(node2);
        exportNodeNames.push(node2.name);
        data.nodes.push(nodeData);
        const pinDataForNode = this.workflowsStore.pinDataByNodeName(node2.name);
        if (pinDataForNode) {
          data.pinData[node2.name] = pinDataForNode;
        }
        if (nodeData.credentials && this.settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]) {
          const usedCredentials = this.workflowsStore.usedCredentials;
          nodeData.credentials = Object.fromEntries(
            Object.entries(nodeData.credentials).filter(([_, credential]) => {
              var _a;
              return credential.id && (!usedCredentials[credential.id] || ((_a = usedCredentials[credential.id]) == null ? void 0 : _a.currentUserHasAccess));
            })
          );
        }
      }
      let connectionToKeep, connections2, type, connectionIndex, sourceIndex, connectionData, typeConnections;
      data.nodes.forEach((node2) => {
        connections2 = this.workflowsStore.outgoingConnectionsByNodeName(node2.name);
        if (Object.keys(connections2).length === 0) {
          return;
        }
        typeConnections = {};
        for (type of Object.keys(connections2)) {
          for (sourceIndex = 0; sourceIndex < connections2[type].length; sourceIndex++) {
            connectionToKeep = [];
            for (connectionIndex = 0; connectionIndex < connections2[type][sourceIndex].length; connectionIndex++) {
              connectionData = connections2[type][sourceIndex][connectionIndex];
              if (exportNodeNames.indexOf(connectionData.node) !== -1) {
                connectionToKeep.push(connectionData);
              }
            }
            if (connectionToKeep.length) {
              if (!typeConnections.hasOwnProperty(type)) {
                typeConnections[type] = [];
              }
              typeConnections[type][sourceIndex] = connectionToKeep;
            }
          }
        }
        if (Object.keys(typeConnections).length) {
          data.connections[node2.name] = typeConnections;
        }
      });
      return data;
    },
    resetWorkspace() {
      this.workflowsStore.resetWorkflow();
      this.onToggleNodeCreator({ createNodeActive: false });
      this.nodeCreatorStore.setShowScrim(false);
      this.canvasStore.resetZoom();
      this.unbindEndpointEventListeners();
      this.deleteEveryEndpoint();
      if (this.executionWaitingForWebhook) {
        try {
          void this.workflowsStore.removeTestWebhook(this.workflowsStore.workflowId);
        } catch (error2) {
        }
      }
      this.workflowsStore.resetState();
      this.uiStore.removeActiveAction("workflowRunning");
      this.uiStore.resetSelectedNodes();
      this.uiStore.nodeViewOffsetPosition = [0, 0];
      this.nodeHelpers.credentialsUpdated.value = false;
    },
    async loadActiveWorkflows() {
      await this.workflowsStore.fetchActiveWorkflows();
    },
    async loadNodeTypes() {
      await this.nodeTypesStore.getNodeTypes();
    },
    async loadCredentialTypes() {
      await this.credentialsStore.fetchCredentialTypes(true);
    },
    async loadCredentialsForWorkflow() {
      var _a, _b, _c;
      if (this.settingsStore.isPreviewMode) {
        return;
      }
      const workflow = this.workflowsStore.getWorkflowById(this.currentWorkflow);
      const workflowId = (workflow == null ? void 0 : workflow.id) ?? this.$route.params.name;
      let options;
      if (workflowId) {
        options = { workflowId };
      } else {
        const queryParam = typeof ((_a = this.$route.query) == null ? void 0 : _a.projectId) === "string" ? (_b = this.$route.query) == null ? void 0 : _b.projectId : void 0;
        const projectId = queryParam ?? ((_c = this.projectsStore.personalProject) == null ? void 0 : _c.id);
        if (projectId === void 0) {
          throw new Error(
            "Could not find projectId in the query nor could I find the personal project in the project store"
          );
        }
        options = { projectId };
      }
      await this.credentialsStore.fetchAllCredentialsForWorkflow(options);
    },
    async loadVariables() {
      await this.environmentsStore.fetchAllVariables();
    },
    async loadSecrets() {
      await this.externalSecretsStore.fetchAllSecrets();
    },
    async onPostMessageReceived(message) {
      var _a, _b;
      if (!message || typeof message.data !== "string" || !((_b = (_a = message.data) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, '"command"'))) {
        return;
      }
      try {
        const json = JSON.parse(message.data);
        if (json && json.command === "openWorkflow") {
          try {
            await this.importWorkflowExact(json);
            this.canOpenNDV = json.canOpenNDV ?? true;
            this.hideNodeIssues = json.hideNodeIssues ?? false;
            this.isExecutionPreview = false;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: this.$locale.baseText("openWorkflow.workflowImportError")
                }),
                "*"
              );
            }
            this.showMessage({
              title: this.$locale.baseText("openWorkflow.workflowImportError"),
              message: e.message,
              type: "error"
            });
          }
        } else if (json && json.command === "openExecution") {
          try {
            this.nodeHelpers.isProductionExecutionPreview.value = json.executionMode !== "manual";
            await this.openExecution(json.executionId);
            this.canOpenNDV = json.canOpenNDV ?? true;
            this.hideNodeIssues = json.hideNodeIssues ?? false;
            this.isExecutionPreview = true;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: this.$locale.baseText("nodeView.showError.openExecution.title")
                }),
                "*"
              );
            }
            this.showMessage({
              title: this.$locale.baseText("nodeView.showError.openExecution.title"),
              message: e.message,
              type: "error"
            });
          }
        } else if ((json == null ? void 0 : json.command) === "setActiveExecution") {
          this.executionsStore.activeExecution = await this.executionsStore.fetchExecution(
            json.executionId
          );
        }
      } catch (e) {
      }
    },
    async onImportWorkflowDataEvent(data) {
      await this.importWorkflowData(data.data, "file");
    },
    async onImportWorkflowUrlEvent(data) {
      const workflowData = await this.getWorkflowDataFromUrl(data.url);
      if (workflowData !== void 0) {
        await this.importWorkflowData(workflowData, "url");
      }
    },
    onToggleNodeCreator({ source, createNodeActive, nodeCreatorView }) {
      if (createNodeActive === this.createNodeActive) return;
      if (!nodeCreatorView) {
        nodeCreatorView = this.containsTrigger ? REGULAR_NODE_CREATOR_VIEW : TRIGGER_NODE_CREATOR_VIEW;
      }
      this.nodeCreatorStore.setSelectedView(nodeCreatorView);
      this.createNodeActive = createNodeActive;
      let mode;
      switch (this.nodeCreatorStore.selectedView) {
        case AI_NODE_CREATOR_VIEW:
          mode = "ai";
          break;
        case REGULAR_NODE_CREATOR_VIEW:
          mode = "regular";
          break;
        default:
          mode = "regular";
      }
      if (createNodeActive && source) this.nodeCreatorStore.setOpenSource(source);
      void this.externalHooks.run("nodeView.createNodeActiveChanged", {
        source,
        mode,
        createNodeActive
      });
      this.$telemetry.trackNodesPanel("nodeView.createNodeActiveChanged", {
        source,
        mode,
        createNodeActive,
        workflow_id: this.workflowsStore.workflowId
      });
    },
    async onAddNodes({ nodes, connections: connections2 }, dragAndDrop = false, position2) {
      let currentPosition = position2;
      for (const { type, isAutoAdd, name, openDetail, position: nodePosition } of nodes) {
        await this.addNode(
          type,
          { position: nodePosition ?? currentPosition, dragAndDrop, name },
          openDetail ?? false,
          true,
          isAutoAdd
        );
        const lastAddedNode2 = this.nodes[this.nodes.length - 1];
        currentPosition = [
          lastAddedNode2.position[0] + NODE_SIZE * 2 + GRID_SIZE,
          lastAddedNode2.position[1]
        ];
      }
      const newNodesOffset = this.nodes.length - nodes.length;
      for (const { from, to } of connections2) {
        const fromNode = this.nodes[newNodesOffset + from.nodeIndex];
        const toNode = this.nodes[newNodesOffset + to.nodeIndex];
        this.connectTwoNodes(
          fromNode.name,
          from.outputIndex ?? 0,
          toNode.name,
          to.inputIndex ?? 0,
          from.type ?? NodeConnectionType.Main
        );
      }
      const lastAddedNode = this.nodes[this.nodes.length - 1];
      const workflow = this.workflowHelpers.getCurrentWorkflow();
      const lastNodeInputs = workflow.getParentNodesByDepth(lastAddedNode.name, 1);
      if (lastNodeInputs.length > 1) {
        lastNodeInputs.slice(1).forEach((node2, index) => {
          const nodeUi = this.workflowsStore.getNodeByName(node2.name);
          if (!nodeUi) return;
          this.onMoveNode({
            nodeName: nodeUi.name,
            position: [nodeUi.position[0], nodeUi.position[1] + 100 * (index + 1)]
          });
        });
      }
      const lastNodeType = this.nodeTypesStore.getNodeType(lastAddedNode.type);
      const isSubNode = isSubNodeType(lastNodeType);
      if (isSubNode && nodes.length > 1) {
        this.onMoveNode({
          nodeName: lastAddedNode.name,
          position: [
            lastAddedNode.position[0] - NODE_SIZE * 2.5,
            lastAddedNode.position[1] + NODE_SIZE * 1.5
          ]
        });
      }
      this.nodeHelpers.addPinDataConnections(this.workflowsStore.pinnedWorkflowData);
    },
    async saveCurrentWorkflowExternal(callback) {
      await this.workflowHelpers.saveCurrentWorkflow();
      callback == null ? void 0 : callback();
    },
    setSuspendRecordingDetachedConnections(suspend) {
      this.suspendRecordingDetachedConnections = suspend;
    },
    onMoveNode({ nodeName, position: position2 }) {
      this.workflowsStore.updateNodeProperties({ name: nodeName, properties: { position: position2 } });
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      setTimeout(() => {
        var _a;
        if (node2) {
          (_a = this.instance) == null ? void 0 : _a.repaintEverything();
          this.onNodeMoved(node2);
        }
      }, 0);
    },
    onRevertAddNode({ node: node2 }) {
      this.removeNode(node2.name, false);
    },
    async onRevertRemoveNode({ node: node2 }) {
      const prevNode = this.workflowsStore.workflow.nodes.find((n) => n.id === node2.id);
      if (prevNode) {
        return;
      }
      node2.id = v4();
      await this.nodeHelpers.addNodes([node2]);
    },
    onRevertAddConnection({ connection }) {
      this.suspendRecordingDetachedConnections = true;
      this.nodeHelpers.removeConnection(connection, true);
      this.suspendRecordingDetachedConnections = false;
    },
    async onRevertRemoveConnection({ connection }) {
      this.suspendRecordingDetachedConnections = true;
      this.nodeHelpers.addConnection(connection);
      this.suspendRecordingDetachedConnections = false;
    },
    async onRevertNameChange({ currentName, newName }) {
      await this.renameNode(newName, currentName);
    },
    onRevertEnableToggle({ nodeName }) {
      const node2 = this.workflowsStore.getNodeByName(nodeName);
      if (node2) {
        this.nodeHelpers.disableNodes([node2]);
      }
    },
    onPageShow(e) {
      if (e.persisted) {
        this.canvasStore.stopLoading();
      }
    },
    async readOnlyEnvRouteCheck() {
      if ((this.readOnlyEnv || !this.projectPermissions.workflow.create) && (this.$route.name === VIEWS.NEW_WORKFLOW || this.$route.name === VIEWS.TEMPLATE_IMPORT)) {
        await this.$nextTick();
        this.resetWorkspace();
        this.uiStore.stateIsDirty = false;
        await this.$router.replace({ name: VIEWS.HOMEPAGE });
      }
    },
    async checkAndInitDebugMode() {
      if (this.$route.name === VIEWS.EXECUTION_DEBUG) {
        this.workflowHelpers.setDocumentTitle(this.workflowName, "DEBUG");
        if (!this.workflowsStore.isInDebugMode) {
          await this.applyExecutionData(this.$route.params.executionId);
          this.workflowsStore.isInDebugMode = true;
        }
      }
    },
    onContextMenu(event) {
      this.contextMenu.open(event, {
        source: "canvas",
        nodeIds: this.uiStore.selectedNodes.map((node2) => node2.id)
      });
    },
    onContextMenuAction(action2, nodeIds) {
      const nodes = nodeIds.map((nodeId) => this.workflowsStore.getNodeById(nodeId)).filter(isPresent);
      switch (action2) {
        case "copy":
          this.copyNodes(nodes);
          break;
        case "delete":
          this.deleteNodes(nodes);
          break;
        case "duplicate":
          void this.duplicateNodes(nodes);
          break;
        case "execute":
          this.onRunNode(nodes[0].name, "NodeView.onContextMenuAction");
          break;
        case "open":
          this.ndvStore.activeNodeName = nodes[0].name;
          break;
        case "rename":
          void this.renameNodePrompt(nodes[0].name);
          break;
        case "toggle_activation":
          this.toggleActivationNodes(nodes);
          break;
        case "toggle_pin":
          this.togglePinNodes(nodes, "context-menu");
          break;
        case "add_node":
          this.onToggleNodeCreator({
            source: NODE_CREATOR_OPEN_SOURCES.CONTEXT_MENU,
            createNodeActive: !this.isReadOnlyRoute && !this.readOnlyEnv && !!(this.workflowPermissions.update ?? this.projectPermissions.workflow.update)
          });
          break;
        case "add_sticky":
          void this.onAddNodes({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
          break;
        case "select_all":
          this.selectAllNodes();
          break;
        case "deselect_all":
          this.deselectAllNodes();
          break;
      }
    },
    async onSourceControlPull() {
      let workflowId = null;
      if (this.$route.params.name) {
        workflowId = this.$route.params.name.toString();
      }
      try {
        if (workflowId !== null && !this.uiStore.stateIsDirty) {
          const workflow = await this.workflowsStore.fetchWorkflow(workflowId);
          if (workflow) {
            this.workflowHelpers.setDocumentTitle(workflow.name, "IDLE");
            await this.openWorkflow(workflow);
          }
        }
        await Promise.all([
          this.loadVariables(),
          this.tagsStore.fetchAll(),
          this.loadCredentialsForWorkflow()
        ]);
      } catch (error2) {
        console.error(error2);
      }
    }
  }
});
const content$1 = "_content_yewsk_1";
const shake = "_shake_yewsk_9";
const setupCredentialsButtonWrapper = "_setupCredentialsButtonWrapper_yewsk_27";
const style2 = {
  content: content$1,
  shake,
  setupCredentialsButtonWrapper
};
const _hoisted_1$b = ["textContent"];
const _hoisted_2$7 = {
  key: 0,
  class: "workflow-execute-wrapper"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CanvasAddButton = resolveComponent("CanvasAddButton");
  const _component_Node = __unplugin_components_0$6;
  const _component_Sticky = __unplugin_components_1;
  const _component_NodeDetailsView = __unplugin_components_2;
  const _component_LazySetupWorkflowCredentialsButton = resolveComponent("LazySetupWorkflowCredentialsButton");
  const _component_LazyNodeCreation = resolveComponent("LazyNodeCreation");
  const _component_LazyCanvasControls = resolveComponent("LazyCanvasControls");
  const _component_ContextMenu = ContextMenu;
  const _component_n8n_button = resolveComponent("n8n-button");
  const _component_KeyboardShortcutTooltip = KeyboardShortcutTooltip;
  const _component_n8n_icon_button = resolveComponent("n8n-icon-button");
  const _directive_touch = resolveDirective("touch");
  return openBlock(), createElementBlock("div", {
    ref: "nodeViewRootRef",
    class: normalizeClass(_ctx.$style["content"])
  }, [
    createBaseVNode("div", {
      id: "node-view-root",
      class: "node-view-root do-not-select",
      "data-test-id": "node-view-root",
      onDragover: _cache[13] || (_cache[13] = (...args) => _ctx.onDragOver && _ctx.onDragOver(...args)),
      onDrop: _cache[14] || (_cache[14] = (...args) => _ctx.onDrop && _ctx.onDrop(...args))
    }, [
      withDirectives((openBlock(), createElementBlock("div", {
        class: normalizeClass(["node-view-wrapper", _ctx.workflowClasses]),
        "data-test-id": "node-view-wrapper",
        onTouchstart: _cache[3] || (_cache[3] = (...args) => _ctx.mouseDown && _ctx.mouseDown(...args)),
        onTouchend: _cache[4] || (_cache[4] = (...args) => _ctx.mouseUp && _ctx.mouseUp(...args)),
        onTouchmove: _cache[5] || (_cache[5] = (...args) => _ctx.canvasPanning.onMouseMove && _ctx.canvasPanning.onMouseMove(...args)),
        onMousedown: _cache[6] || (_cache[6] = (...args) => _ctx.mouseDown && _ctx.mouseDown(...args)),
        onMouseup: _cache[7] || (_cache[7] = (...args) => _ctx.mouseUp && _ctx.mouseUp(...args)),
        onContextmenu: _cache[8] || (_cache[8] = (...args) => _ctx.onContextMenu && _ctx.onContextMenu(...args)),
        onWheel: _cache[9] || (_cache[9] = (...args) => _ctx.canvasStore.wheelScroll && _ctx.canvasStore.wheelScroll(...args))
      }, [
        createBaseVNode("div", {
          id: "node-view-background",
          class: "node-view-background",
          style: normalizeStyle(_ctx.backgroundStyle),
          "data-test-id": "node-view-background"
        }, null, 4),
        createBaseVNode("div", {
          id: "node-view",
          ref: "nodeViewRef",
          class: "node-view",
          style: normalizeStyle(_ctx.workflowStyle),
          "data-test-id": "node-view"
        }, [
          withDirectives(createVNode(_component_CanvasAddButton, {
            ref: "canvasAddButton",
            style: normalizeStyle(_ctx.canvasAddButtonStyle),
            "show-tooltip": !_ctx.containsTrigger && _ctx.showTriggerMissingTooltip,
            position: _ctx.canvasStore.canvasAddButtonPosition,
            "data-test-id": "canvas-add-button",
            onClick: _ctx.onCanvasAddButtonCLick,
            "onHook:mounted": _ctx.canvasStore.setRecenteredCanvasAddButtonPosition
          }, null, 8, ["style", "show-tooltip", "position", "onClick", "onHook:mounted"]), [
            [vShow, _ctx.showCanvasAddButton]
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodesToRender, (nodeData) => {
            return openBlock(), createBlock(_component_Node, {
              key: `${nodeData.id}_node`,
              name: nodeData.name,
              "is-read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
              instance: _ctx.instance,
              "is-active": !!_ctx.activeNode && _ctx.activeNode.name === nodeData.name,
              "hide-actions": _ctx.pullConnActive,
              "is-production-execution-preview": _ctx.isProductionExecutionPreview,
              workflow: _ctx.currentWorkflowObject,
              "disable-pointer-events": !_ctx.canOpenNDV,
              "hide-node-issues": _ctx.hideNodeIssues,
              onDeselectAllNodes: _ctx.deselectAllNodes,
              onDeselectNode: _ctx.nodeDeselectedByName,
              onNodeSelected: _ctx.nodeSelectedByName,
              onRunWorkflow: _ctx.onRunNode,
              onMoved: _ctx.onNodeMoved,
              onRun: _ctx.onNodeRun,
              onRemoveNode: _cache[0] || (_cache[0] = (name) => _ctx.removeNode(name, true)),
              onToggleDisableNode: _cache[1] || (_cache[1] = (node2) => _ctx.toggleActivationNodes([node2]))
            }, {
              "custom-tooltip": withCtx(() => [
                createBaseVNode("span", {
                  textContent: toDisplayString(_ctx.$locale.baseText("nodeView.canvasAddButton.addATriggerNodeBeforeExecuting"))
                }, null, 8, _hoisted_1$b)
              ]),
              _: 2
            }, 1032, ["name", "is-read-only", "instance", "is-active", "hide-actions", "is-production-execution-preview", "workflow", "disable-pointer-events", "hide-node-issues", "onDeselectAllNodes", "onDeselectNode", "onNodeSelected", "onRunWorkflow", "onMoved", "onRun"]);
          }), 128)),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.stickiesToRender, (stickyData) => {
            return openBlock(), createBlock(_component_Sticky, {
              key: `${stickyData.id}_sticky`,
              name: stickyData.name,
              workflow: _ctx.currentWorkflowObject,
              "is-read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
              instance: _ctx.instance,
              "is-active": !!_ctx.activeNode && _ctx.activeNode.name === stickyData.name,
              "node-view-scale": _ctx.nodeViewScale,
              "grid-size": _ctx.GRID_SIZE,
              "hide-actions": _ctx.pullConnActive,
              onDeselectAllNodes: _ctx.deselectAllNodes,
              onDeselectNode: _ctx.nodeDeselectedByName,
              onNodeSelected: _ctx.nodeSelectedByName,
              onRemoveNode: _cache[2] || (_cache[2] = (name) => _ctx.removeNode(name, true))
            }, null, 8, ["name", "workflow", "is-read-only", "instance", "is-active", "node-view-scale", "grid-size", "hide-actions", "onDeselectAllNodes", "onDeselectNode", "onNodeSelected"]);
          }), 128))
        ], 4)
      ], 34)), [
        [_directive_touch, _ctx.touchTap, "tap"]
      ]),
      createVNode(_component_NodeDetailsView, {
        "workflow-object": _ctx.currentWorkflowObject,
        "read-only": _ctx.isReadOnlyRoute || _ctx.readOnlyEnv || !(_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update),
        renaming: _ctx.renamingActive,
        "is-production-execution-preview": _ctx.isProductionExecutionPreview,
        onRedrawNode: _ctx.redrawNode,
        onSwitchSelectedNode: _ctx.onSwitchSelectedNode,
        onOpenConnectionNodeCreator: _ctx.onOpenConnectionNodeCreator,
        onValueChanged: _ctx.valueChanged,
        onStopExecution: _ctx.stopExecution,
        onSaveKeyboardShortcut: _ctx.onSaveKeyboardShortcut
      }, null, 8, ["workflow-object", "read-only", "renaming", "is-production-execution-preview", "onRedrawNode", "onSwitchSelectedNode", "onOpenConnectionNodeCreator", "onValueChanged", "onStopExecution", "onSaveKeyboardShortcut"]),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.setupCredentialsButtonWrapper)
          }, [
            createVNode(_component_LazySetupWorkflowCredentialsButton)
          ], 2)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv && (_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update) ? (openBlock(), createBlock(_component_LazyNodeCreation, {
            key: 0,
            "create-node-active": _ctx.createNodeActive,
            "node-view-scale": _ctx.nodeViewScale,
            onToggleNodeCreator: _ctx.onToggleNodeCreator,
            onAddNodes: _ctx.onAddNodes
          }, null, 8, ["create-node-active", "node-view-scale", "onToggleNodeCreator", "onAddNodes"])) : createCommentVNode("", true)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createVNode(_component_LazyCanvasControls)
        ]),
        _: 1
      })),
      (openBlock(), createBlock(Suspense, null, {
        default: withCtx(() => [
          createVNode(_component_ContextMenu, { onAction: _ctx.onContextMenuAction }, null, 8, ["onAction"])
        ]),
        _: 1
      })),
      !_ctx.isReadOnlyRoute && !_ctx.readOnlyEnv && (_ctx.workflowPermissions.update ?? _ctx.projectPermissions.workflow.update) ? (openBlock(), createElementBlock("div", _hoisted_2$7, [
        !_ctx.isManualChatOnly ? (openBlock(), createElementBlock("span", {
          key: 0,
          onMouseenter: _cache[10] || (_cache[10] = ($event) => _ctx.showTriggerMissingToltip(true)),
          onMouseleave: _cache[11] || (_cache[11] = ($event) => _ctx.showTriggerMissingToltip(false)),
          onClick: _cache[12] || (_cache[12] = (...args) => _ctx.onRunContainerClick && _ctx.onRunContainerClick(...args))
        }, [
          createVNode(_component_KeyboardShortcutTooltip, {
            label: _ctx.runButtonText,
            shortcut: { metaKey: true, keys: ["↵"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_n8n_button, {
                loading: _ctx.workflowRunning,
                label: _ctx.runButtonText,
                size: "large",
                icon: "flask",
                type: "primary",
                disabled: _ctx.isExecutionDisabled,
                "data-test-id": "execute-workflow-button",
                onClick: withModifiers(_ctx.onRunWorkflow, ["stop"])
              }, null, 8, ["loading", "label", "disabled", "onClick"])
            ]),
            _: 1
          }, 8, ["label"])
        ], 32)) : createCommentVNode("", true),
        _ctx.containsChatNodes ? (openBlock(), createBlock(_component_n8n_button, {
          key: 1,
          label: "Chat",
          size: "large",
          icon: "comment",
          type: "primary",
          "data-test-id": "workflow-chat-button",
          onClick: withModifiers(_ctx.onOpenChat, ["stop"])
        }, null, 8, ["onClick"])) : createCommentVNode("", true),
        _ctx.workflowRunning === true && !_ctx.executionWaitingForWebhook ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 2,
          icon: "stop",
          size: "large",
          class: "stop-execution",
          type: "secondary",
          title: _ctx.stopExecutionInProgress ? _ctx.$locale.baseText("nodeView.stoppingCurrentExecution") : _ctx.$locale.baseText("nodeView.stopCurrentExecution"),
          loading: _ctx.stopExecutionInProgress,
          "data-test-id": "stop-execution-button",
          onClick: withModifiers(_ctx.stopExecution, ["stop"])
        }, null, 8, ["title", "loading", "onClick"])) : createCommentVNode("", true),
        _ctx.workflowRunning === true && _ctx.executionWaitingForWebhook === true ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 3,
          class: "stop-execution",
          icon: "stop",
          size: "large",
          title: _ctx.$locale.baseText("nodeView.stopWaitingForWebhookCall"),
          type: "secondary",
          "data-test-id": "stop-execution-waiting-for-webhook-button",
          onClick: withModifiers(_ctx.stopWaitingForWebhook, ["stop"])
        }, null, 8, ["title", "onClick"])) : createCommentVNode("", true),
        _ctx.workflowExecution && !_ctx.workflowRunning && !_ctx.allTriggersDisabled ? (openBlock(), createBlock(_component_n8n_icon_button, {
          key: 4,
          title: _ctx.$locale.baseText("nodeView.deletesTheCurrentExecutionData"),
          icon: "trash",
          size: "large",
          "data-test-id": "clear-execution-data-button",
          onClick: withModifiers(_ctx.clearExecutionData, ["stop"])
        }, null, 8, ["title", "onClick"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ], 32)
  ], 2);
}
const cssModules$n = {
  "$style": style2
};
const NodeViewV1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$B, [["render", _sfc_render$2], ["__cssModules", cssModules$n], ["__scopeId", "data-v-cf132c44"]]);
const _sfc_main$A = {};
function _sfc_render$1(_ctx, _cache) {
  const _component_N8nButton = resolveComponent("N8nButton");
  return openBlock(), createBlock(_component_N8nButton, {
    label: "Chat",
    size: "large",
    icon: "comment",
    type: "primary",
    "data-test-id": "workflow-chat-button"
  });
}
const __unplugin_components_0$5 = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["render", _sfc_render$1]]);
function tryOnScopeDispose(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function toValue(r) {
  return typeof r === "function" ? r() : unref(r);
}
const isClient = typeof window !== "undefined" && typeof document !== "undefined";
const isDef$1 = (val) => typeof val !== "undefined";
const toString = Object.prototype.toString;
const isObject = (val) => toString.call(val) === "[object Object]";
const noop$2 = () => {
};
function createFilterWrapper(filter2, fn) {
  function wrapper2(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper2;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function promiseTimeout(ms, throwOnTimeout = false, reason = "Timeout") {
  return new Promise((resolve, reject) => {
    if (throwOnTimeout)
      setTimeout(() => reject(reason), ms);
    else
      setTimeout(resolve, ms);
  });
}
function watchWithFilter(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2);
  const stop2 = watchWithFilter(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop: stop2, pause, resume, isActive };
}
function toRefs(objectRef, options = {}) {
  if (!isRef(objectRef))
    return toRefs$1(objectRef);
  const result = Array.isArray(objectRef.value) ? Array.from({ length: objectRef.value.length }) : {};
  for (const key in objectRef.value) {
    result[key] = customRef(() => ({
      get() {
        return objectRef.value[key];
      },
      set(v) {
        var _a;
        const replaceRef = (_a = toValue(options.replaceRef)) != null ? _a : true;
        if (replaceRef) {
          if (Array.isArray(objectRef.value)) {
            const copy = [...objectRef.value];
            copy[key] = v;
            objectRef.value = copy;
          } else {
            const newObject = { ...objectRef.value, [key]: v };
            Object.setPrototypeOf(newObject, Object.getPrototypeOf(objectRef.value));
            objectRef.value = newObject;
          }
        } else {
          objectRef.value[key] = v;
        }
      }
    }));
  }
  return result;
}
function createUntil(r, isNot = false) {
  function toMatch(condition, { flush = "sync", deep = false, timeout: timeout2, throwOnTimeout } = {}) {
    let stop2 = null;
    const watcher = new Promise((resolve) => {
      stop2 = watch(
        r,
        (v) => {
          if (condition(v) !== isNot) {
            stop2 == null ? void 0 : stop2();
            resolve(v);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout2 != null) {
      promises.push(
        promiseTimeout(timeout2, throwOnTimeout).then(() => toValue(r)).finally(() => stop2 == null ? void 0 : stop2())
      );
    }
    return Promise.race(promises);
  }
  function toBe(value, options) {
    if (!isRef(value))
      return toMatch((v) => v === value, options);
    const { flush = "sync", deep = false, timeout: timeout2, throwOnTimeout } = options != null ? options : {};
    let stop2 = null;
    const watcher = new Promise((resolve) => {
      stop2 = watch(
        [r, value],
        ([v1, v2]) => {
          if (isNot !== (v1 === v2)) {
            stop2 == null ? void 0 : stop2();
            resolve(v1);
          }
        },
        {
          flush,
          deep,
          immediate: true
        }
      );
    });
    const promises = [watcher];
    if (timeout2 != null) {
      promises.push(
        promiseTimeout(timeout2, throwOnTimeout).then(() => toValue(r)).finally(() => {
          stop2 == null ? void 0 : stop2();
          return toValue(r);
        })
      );
    }
    return Promise.race(promises);
  }
  function toBeTruthy(options) {
    return toMatch((v) => Boolean(v), options);
  }
  function toBeNull(options) {
    return toBe(null, options);
  }
  function toBeUndefined(options) {
    return toBe(void 0, options);
  }
  function toBeNaN(options) {
    return toMatch(Number.isNaN, options);
  }
  function toContains(value, options) {
    return toMatch((v) => {
      const array2 = Array.from(v);
      return array2.includes(value) || array2.includes(toValue(value));
    }, options);
  }
  function changed(options) {
    return changedTimes(1, options);
  }
  function changedTimes(n = 1, options) {
    let count2 = -1;
    return toMatch(() => {
      count2 += 1;
      return count2 >= n;
    }, options);
  }
  if (Array.isArray(toValue(r))) {
    const instance = {
      toMatch,
      toContains,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  } else {
    const instance = {
      toMatch,
      toBe,
      toBeTruthy,
      toBeNull,
      toBeNaN,
      toBeUndefined,
      changed,
      changedTimes,
      get not() {
        return createUntil(r, !isNot);
      }
    };
    return instance;
  }
}
function until(r) {
  return createUntil(r);
}
function unrefElement(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target2;
  let events;
  let listeners;
  let options;
  if (typeof args[0] === "string" || Array.isArray(args[0])) {
    [events, listeners, options] = args;
    target2 = defaultWindow;
  } else {
    [target2, events, listeners, options] = args;
  }
  if (!target2)
    return noop$2;
  if (!Array.isArray(events))
    events = [events];
  if (!Array.isArray(listeners))
    listeners = [listeners];
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options2) => {
    el.addEventListener(event, listener, options2);
    return () => el.removeEventListener(event, listener, options2);
  };
  const stopWatch = watch(
    () => [unrefElement(target2), toValue(options)],
    ([el, options2]) => {
      cleanup();
      if (!el)
        return;
      const optionsClone = isObject(options2) ? { ...options2 } : options2;
      cleanups.push(
        ...events.flatMap((event) => {
          return listeners.map((listener) => register(el, event, listener, optionsClone));
        })
      );
    },
    { immediate: true, flush: "post" }
  );
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function createKeyPredicate$1(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target: target2 = defaultWindow,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate$1(key);
  const listener = (e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener(target2, eventName, listener, passive);
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
function useVModel(props, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    {
      key = "modelValue";
    }
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue2 = () => isDef$1(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
var noop$1$1 = { value: () => {
} };
function dispatch$2() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$2(_);
}
function Dispatch$2(_) {
  this._ = _;
}
function parseTypenames$1$2(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch$2.prototype = dispatch$2.prototype = {
  constructor: Dispatch$2,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames$1$2(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$1$1(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$1$1(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$1$1(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch$2(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$1$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set$1$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var xhtml$2 = "http://www.w3.org/1999/xhtml";
const namespaces$2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml$2,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace$2(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces$2.hasOwnProperty(prefix) ? { space: namespaces$2[prefix], local: name } : name;
}
function creatorInherit$2(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml$2 && document2.documentElement.namespaceURI === xhtml$2 ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed$2(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator$2(name) {
  var fullname = namespace$2(name);
  return (fullname.local ? creatorFixed$2 : creatorInherit$2)(fullname);
}
function none$2() {
}
function selector$2(selector2) {
  return selector2 == null ? none$2 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select$2(select2) {
  if (typeof select2 !== "function")
    select2 = selector$2(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1$1(subgroups, this._parents);
}
function array$2(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty$2() {
  return [];
}
function selectorAll$2(selector2) {
  return selector2 == null ? empty$2 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll$2(select2) {
  return function() {
    return array$2(select2.apply(this, arguments));
  };
}
function selection_selectAll$2(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll$2(select2);
  else
    select2 = selectorAll$2(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents.push(node2);
      }
    }
  }
  return new Selection$1$1(subgroups, parents);
}
function matcher$2(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher$2(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find$2 = Array.prototype.find;
function childFind$2(match) {
  return function() {
    return find$2.call(this.children, match);
  };
}
function childFirst$2() {
  return this.firstElementChild;
}
function selection_selectChild$2(match) {
  return this.select(match == null ? childFirst$2 : childFind$2(typeof match === "function" ? match : childMatcher$2(match)));
}
var filter$2 = Array.prototype.filter;
function children$2() {
  return Array.from(this.children);
}
function childrenFilter$2(match) {
  return function() {
    return filter$2.call(this.children, match);
  };
}
function selection_selectChildren$2(match) {
  return this.selectAll(match == null ? children$2 : childrenFilter$2(typeof match === "function" ? match : childMatcher$2(match)));
}
function selection_filter$2(match) {
  if (typeof match !== "function")
    match = matcher$2(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1$1(subgroups, this._parents);
}
function sparse$2(update) {
  return new Array(update.length);
}
function selection_enter$2() {
  return new Selection$1$1(this._enter || this._groups.map(sparse$2), this._parents);
}
function EnterNode$2(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode$2.prototype = {
  constructor: EnterNode$2,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$3$1(x) {
  return function() {
    return x;
  };
}
function bindIndex$2(parent, group, enter, update, exit, data) {
  var i = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode$2(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey$2(parent, group, enter, update, exit, data, key) {
  var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update[i] = node2;
      node2.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode$2(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
      exit[i] = node2;
    }
  }
}
function datum$2(node2) {
  return node2.__data__;
}
function selection_data$2(value, key) {
  if (!arguments.length)
    return Array.from(this, datum$2);
  var bind = key ? bindKey$2 : bindIndex$2, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$3$1(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike$2(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike$2(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit$2() {
  return new Selection$1$1(this._exit || this._groups.map(sparse$2), this._parents);
}
function selection_join$2(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge$2(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1$1(merges, this._parents);
}
function selection_order$2() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next && node2.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node2, next);
        next = node2;
      }
    }
  }
  return this;
}
function selection_sort$2(compare) {
  if (!compare)
    compare = ascending$2;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1$1(sortgroups, this._parents).order();
}
function ascending$2(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call$2() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes$2() {
  return Array.from(this);
}
function selection_node$2() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size$2() {
  let size = 0;
  for (const node2 of this)
    ++size;
  return size;
}
function selection_empty$2() {
  return !this.node();
}
function selection_each$2(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS$1$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr$2(name, value) {
  var fullname = namespace$2(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1$1 : attrRemove$1$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1$1 : attrFunction$1$1 : fullname.local ? attrConstantNS$1$1 : attrConstant$1$1)(fullname, value));
}
function defaultView$2(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style$2(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1$1 : typeof value === "function" ? styleFunction$1$1 : styleConstant$1$1)(name, value, priority == null ? "" : priority)) : styleValue$2(this.node(), name);
}
function styleValue$2(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView$2(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove$2(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant$2(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction$2(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property$2(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove$2 : typeof value === "function" ? propertyFunction$2 : propertyConstant$2)(name, value)) : this.node()[name];
}
function classArray$2(string) {
  return string.trim().split(/^|\s+/);
}
function classList$2(node2) {
  return node2.classList || new ClassList$2(node2);
}
function ClassList$2(node2) {
  this._node = node2;
  this._names = classArray$2(node2.getAttribute("class") || "");
}
ClassList$2.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd$2(node2, names) {
  var list = classList$2(node2), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove$2(node2, names) {
  var list = classList$2(node2), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue$2(names) {
  return function() {
    classedAdd$2(this, names);
  };
}
function classedFalse$2(names) {
  return function() {
    classedRemove$2(this, names);
  };
}
function classedFunction$2(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd$2 : classedRemove$2)(this, names);
  };
}
function selection_classed$2(name, value) {
  var names = classArray$2(name + "");
  if (arguments.length < 2) {
    var list = classList$2(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction$2 : value ? classedTrue$2 : classedFalse$2)(names, value));
}
function textRemove$2() {
  this.textContent = "";
}
function textConstant$1$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text$2(value) {
  return arguments.length ? this.each(value == null ? textRemove$2 : (typeof value === "function" ? textFunction$1$1 : textConstant$1$1)(value)) : this.node().textContent;
}
function htmlRemove$2() {
  this.innerHTML = "";
}
function htmlConstant$2(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction$2(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html$2(value) {
  return arguments.length ? this.each(value == null ? htmlRemove$2 : (typeof value === "function" ? htmlFunction$2 : htmlConstant$2)(value)) : this.node().innerHTML;
}
function raise$2() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise$2() {
  return this.each(raise$2);
}
function lower$2() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower$2() {
  return this.each(lower$2);
}
function selection_append$2(name) {
  var create2 = typeof name === "function" ? name : creator$2(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull$2() {
  return null;
}
function selection_insert$2(name, before) {
  var create2 = typeof name === "function" ? name : creator$2(name), select2 = before == null ? constantNull$2 : typeof before === "function" ? before : selector$2(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove$2() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove$2() {
  return this.each(remove$2);
}
function selection_cloneShallow$2() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep$2() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone$2(deep) {
  return this.select(deep ? selection_cloneDeep$2 : selection_cloneShallow$2);
}
function selection_datum$2(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener$2(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$3(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove$2(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd$2(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener$2(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on$2(typename, value, options) {
  var typenames = parseTypenames$3(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd$2 : onRemove$2;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent$2(node2, type, params) {
  var window2 = defaultView$2(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant$2(type, params) {
  return function() {
    return dispatchEvent$2(this, type, params);
  };
}
function dispatchFunction$2(type, params) {
  return function() {
    return dispatchEvent$2(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch$2(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction$2 : dispatchConstant$2)(type, params));
}
function* selection_iterator$2() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        yield node2;
    }
  }
}
var root$2 = [null];
function Selection$1$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection$1() {
  return new Selection$1$1([[document.documentElement]], root$2);
}
function selection_selection$2() {
  return this;
}
Selection$1$1.prototype = selection$1.prototype = {
  constructor: Selection$1$1,
  select: selection_select$2,
  selectAll: selection_selectAll$2,
  selectChild: selection_selectChild$2,
  selectChildren: selection_selectChildren$2,
  filter: selection_filter$2,
  data: selection_data$2,
  enter: selection_enter$2,
  exit: selection_exit$2,
  join: selection_join$2,
  merge: selection_merge$2,
  selection: selection_selection$2,
  order: selection_order$2,
  sort: selection_sort$2,
  call: selection_call$2,
  nodes: selection_nodes$2,
  node: selection_node$2,
  size: selection_size$2,
  empty: selection_empty$2,
  each: selection_each$2,
  attr: selection_attr$2,
  style: selection_style$2,
  property: selection_property$2,
  classed: selection_classed$2,
  text: selection_text$2,
  html: selection_html$2,
  raise: selection_raise$2,
  lower: selection_lower$2,
  append: selection_append$2,
  insert: selection_insert$2,
  remove: selection_remove$2,
  clone: selection_clone$2,
  datum: selection_datum$2,
  on: selection_on$2,
  dispatch: selection_dispatch$2,
  [Symbol.iterator]: selection_iterator$2
};
function select$2(selector2) {
  return typeof selector2 === "string" ? new Selection$1$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1$1([[selector2]], root$2);
}
function sourceEvent$2(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer$2(event, node2) {
  event = sourceEvent$2(event);
  if (node2 === void 0)
    node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node2.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassive$1 = { passive: false };
const nonpassivecapture$2 = { capture: true, passive: false };
function nopropagation$1$1(event) {
  event.stopImmediatePropagation();
}
function noevent$1$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable$1(view) {
  var root2 = view.document.documentElement, selection2 = select$2(view).on("dragstart.drag", noevent$1$1, nonpassivecapture$2);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1$1, nonpassivecapture$2);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag$2(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select$2(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1$1, nonpassivecapture$2);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
const constant$2$1 = (x) => () => x;
function DragEvent$1(type, {
  sourceEvent: sourceEvent2,
  subject,
  target: target2,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent$1.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$1$1(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer$1() {
  return this.parentNode;
}
function defaultSubject$1(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable$1$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag$1() {
  var filter2 = defaultFilter$1$1, container2 = defaultContainer$1, subject = defaultSubject$1, touchable = defaultTouchable$1$1, gestures = {}, listeners = dispatch$2("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive$1).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter2.call(this, event, d))
      return;
    var gesture = beforestart(this, container2.call(this, event, d), event, d, "mouse");
    if (!gesture)
      return;
    select$2(event.view).on("mousemove.drag", mousemoved, nonpassivecapture$2).on("mouseup.drag", mouseupped, nonpassivecapture$2);
    dragDisable$1(event.view);
    nopropagation$1$1(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent$1$1(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select$2(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag$2(event.view, mousemoving);
    noevent$1$1(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter2.call(this, event, d))
      return;
    var touches = event.changedTouches, c = container2.call(this, event, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation$1$1(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent$1$1(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation$1$1(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container22, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer$2(touch || event, container22), dx, dy, s;
    if ((s = subject.call(that, new DragEvent$1("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null)
      return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer$2(touch2 || event2, container22), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent$1(type, {
          sourceEvent: event2,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$2$1(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container2 = typeof _ === "function" ? _ : constant$2$1(_), drag2) : container2;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant$2$1(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$2$1(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}
function define$1(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend$1(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color$1() {
}
var darker$1 = 0.7;
var brighter$1 = 1 / darker$1;
var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$1 = new RegExp(`^rgb\\(${reI$1},${reI$1},${reI$1}\\)$`), reRgbPercent$1 = new RegExp(`^rgb\\(${reP$1},${reP$1},${reP$1}\\)$`), reRgbaInteger$1 = new RegExp(`^rgba\\(${reI$1},${reI$1},${reI$1},${reN$1}\\)$`), reRgbaPercent$1 = new RegExp(`^rgba\\(${reP$1},${reP$1},${reP$1},${reN$1}\\)$`), reHslPercent$1 = new RegExp(`^hsl\\(${reN$1},${reP$1},${reP$1}\\)$`), reHslaPercent$1 = new RegExp(`^hsla\\(${reN$1},${reP$1},${reP$1},${reN$1}\\)$`);
var named$1 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define$1(Color$1, color$2, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex$1,
  formatHex8: color_formatHex8$1,
  formatHsl: color_formatHsl$1,
  formatRgb: color_formatRgb$1,
  toString: color_formatRgb$1
});
function color_formatHex$1() {
  return this.rgb().formatHex();
}
function color_formatHex8$1() {
  return this.rgb().formatHex8();
}
function color_formatHsl$1() {
  return hslConvert$1(this).formatHsl();
}
function color_formatRgb$1() {
  return this.rgb().formatRgb();
}
function color$2(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$1(m) : l === 3 ? new Rgb$1(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba$1(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba$1(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format]) : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0) : null;
}
function rgbn$1(n) {
  return new Rgb$1(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba$1(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb$1(r, g, b, a);
}
function rgbConvert$1(o) {
  if (!(o instanceof Color$1))
    o = color$2(o);
  if (!o)
    return new Rgb$1();
  o = o.rgb();
  return new Rgb$1(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb$1(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define$1(Rgb$1, rgb$1, extend$1(Color$1, {
  brighter(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb$1(clampi$1(this.r), clampi$1(this.g), clampi$1(this.b), clampa$1(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex$1,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex$1,
  formatHex8: rgb_formatHex8$1,
  formatRgb: rgb_formatRgb$1,
  toString: rgb_formatRgb$1
}));
function rgb_formatHex$1() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}`;
}
function rgb_formatHex8$1() {
  return `#${hex$1(this.r)}${hex$1(this.g)}${hex$1(this.b)}${hex$1((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb$1() {
  const a = clampa$1(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi$1(this.r)}, ${clampi$1(this.g)}, ${clampi$1(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa$1(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi$1(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex$1(value) {
  value = clampi$1(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla$1(h2, s, l, a) {
  if (a <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl$1(h2, s, l, a);
}
function hslConvert$1(o) {
  if (o instanceof Hsl$1)
    return new Hsl$1(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$1))
    o = color$2(o);
  if (!o)
    return new Hsl$1();
  if (o instanceof Hsl$1)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h2 = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max)
      h2 = (g - b) / s + (g < b) * 6;
    else if (g === max)
      h2 = (b - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl$1(h2, s, l, o.opacity);
}
function hsl$1(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert$1(h2) : new Hsl$1(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl$1(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define$1(Hsl$1, hsl$1, extend$1(Color$1, {
  brighter(k) {
    k = k == null ? brighter$1 : Math.pow(brighter$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker$1 : Math.pow(darker$1, k);
    return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb$1(
      hsl2rgb$1(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb$1(h2, m1, m2),
      hsl2rgb$1(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl$1(clamph$1(this.h), clampt$1(this.s), clampt$1(this.l), clampa$1(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa$1(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph$1(this.h)}, ${clampt$1(this.s) * 100}%, ${clampt$1(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph$1(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt$1(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb$1(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$1$2 = (x) => () => x;
function linear$1(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential$1(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma$1(y) {
  return (y = +y) === 1 ? nogamma$1 : function(a, b) {
    return b - a ? exponential$1(a, b, y) : constant$1$2(isNaN(a) ? b : a);
  };
}
function nogamma$1(a, b) {
  var d = b - a;
  return d ? linear$1(a, d) : constant$1$2(isNaN(a) ? b : a);
}
const interpolateRgb$1 = function rgbGamma(y) {
  var color2 = gamma$1(y);
  function rgb$1$1(start2, end) {
    var r = color2((start2 = rgb$1(start2)).r, (end = rgb$1(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma$1(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$1$1.gamma = rgbGamma;
  return rgb$1$1;
}(1);
function interpolateNumber$1(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$1 = new RegExp(reA$1.source, "g");
function zero$1(b) {
  return function() {
    return b;
  };
}
function one$1(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString$1(a, b) {
  var bi = reA$1.lastIndex = reB$1.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA$1.exec(a)) && (bm = reB$1.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber$1(am, bm) });
    }
    bi = reB$1.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one$1(q[0].x) : zero$1(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
var degrees$1 = 180 / Math.PI;
var identity$1$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose$1(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX,
    scaleY
  };
}
var svgNode$1;
function parseCss$1(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1$1 : decompose$1(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg$1(value) {
  if (value == null)
    return identity$1$1;
  if (!svgNode$1)
    svgNode$1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode$1.setAttribute("transform", value);
  if (!(value = svgNode$1.transform.baseVal.consolidate()))
    return identity$1$1;
  value = value.matrix;
  return decompose$1(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform$1(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss$1 = interpolateTransform$1(parseCss$1, "px, ", "px)", "deg)");
var interpolateTransformSvg$1 = interpolateTransform$1(parseSvg$1, ", ", ")", ")");
var epsilon2$1 = 1e-12;
function cosh$1(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh$1(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh$1(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
const interpolateZoom$1 = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2$1) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh$1(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh$1(rho * s + r0) - sinh$1(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh$1(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);
var frame$1 = 0, timeout$1$1 = 0, interval$1 = 0, pokeDelay$1 = 1e3, taskHead$1, taskTail$1, clockLast$1 = 0, clockNow$1 = 0, clockSkew$1 = 0, clock$1 = typeof performance === "object" && performance.now ? performance : Date, setFrame$1 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now$1() {
  return clockNow$1 || (setFrame$1(clearNow$1), clockNow$1 = clock$1.now() + clockSkew$1);
}
function clearNow$1() {
  clockNow$1 = 0;
}
function Timer$1() {
  this._call = this._time = this._next = null;
}
Timer$1.prototype = timer$1.prototype = {
  constructor: Timer$1,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail$1 !== this) {
      if (taskTail$1)
        taskTail$1._next = this;
      else
        taskHead$1 = this;
      taskTail$1 = this;
    }
    this._call = callback;
    this._time = time;
    sleep$1();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep$1();
    }
  }
};
function timer$1(callback, delay, time) {
  var t = new Timer$1();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush$1() {
  now$1();
  ++frame$1;
  var t = taskHead$1, e;
  while (t) {
    if ((e = clockNow$1 - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame$1;
}
function wake$1() {
  clockNow$1 = (clockLast$1 = clock$1.now()) + clockSkew$1;
  frame$1 = timeout$1$1 = 0;
  try {
    timerFlush$1();
  } finally {
    frame$1 = 0;
    nap$1();
    clockNow$1 = 0;
  }
}
function poke$1() {
  var now2 = clock$1.now(), delay = now2 - clockLast$1;
  if (delay > pokeDelay$1)
    clockSkew$1 -= delay, clockLast$1 = now2;
}
function nap$1() {
  var t0, t1 = taskHead$1, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead$1 = t2;
    }
  }
  taskTail$1 = t0;
  sleep$1(time);
}
function sleep$1(time) {
  if (frame$1)
    return;
  if (timeout$1$1)
    timeout$1$1 = clearTimeout(timeout$1$1);
  var delay = time - clockNow$1;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1$1 = setTimeout(wake$1, time - clock$1.now() - clockSkew$1);
    if (interval$1)
      interval$1 = clearInterval(interval$1);
  } else {
    if (!interval$1)
      clockLast$1 = clock$1.now(), interval$1 = setInterval(poke$1, pokeDelay$1);
    frame$1 = 1, setFrame$1(wake$1);
  }
}
function timeout$2(callback, delay, time) {
  var t = new Timer$1();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn$1 = dispatch$2("start", "end", "cancel", "interrupt");
var emptyTween$1 = [];
var CREATED$1 = 0;
var SCHEDULED$1 = 1;
var STARTING$1 = 2;
var STARTED$1 = 3;
var RUNNING$1 = 4;
var ENDING$1 = 5;
var ENDED$1 = 6;
function schedule$1(node2, name, id2, index, group, timing) {
  var schedules = node2.__transition;
  if (!schedules)
    node2.__transition = {};
  else if (id2 in schedules)
    return;
  create$1(node2, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn$1,
    tween: emptyTween$1,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED$1
  });
}
function init$1(node2, id2) {
  var schedule2 = get$3(node2, id2);
  if (schedule2.state > CREATED$1)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$3(node2, id2) {
  var schedule2 = get$3(node2, id2);
  if (schedule2.state > STARTED$1)
    throw new Error("too late; already running");
  return schedule2;
}
function get$3(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create$1(node2, id2, self) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self;
  self.timer = timer$1(schedule2, 0, self.time);
  function schedule2(elapsed) {
    self.state = SCHEDULED$1;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED$1)
      return stop2();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED$1)
        return timeout$2(start2);
      if (o.state === RUNNING$1) {
        o.state = ENDED$1;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED$1;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout$2(function() {
      if (self.state === STARTED$1) {
        self.state = RUNNING$1;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING$1;
    self.on.call("start", node2, node2.__data__, self.index, self.group);
    if (self.state !== STARTING$1)
      return;
    self.state = STARTED$1;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node2, node2.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop2), self.state = ENDING$1, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t);
    }
    if (self.state === ENDING$1) {
      self.on.call("end", node2, node2.__data__, self.index, self.group);
      stop2();
    }
  }
  function stop2() {
    self.state = ENDED$1;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node2.__transition;
  }
}
function interrupt$1(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING$1 && schedule2.state < ENDING$1;
    schedule2.state = ENDED$1;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node2.__transition;
}
function selection_interrupt$1(name) {
  return this.each(function() {
    interrupt$1(this, name);
  });
}
function tweenRemove$1(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$3(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction$1(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$3(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween$1(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get$3(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove$1 : tweenFunction$1)(id2, name, value));
}
function tweenValue$1(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule2 = set$3(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node2) {
    return get$3(node2, id2).value[name];
  };
}
function interpolate$1(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber$1 : b instanceof color$2 ? interpolateRgb$1 : (c = color$2(b)) ? (b = c, interpolateRgb$1) : interpolateString$1)(a, b);
}
function attrRemove$3(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$3(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$3(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS$3(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction$3(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS$3(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr$1(name, value) {
  var fullname = namespace$2(name), i = fullname === "transform" ? interpolateTransformSvg$1 : interpolate$1;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$3 : attrFunction$3)(fullname, i, tweenValue$1(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$3 : attrRemove$3)(fullname) : (fullname.local ? attrConstantNS$3 : attrConstant$3)(fullname, i, value));
}
function attrInterpolate$1(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS$1(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS$1(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS$1(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween$1(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate$1(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween$1(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace$2(name);
  return this.tween(key, (fullname.local ? attrTweenNS$1 : attrTween$1)(fullname, value));
}
function delayFunction$1(id2, value) {
  return function() {
    init$1(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant$1(id2, value) {
  return value = +value, function() {
    init$1(this, id2).delay = value;
  };
}
function transition_delay$1(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction$1 : delayConstant$1)(id2, value)) : get$3(this.node(), id2).delay;
}
function durationFunction$1(id2, value) {
  return function() {
    set$3(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant$1(id2, value) {
  return value = +value, function() {
    set$3(this, id2).duration = value;
  };
}
function transition_duration$1(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction$1 : durationConstant$1)(id2, value)) : get$3(this.node(), id2).duration;
}
function easeConstant$1(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$3(this, id2).ease = value;
  };
}
function transition_ease$1(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant$1(id2, value)) : get$3(this.node(), id2).ease;
}
function easeVarying$1(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set$3(this, id2).ease = v;
  };
}
function transition_easeVarying$1(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying$1(this._id, value));
}
function transition_filter$1(match) {
  if (typeof match !== "function")
    match = matcher$2(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition$1(subgroups, this._parents, this._name, this._id);
}
function transition_merge$1(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition$1(merges, this._parents, this._name, this._id);
}
function start$1(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction$1(id2, name, listener) {
  var on0, on1, sit = start$1(name) ? init$1 : set$3;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on$1(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$3(this.node(), id2).on.on(name) : this.each(onFunction$1(id2, name, listener));
}
function removeFunction$1(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove$1() {
  return this.on("end.remove", removeFunction$1(this._id));
}
function transition_select$1(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector$2(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule$1(subgroup[i], name, id2, i, subgroup, get$3(node2, id2));
      }
    }
  }
  return new Transition$1(subgroups, this._parents, name, id2);
}
function transition_selectAll$1(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll$2(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children2 = select2.call(node2, node2.__data__, i, group), child, inherit2 = get$3(node2, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule$1(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node2);
      }
    }
  }
  return new Transition$1(subgroups, parents, name, id2);
}
var Selection$3 = selection$1.prototype.constructor;
function transition_selection$1() {
  return new Selection$3(this._groups, this._parents);
}
function styleNull$1(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue$2(this, name), string1 = (this.style.removeProperty(name), styleValue$2(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove$3(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$3(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue$2(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction$3(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue$2(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue$2(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove$1(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$3(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove$3(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style$1(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss$1 : interpolate$1;
  return value == null ? this.styleTween(name, styleNull$1(name, i)).on("end.style." + name, styleRemove$3(name)) : typeof value === "function" ? this.styleTween(name, styleFunction$3(name, i, tweenValue$1(this, "style." + name, value))).each(styleMaybeRemove$1(this._id, name)) : this.styleTween(name, styleConstant$3(name, i, value), priority).on("end.style." + name, null);
}
function styleInterpolate$1(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween$1(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate$1(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween$1(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween$1(name, value, priority == null ? "" : priority));
}
function textConstant$3(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$3(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text$1(value) {
  return this.tween("text", typeof value === "function" ? textFunction$3(tweenValue$1(this, "text", value)) : textConstant$3(value == null ? "" : value + ""));
}
function textInterpolate$1(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween$1(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate$1(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween$1(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween$1(value));
}
function transition_transition$1() {
  var name = this._name, id0 = this._id, id1 = newId$1();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get$3(node2, id0);
        schedule$1(node2, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition$1(groups, this._parents, name, id1);
}
function transition_end$1() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule2 = set$3(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve();
  });
}
var id$1 = 0;
function Transition$1(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId$1() {
  return ++id$1;
}
var selection_prototype$1 = selection$1.prototype;
Transition$1.prototype = {
  constructor: Transition$1,
  select: transition_select$1,
  selectAll: transition_selectAll$1,
  selectChild: selection_prototype$1.selectChild,
  selectChildren: selection_prototype$1.selectChildren,
  filter: transition_filter$1,
  merge: transition_merge$1,
  selection: transition_selection$1,
  transition: transition_transition$1,
  call: selection_prototype$1.call,
  nodes: selection_prototype$1.nodes,
  node: selection_prototype$1.node,
  size: selection_prototype$1.size,
  empty: selection_prototype$1.empty,
  each: selection_prototype$1.each,
  on: transition_on$1,
  attr: transition_attr$1,
  attrTween: transition_attrTween$1,
  style: transition_style$1,
  styleTween: transition_styleTween$1,
  text: transition_text$1,
  textTween: transition_textTween$1,
  remove: transition_remove$1,
  tween: transition_tween$1,
  delay: transition_delay$1,
  duration: transition_duration$1,
  ease: transition_ease$1,
  easeVarying: transition_easeVarying$1,
  end: transition_end$1,
  [Symbol.iterator]: selection_prototype$1[Symbol.iterator]
};
function cubicInOut$1(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming$1 = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut$1
};
function inherit$1(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition$1(name) {
  var id2, timing;
  if (name instanceof Transition$1) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId$1(), (timing = defaultTiming$1).time = now$1(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule$1(node2, name, id2, i, group, timing || inherit$1(node2, id2));
      }
    }
  }
  return new Transition$1(groups, this._parents, name, id2);
}
selection$1.prototype.interrupt = selection_interrupt$1;
selection$1.prototype.transition = selection_transition$1;
const constant$4 = (x) => () => x;
function ZoomEvent$1(type, {
  sourceEvent: sourceEvent2,
  target: target2,
  transform,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    transform: { value: transform, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform$1(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform$1.prototype = {
  constructor: Transform$1,
  scale: function(k) {
    return k === 1 ? this : new Transform$1(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform$1(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity$2 = new Transform$1(1, 0, 0);
Transform$1.prototype;
function nopropagation$2(event) {
  event.stopImmediatePropagation();
}
function noevent$3(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter$2(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent$1() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform$1() {
  return this.__zoom || identity$2;
}
function defaultWheelDelta$1(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable$2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain$1(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom$1() {
  var filter2 = defaultFilter$2, extent = defaultExtent$1, constrain = defaultConstrain$1, wheelDelta = defaultWheelDelta$1, touchable = defaultTouchable$2, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom$1, listeners = dispatch$2("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform$1).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform$1);
    if (collection !== selection2) {
      schedule2(collection, transform, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom2.translateBy = function(selection2, x, y, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x, y, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity$2.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform$1(k, transform.x, transform.y);
  }
  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform$1(transform.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition2, transform, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate2(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform$1(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select$2(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent$1(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer$2(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt$1(this);
      g.start();
    }
    noevent$3(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select$2(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer$2(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable$1(event.view);
    nopropagation$2(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt$1(this);
    g.start();
    function mousemoved(event2) {
      noevent$3(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer$2(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag$2(event2.view, g.moved);
      noevent$3(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer$2(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent$3(event);
    if (duration > 0)
      select$2(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else
      select$2(this).call(zoom2.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation$2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer$2(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt$1(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent$3(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer$2(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation$2(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer$2(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select$2(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$4(+_), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$4(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$4(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$4([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}
var Position = /* @__PURE__ */ ((Position2) => {
  Position2["Left"] = "left";
  Position2["Top"] = "top";
  Position2["Right"] = "right";
  Position2["Bottom"] = "bottom";
  return Position2;
})(Position || {});
var SelectionMode = /* @__PURE__ */ ((SelectionMode2) => {
  SelectionMode2["Partial"] = "partial";
  SelectionMode2["Full"] = "full";
  return SelectionMode2;
})(SelectionMode || {});
var ConnectionLineType = /* @__PURE__ */ ((ConnectionLineType2) => {
  ConnectionLineType2["Bezier"] = "default";
  ConnectionLineType2["SimpleBezier"] = "simple-bezier";
  ConnectionLineType2["Straight"] = "straight";
  ConnectionLineType2["Step"] = "step";
  ConnectionLineType2["SmoothStep"] = "smoothstep";
  return ConnectionLineType2;
})(ConnectionLineType || {});
var ConnectionMode = /* @__PURE__ */ ((ConnectionMode2) => {
  ConnectionMode2["Strict"] = "strict";
  ConnectionMode2["Loose"] = "loose";
  return ConnectionMode2;
})(ConnectionMode || {});
var MarkerType = /* @__PURE__ */ ((MarkerType2) => {
  MarkerType2["Arrow"] = "arrow";
  MarkerType2["ArrowClosed"] = "arrowclosed";
  return MarkerType2;
})(MarkerType || {});
var PanOnScrollMode = /* @__PURE__ */ ((PanOnScrollMode2) => {
  PanOnScrollMode2["Free"] = "free";
  PanOnScrollMode2["Vertical"] = "vertical";
  PanOnScrollMode2["Horizontal"] = "horizontal";
  return PanOnScrollMode2;
})(PanOnScrollMode || {});
var PanelPosition = /* @__PURE__ */ ((PanelPosition2) => {
  PanelPosition2["TopLeft"] = "top-left";
  PanelPosition2["TopCenter"] = "top-center";
  PanelPosition2["TopRight"] = "top-right";
  PanelPosition2["BottomLeft"] = "bottom-left";
  PanelPosition2["BottomCenter"] = "bottom-center";
  PanelPosition2["BottomRight"] = "bottom-right";
  return PanelPosition2;
})(PanelPosition || {});
function isInputDOMNode(event) {
  var _a, _b;
  const target2 = ((_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)) == null ? void 0 : _b[0]) || event.target;
  const hasAttribute = typeof (target2 == null ? void 0 : target2.hasAttribute) === "function" ? target2.hasAttribute("contenteditable") : false;
  const closest = typeof (target2 == null ? void 0 : target2.closest) === "function" ? target2.closest(".nokey") : null;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(target2 == null ? void 0 : target2.nodeName) || hasAttribute || !!closest;
}
function wasModifierPressed(event) {
  return event.ctrlKey || event.metaKey || event.shiftKey;
}
function isKeyMatch(pressedKey, keyToMatch, pressedKeys, isKeyUp) {
  const keyCombination = keyToMatch.split("+").map((k) => k.trim().toLowerCase());
  if (keyCombination.length === 1) {
    return pressedKey.toLowerCase() === keyToMatch.toLowerCase();
  }
  if (isKeyUp) {
    pressedKeys.delete(pressedKey.toLowerCase());
  } else {
    pressedKeys.add(pressedKey.toLowerCase());
  }
  return keyCombination.every(
    (key, index) => pressedKeys.has(key) && Array.from(pressedKeys.values())[index] === keyCombination[index]
  );
}
function createKeyPredicate(keyFilter, pressedKeys) {
  return (event) => {
    if (!event.code && !event.key) {
      return false;
    }
    const keyOrCode = useKeyOrCode(event.code, keyFilter);
    if (Array.isArray(keyFilter)) {
      return keyFilter.some((key) => isKeyMatch(event[keyOrCode], key, pressedKeys, event.type === "keyup"));
    }
    return isKeyMatch(event[keyOrCode], keyFilter, pressedKeys, event.type === "keyup");
  };
}
function useKeyOrCode(code, keysToWatch) {
  if (typeof keysToWatch === "string") {
    return code === keysToWatch ? "code" : "key";
  }
  return keysToWatch.includes(code) ? "code" : "key";
}
function useKeyPress(keyFilter, options) {
  const actInsideInputWithModifier = toRef(() => toValue$1(options == null ? void 0 : options.actInsideInputWithModifier) ?? false);
  const target2 = toRef(() => toValue$1(options == null ? void 0 : options.target) ?? window);
  const isPressed = ref(toValue$1(keyFilter) === true);
  let modifierPressed = false;
  const pressedKeys = /* @__PURE__ */ new Set();
  let currentFilter = createKeyFilterFn(toValue$1(keyFilter));
  watch(
    () => toValue$1(keyFilter),
    (nextKeyFilter, previousKeyFilter) => {
      if (typeof previousKeyFilter === "boolean" && typeof nextKeyFilter !== "boolean") {
        reset();
      }
      currentFilter = createKeyFilterFn(nextKeyFilter);
    },
    {
      immediate: true
    }
  );
  onMounted(() => {
    useEventListener(window, ["blur", "contextmenu"], reset);
  });
  onKeyStroke(
    (...args) => currentFilter(...args),
    (e) => {
      modifierPressed = wasModifierPressed(e);
      const preventAction = (!modifierPressed || modifierPressed && !actInsideInputWithModifier.value) && isInputDOMNode(e);
      if (preventAction) {
        return;
      }
      e.preventDefault();
      isPressed.value = true;
    },
    { eventName: "keydown", target: target2 }
  );
  onKeyStroke(
    (...args) => currentFilter(...args),
    (e) => {
      if (isPressed.value) {
        const preventAction = (!modifierPressed || modifierPressed && !actInsideInputWithModifier.value) && isInputDOMNode(e);
        if (preventAction) {
          return;
        }
        reset();
      }
    },
    { eventName: "keyup", target: target2 }
  );
  function reset() {
    modifierPressed = false;
    pressedKeys.clear();
    isPressed.value = false;
  }
  function createKeyFilterFn(keyFilter2) {
    if (keyFilter2 === null) {
      reset();
      return () => false;
    }
    if (typeof keyFilter2 === "boolean") {
      reset();
      isPressed.value = keyFilter2;
      return () => false;
    }
    if (Array.isArray(keyFilter2) || typeof keyFilter2 === "string") {
      return createKeyPredicate(keyFilter2, pressedKeys);
    }
    return keyFilter2;
  }
  return isPressed;
}
const ARIA_NODE_DESC_KEY = "vue-flow__node-desc";
const ARIA_EDGE_DESC_KEY = "vue-flow__edge-desc";
const ARIA_LIVE_MESSAGE = "vue-flow__aria-live";
const elementSelectionKeys = ["Enter", " ", "Escape"];
const arrowKeyDiffs = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
function nodeToRect(node2) {
  return {
    ...node2.computedPosition || { x: 0, y: 0 },
    width: node2.dimensions.width || 0,
    height: node2.dimensions.height || 0
  };
}
function getOverlappingArea(rectA, rectB) {
  const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));
  const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));
  return Math.ceil(xOverlap * yOverlap);
}
function getDimensions(node2) {
  return {
    width: node2.offsetWidth,
    height: node2.offsetHeight
  };
}
function clamp(val, min = 0, max = 1) {
  return Math.min(Math.max(val, min), max);
}
function clampPosition(position2, extent) {
  return {
    x: clamp(position2.x, extent[0][0], extent[1][0]),
    y: clamp(position2.y, extent[0][1], extent[1][1])
  };
}
function getHostForElement(element) {
  const doc = element.getRootNode();
  if ("elementFromPoint" in doc) {
    return doc;
  }
  return window.document;
}
function isEdge(element) {
  return element && typeof element === "object" && "id" in element && "source" in element && "target" in element;
}
function isNode(element) {
  return element && typeof element === "object" && "id" in element && "position" in element && !isEdge(element);
}
function isGraphNode(element) {
  return isNode(element) && "computedPosition" in element;
}
function isNumeric(n) {
  return !Number.isNaN(n) && Number.isFinite(n);
}
function isRect(obj) {
  return isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);
}
function parseNode(node2, existingNode, parentNode) {
  const initialState = {
    id: node2.id.toString(),
    type: node2.type ?? "default",
    dimensions: markRaw({
      width: 0,
      height: 0
    }),
    computedPosition: markRaw({
      z: 0,
      ...node2.position
    }),
    // todo: shouldn't be defined initially, as we want to use handleBounds to check if a node was actually initialized or not
    handleBounds: {
      source: [],
      target: []
    },
    draggable: void 0,
    selectable: void 0,
    connectable: void 0,
    focusable: void 0,
    selected: false,
    dragging: false,
    resizing: false,
    initialized: false,
    isParent: false,
    position: {
      x: 0,
      y: 0
    },
    data: isDef(node2.data) ? node2.data : {},
    events: markRaw(isDef(node2.events) ? node2.events : {})
  };
  return Object.assign(existingNode ?? initialState, node2, { id: node2.id.toString(), parentNode });
}
function parseEdge(edge2, existingEdge, defaultEdgeOptions) {
  var _a, _b;
  const initialState = {
    id: edge2.id.toString(),
    type: edge2.type ?? (existingEdge == null ? void 0 : existingEdge.type) ?? "default",
    source: edge2.source.toString(),
    target: edge2.target.toString(),
    sourceHandle: (_a = edge2.sourceHandle) == null ? void 0 : _a.toString(),
    targetHandle: (_b = edge2.targetHandle) == null ? void 0 : _b.toString(),
    updatable: edge2.updatable ?? (defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.updatable),
    selectable: edge2.selectable ?? (defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.selectable),
    focusable: edge2.focusable ?? (defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.focusable),
    data: isDef(edge2.data) ? edge2.data : {},
    events: markRaw(isDef(edge2.events) ? edge2.events : {}),
    label: edge2.label ?? "",
    interactionWidth: edge2.interactionWidth ?? (defaultEdgeOptions == null ? void 0 : defaultEdgeOptions.interactionWidth),
    ...defaultEdgeOptions ?? {}
  };
  return Object.assign(existingEdge ?? initialState, edge2, { id: edge2.id.toString() });
}
function getConnectedElements(nodeOrId, nodes, edges, dir) {
  const id2 = typeof nodeOrId === "string" ? nodeOrId : nodeOrId.id;
  const connectedIds = /* @__PURE__ */ new Set();
  const origin = dir === "source" ? "target" : "source";
  for (const edge2 of edges) {
    if (edge2[origin] === id2) {
      connectedIds.add(edge2[dir]);
    }
  }
  return nodes.filter((n) => connectedIds.has(n.id));
}
function getOutgoers(...args) {
  if (args.length === 3) {
    const [nodeOrId2, nodes, edges] = args;
    return getConnectedElements(nodeOrId2, nodes, edges, "target");
  }
  const [nodeOrId, elements] = args;
  const nodeId = typeof nodeOrId === "string" ? nodeOrId : nodeOrId.id;
  const outgoers = elements.filter((el) => isEdge(el) && el.source === nodeId);
  return outgoers.map((edge2) => elements.find((el) => isNode(el) && el.id === edge2.target));
}
function getIncomers(...args) {
  if (args.length === 3) {
    const [nodeOrId2, nodes, edges] = args;
    return getConnectedElements(nodeOrId2, nodes, edges, "source");
  }
  const [nodeOrId, elements] = args;
  const nodeId = typeof nodeOrId === "string" ? nodeOrId : nodeOrId.id;
  const incomers = elements.filter((el) => isEdge(el) && el.target === nodeId);
  return incomers.map((edge2) => elements.find((el) => isNode(el) && el.id === edge2.source));
}
function getEdgeId({ source, sourceHandle, target: target2, targetHandle }) {
  return `vueflow__edge-${source}${sourceHandle ?? ""}-${target2}${targetHandle ?? ""}`;
}
function connectionExists(edge2, elements) {
  return elements.some(
    (el) => isEdge(el) && el.source === edge2.source && el.target === edge2.target && (el.sourceHandle === edge2.sourceHandle || !el.sourceHandle && !edge2.sourceHandle) && (el.targetHandle === edge2.targetHandle || !el.targetHandle && !edge2.targetHandle)
  );
}
function rendererPointToPoint({ x, y }, { x: tx, y: ty, zoom: tScale }) {
  return {
    x: x * tScale + tx,
    y: y * tScale + ty
  };
}
function pointToRendererPoint({ x, y }, { x: tx, y: ty, zoom: tScale }, snapToGrid = false, [snapX, snapY] = [1, 1]) {
  const position2 = {
    x: (x - tx) / tScale,
    y: (y - ty) / tScale
  };
  if (snapToGrid) {
    return {
      x: snapX * Math.round(position2.x / snapX),
      y: snapY * Math.round(position2.y / snapY)
    };
  }
  return position2;
}
function getBoundsOfBoxes(box1, box2) {
  return {
    x: Math.min(box1.x, box2.x),
    y: Math.min(box1.y, box2.y),
    x2: Math.max(box1.x2, box2.x2),
    y2: Math.max(box1.y2, box2.y2)
  };
}
function rectToBox({ x, y, width, height }) {
  return {
    x,
    y,
    x2: x + width,
    y2: y + height
  };
}
function boxToRect({ x, y, x2, y2 }) {
  return {
    x,
    y,
    width: x2 - x,
    height: y2 - y
  };
}
function getBoundsofRects(rect1, rect2) {
  return boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));
}
function getRectOfNodes(nodes) {
  let box = {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY,
    x2: Number.NEGATIVE_INFINITY,
    y2: Number.NEGATIVE_INFINITY
  };
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    box = getBoundsOfBoxes(
      box,
      rectToBox({
        ...node2.computedPosition,
        ...node2.dimensions
      })
    );
  }
  return boxToRect(box);
}
function getNodesInside(nodes, rect, viewport = { x: 0, y: 0, zoom: 1 }, partially = false, excludeNonSelectableNodes = false) {
  const paneRect = {
    ...pointToRendererPoint(rect, viewport),
    width: rect.width / viewport.zoom,
    height: rect.height / viewport.zoom
  };
  const visibleNodes = [];
  for (const node2 of nodes) {
    const { dimensions, selectable = true, hidden = false } = node2;
    const width = dimensions.width ?? node2.width ?? null;
    const height = dimensions.height ?? node2.height ?? null;
    if (excludeNonSelectableNodes && !selectable || hidden) {
      continue;
    }
    const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node2));
    const notInitialized = width === null || height === null;
    const partiallyVisible = partially && overlappingArea > 0;
    const area = (width ?? 0) * (height ?? 0);
    const isVisible = notInitialized || partiallyVisible || overlappingArea >= area;
    if (isVisible || node2.dragging) {
      visibleNodes.push(node2);
    }
  }
  return visibleNodes;
}
function getConnectedEdges(nodesOrId, edges) {
  const nodeIds = /* @__PURE__ */ new Set();
  if (typeof nodesOrId === "string") {
    nodeIds.add(nodesOrId);
  } else if (nodesOrId.length >= 1) {
    for (const n of nodesOrId) {
      nodeIds.add(n.id);
    }
  }
  return edges.filter((edge2) => nodeIds.has(edge2.source) || nodeIds.has(edge2.target));
}
function getTransformForBounds(bounds, width, height, minZoom, maxZoom, padding = 0.1, offset = { x: 0, y: 0 }) {
  const xZoom = width / (bounds.width * (1 + padding));
  const yZoom = height / (bounds.height * (1 + padding));
  const zoom2 = Math.min(xZoom, yZoom);
  const clampedZoom = clamp(zoom2, minZoom, maxZoom);
  const boundsCenterX = bounds.x + bounds.width / 2;
  const boundsCenterY = bounds.y + bounds.height / 2;
  const x = width / 2 - boundsCenterX * clampedZoom + (offset.x ?? 0);
  const y = height / 2 - boundsCenterY * clampedZoom + (offset.y ?? 0);
  return { x, y, zoom: clampedZoom };
}
function getXYZPos(parentPos, computedPosition) {
  return {
    x: computedPosition.x + parentPos.x,
    y: computedPosition.y + parentPos.y,
    z: (parentPos.z > computedPosition.z ? parentPos.z : computedPosition.z) + 1
  };
}
function isParentSelected(node2, findNode) {
  if (!node2.parentNode) {
    return false;
  }
  const parent = findNode(node2.parentNode);
  if (!parent) {
    return false;
  }
  if (parent.selected) {
    return true;
  }
  return isParentSelected(parent, findNode);
}
function getMarkerId(marker, vueFlowId) {
  if (typeof marker === "undefined") {
    return "";
  }
  if (typeof marker === "string") {
    return marker;
  }
  const idPrefix = vueFlowId ? `${vueFlowId}__` : "";
  return `${idPrefix}${Object.keys(marker).sort().map((key) => `${key}=${marker[key]}`).join("&")}`;
}
function calcAutoPanVelocity(value, min, max) {
  if (value < min) {
    return clamp(Math.abs(value - min), 1, min) / min;
  }
  if (value > max) {
    return -clamp(Math.abs(value - max), 1, min) / min;
  }
  return 0;
}
function calcAutoPan(pos, bounds, speed = 15, distance2 = 40) {
  const xMovement = calcAutoPanVelocity(pos.x, distance2, bounds.width - distance2) * speed;
  const yMovement = calcAutoPanVelocity(pos.y, distance2, bounds.height - distance2) * speed;
  return [xMovement, yMovement];
}
function handleParentExpand(updateItem, parent) {
  if (parent) {
    const extendWidth = updateItem.position.x + updateItem.dimensions.width - parent.dimensions.width;
    const extendHeight = updateItem.position.y + updateItem.dimensions.height - parent.dimensions.height;
    if (extendWidth > 0 || extendHeight > 0 || updateItem.position.x < 0 || updateItem.position.y < 0) {
      let parentStyles = {};
      if (typeof parent.style === "function") {
        parentStyles = { ...parent.style(parent) };
      } else if (parent.style) {
        parentStyles = { ...parent.style };
      }
      parentStyles.width = parentStyles.width ?? `${parent.dimensions.width}px`;
      parentStyles.height = parentStyles.height ?? `${parent.dimensions.height}px`;
      if (extendWidth > 0) {
        if (typeof parentStyles.width === "string") {
          const currWidth = Number(parentStyles.width.replace("px", ""));
          parentStyles.width = `${currWidth + extendWidth}px`;
        } else {
          parentStyles.width += extendWidth;
        }
      }
      if (extendHeight > 0) {
        if (typeof parentStyles.height === "string") {
          const currWidth = Number(parentStyles.height.replace("px", ""));
          parentStyles.height = `${currWidth + extendHeight}px`;
        } else {
          parentStyles.height += extendHeight;
        }
      }
      if (updateItem.position.x < 0) {
        const xDiff = Math.abs(updateItem.position.x);
        parent.position.x = parent.position.x - xDiff;
        if (typeof parentStyles.width === "string") {
          const currWidth = Number(parentStyles.width.replace("px", ""));
          parentStyles.width = `${currWidth + xDiff}px`;
        } else {
          parentStyles.width += xDiff;
        }
        updateItem.position.x = 0;
      }
      if (updateItem.position.y < 0) {
        const yDiff = Math.abs(updateItem.position.y);
        parent.position.y = parent.position.y - yDiff;
        if (typeof parentStyles.height === "string") {
          const currWidth = Number(parentStyles.height.replace("px", ""));
          parentStyles.height = `${currWidth + yDiff}px`;
        } else {
          parentStyles.height += yDiff;
        }
        updateItem.position.y = 0;
      }
      parent.dimensions.width = Number(parentStyles.width.toString().replace("px", ""));
      parent.dimensions.height = Number(parentStyles.height.toString().replace("px", ""));
      if (typeof parent.style === "function") {
        parent.style = (p) => {
          const styleFunc = parent.style;
          return {
            ...styleFunc(p),
            ...parentStyles
          };
        };
      } else {
        parent.style = {
          ...parent.style,
          ...parentStyles
        };
      }
    }
  }
}
function applyChanges(changes, elements) {
  var _a, _b;
  const addRemoveChanges = changes.filter((c) => c.type === "add" || c.type === "remove");
  for (const change of addRemoveChanges) {
    if (change.type === "add") {
      const index = elements.findIndex((el) => el.id === change.item.id);
      if (index === -1) {
        elements.push(change.item);
      }
    } else if (change.type === "remove") {
      const index = elements.findIndex((el) => el.id === change.id);
      if (index !== -1) {
        elements.splice(index, 1);
      }
    }
  }
  const elementIds = elements.map((el) => el.id);
  for (const element of elements) {
    for (const currentChange of changes) {
      if (currentChange.id !== element.id) {
        continue;
      }
      switch (currentChange.type) {
        case "select":
          element.selected = currentChange.selected;
          break;
        case "position":
          if (isGraphNode(element)) {
            if (typeof currentChange.position !== "undefined") {
              element.position = currentChange.position;
            }
            if (typeof currentChange.dragging !== "undefined") {
              element.dragging = currentChange.dragging;
            }
            if (element.expandParent && element.parentNode) {
              const parent = elements[elementIds.indexOf(element.parentNode)];
              if (parent && isGraphNode(parent)) {
                handleParentExpand(element, parent);
              }
            }
          }
          break;
        case "dimensions":
          if (isGraphNode(element)) {
            if (typeof currentChange.dimensions !== "undefined") {
              element.dimensions = currentChange.dimensions;
            }
            if (typeof currentChange.updateStyle !== "undefined" && currentChange.updateStyle) {
              element.style = {
                ...element.style || {},
                width: `${(_a = currentChange.dimensions) == null ? void 0 : _a.width}px`,
                height: `${(_b = currentChange.dimensions) == null ? void 0 : _b.height}px`
              };
            }
            if (typeof currentChange.resizing !== "undefined") {
              element.resizing = currentChange.resizing;
            }
            if (element.expandParent && element.parentNode) {
              const parent = elements[elementIds.indexOf(element.parentNode)];
              if (parent && isGraphNode(parent)) {
                const parentInit = !!parent.dimensions.width && !!parent.dimensions.height;
                if (!parentInit) {
                  nextTick(() => {
                    handleParentExpand(element, parent);
                  });
                } else {
                  handleParentExpand(element, parent);
                }
              }
            }
          }
          break;
      }
    }
  }
  return elements;
}
function createSelectionChange(id2, selected2) {
  return {
    id: id2,
    type: "select",
    selected: selected2
  };
}
function createAdditionChange(item) {
  return {
    item,
    type: "add"
  };
}
function createNodeRemoveChange(id2) {
  return {
    id: id2,
    type: "remove"
  };
}
function createEdgeRemoveChange(id2, source, target2, sourceHandle, targetHandle) {
  return {
    id: id2,
    source,
    target: target2,
    sourceHandle: sourceHandle || null,
    targetHandle: targetHandle || null,
    type: "remove"
  };
}
function getSelectionChanges(items, selectedIds = /* @__PURE__ */ new Set(), mutateItem = false) {
  const changes = [];
  for (const [id2, item] of items) {
    const willBeSelected = selectedIds.has(id2);
    if (!(item.selected === void 0 && !willBeSelected) && item.selected !== willBeSelected) {
      if (mutateItem) {
        item.selected = willBeSelected;
      }
      changes.push(createSelectionChange(item.id, willBeSelected));
    }
  }
  return changes;
}
function createExtendedEventHook(defaultHandler) {
  const fns = /* @__PURE__ */ new Set();
  let hasDefaultHandler = false;
  const hasListeners = () => fns.size > 0;
  if (defaultHandler) {
    hasDefaultHandler = true;
    fns.add(defaultHandler);
  }
  const off = (fn) => {
    fns.delete(fn);
  };
  const on = (fn) => {
    if (defaultHandler && hasDefaultHandler) {
      fns.delete(defaultHandler);
    }
    fns.add(fn);
    const offFn = () => {
      off(fn);
      if (defaultHandler && hasDefaultHandler) {
        fns.add(defaultHandler);
      }
    };
    tryOnScopeDispose(offFn);
    return {
      off: offFn
    };
  };
  const trigger2 = (param) => {
    return Promise.all(Array.from(fns).map((fn) => fn(param)));
  };
  return {
    on,
    off,
    trigger: trigger2,
    hasListeners,
    fns
  };
}
function hasSelector(target2, selector2, node2) {
  let current = target2;
  do {
    if (current && current.matches(selector2)) {
      return true;
    } else if (current === node2) {
      return false;
    }
    current = current.parentElement;
  } while (current);
  return false;
}
function getDragItems(nodes, nodesDraggable, mousePos, findNode, nodeId) {
  var _a, _b;
  const dragItems = [];
  for (const node2 of nodes) {
    if ((node2.selected || node2.id === nodeId) && (!node2.parentNode || !isParentSelected(node2, findNode)) && (node2.draggable || nodesDraggable && typeof node2.draggable === "undefined")) {
      dragItems.push(
        markRaw({
          id: node2.id,
          position: node2.position || { x: 0, y: 0 },
          distance: {
            x: mousePos.x - ((_a = node2.computedPosition) == null ? void 0 : _a.x) || 0,
            y: mousePos.y - ((_b = node2.computedPosition) == null ? void 0 : _b.y) || 0
          },
          from: node2.computedPosition,
          extent: node2.extent,
          parentNode: node2.parentNode,
          dimensions: node2.dimensions,
          expandParent: node2.expandParent
        })
      );
    }
  }
  return dragItems;
}
function getEventHandlerParams({
  id: id2,
  dragItems,
  findNode
}) {
  const extendedDragItems = [];
  for (const dragItem of dragItems) {
    const node2 = findNode(dragItem.id);
    if (node2) {
      extendedDragItems.push(node2);
    }
  }
  return [id2 ? extendedDragItems.find((n) => n.id === id2) : extendedDragItems[0], extendedDragItems];
}
function getExtentPadding(padding) {
  if (Array.isArray(padding)) {
    switch (padding.length) {
      case 1:
        return [padding[0], padding[0], padding[0], padding[0]];
      case 2:
        return [padding[0], padding[1], padding[0], padding[1]];
      case 3:
        return [padding[0], padding[1], padding[2], padding[1]];
      case 4:
        return padding;
      default:
        return [0, 0, 0, 0];
    }
  }
  return [padding, padding, padding, padding];
}
function getParentExtent(currentExtent, node2, parent) {
  const [top2, right2, bottom2, left2] = typeof currentExtent !== "string" ? getExtentPadding(currentExtent.padding) : [0, 0, 0, 0];
  if (parent && typeof parent.computedPosition.x !== "undefined" && typeof parent.computedPosition.y !== "undefined" && typeof parent.dimensions.width !== "undefined" && typeof parent.dimensions.height !== "undefined") {
    return [
      [parent.computedPosition.x + left2, parent.computedPosition.y + top2],
      [
        parent.computedPosition.x + parent.dimensions.width - right2,
        parent.computedPosition.y + parent.dimensions.height - bottom2
      ]
    ];
  }
  return false;
}
function getExtent(item, triggerError, extent, parent) {
  let currentExtent = item.extent || extent;
  if ((currentExtent === "parent" || !Array.isArray(currentExtent) && (currentExtent == null ? void 0 : currentExtent.range) === "parent") && !item.expandParent) {
    if (item.parentNode && parent && item.dimensions.width && item.dimensions.height) {
      const parentExtent = getParentExtent(currentExtent, item, parent);
      if (parentExtent) {
        currentExtent = parentExtent;
      }
    } else {
      triggerError(new VueFlowError(ErrorCode.NODE_EXTENT_INVALID, item.id));
      currentExtent = extent;
    }
  } else if (Array.isArray(currentExtent)) {
    const parentX = (parent == null ? void 0 : parent.computedPosition.x) || 0;
    const parentY = (parent == null ? void 0 : parent.computedPosition.y) || 0;
    currentExtent = [
      [currentExtent[0][0] + parentX, currentExtent[0][1] + parentY],
      [currentExtent[1][0] + parentX, currentExtent[1][1] + parentY]
    ];
  } else if (currentExtent !== "parent" && (currentExtent == null ? void 0 : currentExtent.range) && Array.isArray(currentExtent.range)) {
    const [top2, right2, bottom2, left2] = getExtentPadding(currentExtent.padding);
    const parentX = (parent == null ? void 0 : parent.computedPosition.x) || 0;
    const parentY = (parent == null ? void 0 : parent.computedPosition.y) || 0;
    currentExtent = [
      [currentExtent.range[0][0] + parentX + left2, currentExtent.range[0][1] + parentY + top2],
      [currentExtent.range[1][0] + parentX - right2, currentExtent.range[1][1] + parentY - bottom2]
    ];
  }
  return currentExtent === "parent" ? [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ] : currentExtent;
}
function clampNodeExtent({ width, height }, extent) {
  return [extent[0], [extent[1][0] - (width || 0), extent[1][1] - (height || 0)]];
}
function calcNextPosition(node2, nextPosition, triggerError, nodeExtent, parentNode) {
  const extent = clampNodeExtent(node2.dimensions, getExtent(node2, triggerError, nodeExtent, parentNode));
  const clampedPos = clampPosition(nextPosition, extent);
  return {
    position: {
      x: clampedPos.x - ((parentNode == null ? void 0 : parentNode.computedPosition.x) || 0),
      y: clampedPos.y - ((parentNode == null ? void 0 : parentNode.computedPosition.y) || 0)
    },
    computedPosition: clampedPos
  };
}
function getHandlePosition(node2, handle2, fallbackPosition = Position.Left) {
  const x = ((handle2 == null ? void 0 : handle2.x) ?? 0) + node2.computedPosition.x;
  const y = ((handle2 == null ? void 0 : handle2.y) ?? 0) + node2.computedPosition.y;
  const { width, height } = handle2 ?? getNodeDimensions(node2);
  const position2 = (handle2 == null ? void 0 : handle2.position) ?? fallbackPosition;
  switch (position2) {
    case Position.Top:
      return {
        x: x + width / 2,
        y
      };
    case Position.Right:
      return {
        x: x + width,
        y: y + height / 2
      };
    case Position.Bottom:
      return {
        x: x + width / 2,
        y: y + height
      };
    case Position.Left:
      return {
        x,
        y: y + height / 2
      };
  }
}
function getHandle(bounds = [], handleId) {
  if (!bounds.length) {
    return null;
  }
  return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;
}
function isEdgeVisible({
  sourcePos,
  targetPos,
  sourceWidth,
  sourceHeight,
  targetWidth,
  targetHeight,
  width,
  height,
  viewport
}) {
  const edgeBox = {
    x: Math.min(sourcePos.x, targetPos.x),
    y: Math.min(sourcePos.y, targetPos.y),
    x2: Math.max(sourcePos.x + sourceWidth, targetPos.x + targetWidth),
    y2: Math.max(sourcePos.y + sourceHeight, targetPos.y + targetHeight)
  };
  if (edgeBox.x === edgeBox.x2) {
    edgeBox.x2 += 1;
  }
  if (edgeBox.y === edgeBox.y2) {
    edgeBox.y2 += 1;
  }
  const viewBox = rectToBox({
    x: (0 - viewport.x) / viewport.zoom,
    y: (0 - viewport.y) / viewport.zoom,
    width: width / viewport.zoom,
    height: height / viewport.zoom
  });
  const xOverlap = Math.max(0, Math.min(viewBox.x2, edgeBox.x2) - Math.max(viewBox.x, edgeBox.x));
  const yOverlap = Math.max(0, Math.min(viewBox.y2, edgeBox.y2) - Math.max(viewBox.y, edgeBox.y));
  const overlappingArea = Math.ceil(xOverlap * yOverlap);
  return overlappingArea > 0;
}
function getEdgeZIndex(edge2, findNode, elevateEdgesOnSelect = false) {
  const hasZIndex = typeof edge2.zIndex === "number";
  let z = hasZIndex ? edge2.zIndex : 0;
  const source = findNode(edge2.source);
  const target2 = findNode(edge2.target);
  if (!source || !target2) {
    return 0;
  }
  if (elevateEdgesOnSelect) {
    z = hasZIndex ? edge2.zIndex : Math.max(source.computedPosition.z || 0, target2.computedPosition.z || 0);
  }
  return z;
}
var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
  ErrorCode2["MISSING_STYLES"] = "MISSING_STYLES";
  ErrorCode2["MISSING_VIEWPORT_DIMENSIONS"] = "MISSING_VIEWPORT_DIMENSIONS";
  ErrorCode2["NODE_INVALID"] = "NODE_INVALID";
  ErrorCode2["NODE_NOT_FOUND"] = "NODE_NOT_FOUND";
  ErrorCode2["NODE_MISSING_PARENT"] = "NODE_MISSING_PARENT";
  ErrorCode2["NODE_TYPE_MISSING"] = "NODE_TYPE_MISSING";
  ErrorCode2["NODE_EXTENT_INVALID"] = "NODE_EXTENT_INVALID";
  ErrorCode2["EDGE_INVALID"] = "EDGE_INVALID";
  ErrorCode2["EDGE_NOT_FOUND"] = "EDGE_NOT_FOUND";
  ErrorCode2["EDGE_SOURCE_MISSING"] = "EDGE_SOURCE_MISSING";
  ErrorCode2["EDGE_TARGET_MISSING"] = "EDGE_TARGET_MISSING";
  ErrorCode2["EDGE_TYPE_MISSING"] = "EDGE_TYPE_MISSING";
  ErrorCode2["EDGE_SOURCE_TARGET_SAME"] = "EDGE_SOURCE_TARGET_SAME";
  ErrorCode2["EDGE_SOURCE_TARGET_MISSING"] = "EDGE_SOURCE_TARGET_MISSING";
  ErrorCode2["EDGE_ORPHANED"] = "EDGE_ORPHANED";
  ErrorCode2["USEVUEFLOW_OPTIONS"] = "USEVUEFLOW_OPTIONS";
  return ErrorCode2;
})(ErrorCode || {});
const messages = {
  [
    "MISSING_STYLES"
    /* MISSING_STYLES */
  ]: () => `It seems that you haven't loaded the necessary styles. Please import '@vue-flow/core/dist/style.css' to ensure that the graph is rendered correctly`,
  [
    "MISSING_VIEWPORT_DIMENSIONS"
    /* MISSING_VIEWPORT_DIMENSIONS */
  ]: () => "The Vue Flow parent container needs a width and a height to render the graph",
  [
    "NODE_INVALID"
    /* NODE_INVALID */
  ]: (id2) => `Node is invalid
Node: ${id2}`,
  [
    "NODE_NOT_FOUND"
    /* NODE_NOT_FOUND */
  ]: (id2) => `Node not found
Node: ${id2}`,
  [
    "NODE_MISSING_PARENT"
    /* NODE_MISSING_PARENT */
  ]: (id2, parentId) => `Node is missing a parent
Node: ${id2}
Parent: ${parentId}`,
  [
    "NODE_TYPE_MISSING"
    /* NODE_TYPE_MISSING */
  ]: (type) => `Node type is missing
Type: ${type}`,
  [
    "NODE_EXTENT_INVALID"
    /* NODE_EXTENT_INVALID */
  ]: (id2) => `Only child nodes can use a parent extent
Node: ${id2}`,
  [
    "EDGE_INVALID"
    /* EDGE_INVALID */
  ]: (id2) => `An edge needs a source and a target
Edge: ${id2}`,
  [
    "EDGE_SOURCE_MISSING"
    /* EDGE_SOURCE_MISSING */
  ]: (id2, source) => `Edge source is missing
Edge: ${id2} 
Source: ${source}`,
  [
    "EDGE_TARGET_MISSING"
    /* EDGE_TARGET_MISSING */
  ]: (id2, target2) => `Edge target is missing
Edge: ${id2} 
Target: ${target2}`,
  [
    "EDGE_TYPE_MISSING"
    /* EDGE_TYPE_MISSING */
  ]: (type) => `Edge type is missing
Type: ${type}`,
  [
    "EDGE_SOURCE_TARGET_SAME"
    /* EDGE_SOURCE_TARGET_SAME */
  ]: (id2, source, target2) => `Edge source and target are the same
Edge: ${id2} 
Source: ${source} 
Target: ${target2}`,
  [
    "EDGE_SOURCE_TARGET_MISSING"
    /* EDGE_SOURCE_TARGET_MISSING */
  ]: (id2, source, target2) => `Edge source or target is missing
Edge: ${id2} 
Source: ${source} 
Target: ${target2}`,
  [
    "EDGE_ORPHANED"
    /* EDGE_ORPHANED */
  ]: (id2) => `Edge was orphaned (suddenly missing source or target) and has been removed
Edge: ${id2}`,
  [
    "EDGE_NOT_FOUND"
    /* EDGE_NOT_FOUND */
  ]: (id2) => `Edge not found
Edge: ${id2}`,
  // deprecation errors
  [
    "USEVUEFLOW_OPTIONS"
    /* USEVUEFLOW_OPTIONS */
  ]: () => `The options parameter is deprecated and will be removed in the next major version. Please use the id parameter instead`
};
class VueFlowError extends Error {
  constructor(code, ...args) {
    var _a;
    super((_a = messages[code]) == null ? void 0 : _a.call(messages, ...args));
    this.name = "VueFlowError";
    this.code = code;
    this.args = args;
  }
}
function isMouseEvent(event) {
  return "clientX" in event;
}
function getEventPosition(event, bounds) {
  var _a, _b;
  const isMouseTriggered = isMouseEvent(event);
  const evtX = isMouseTriggered ? event.clientX : (_a = event.touches) == null ? void 0 : _a[0].clientX;
  const evtY = isMouseTriggered ? event.clientY : (_b = event.touches) == null ? void 0 : _b[0].clientY;
  return {
    x: evtX - ((bounds == null ? void 0 : bounds.left) ?? 0),
    y: evtY - ((bounds == null ? void 0 : bounds.top) ?? 0)
  };
}
const isMacOs = () => {
  var _a;
  return typeof navigator !== "undefined" && ((_a = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a.indexOf("Mac")) >= 0;
};
function getNodeDimensions(node2) {
  var _a, _b;
  return {
    width: ((_a = node2.dimensions) == null ? void 0 : _a.width) ?? node2.width ?? 0,
    height: ((_b = node2.dimensions) == null ? void 0 : _b.height) ?? node2.height ?? 0
  };
}
function defaultValidHandleResult() {
  return {
    handleDomNode: null,
    isValid: false,
    connection: { source: "", target: "", sourceHandle: null, targetHandle: null },
    endHandle: null
  };
}
function resetRecentHandle(handleDomNode) {
  handleDomNode == null ? void 0 : handleDomNode.classList.remove("valid", "connecting", "vue-flow__handle-valid", "vue-flow__handle-connecting");
}
function getHandles(node2, handleBounds, type, currentHandle) {
  const connectionHandles = [];
  for (const handle2 of handleBounds[type] || []) {
    if (`${node2.id}-${handle2.id}-${type}` !== currentHandle) {
      const { x, y } = getHandlePosition(node2, handle2);
      connectionHandles.push({
        id: handle2.id || null,
        type,
        nodeId: node2.id,
        x,
        y
      });
    }
  }
  return connectionHandles;
}
function getClosestHandle(event, doc, pos, connectionRadius, handles, validator) {
  const { x, y } = getEventPosition(event);
  const domNodes = doc.elementsFromPoint(x, y);
  const handleBelow = domNodes.find((el) => el.classList.contains("vue-flow__handle"));
  if (handleBelow) {
    const handleNodeId = handleBelow.getAttribute("data-nodeid");
    if (handleNodeId) {
      const handleType = getHandleType(void 0, handleBelow);
      const handleId = handleBelow.getAttribute("data-handleid");
      const validHandleResult = validator({ nodeId: handleNodeId, id: handleId, type: handleType });
      if (validHandleResult) {
        const handle2 = handles.find((h2) => h2.nodeId === handleNodeId && h2.type === handleType && h2.id === handleId);
        return {
          handle: {
            id: handleId,
            type: handleType,
            nodeId: handleNodeId,
            x: (handle2 == null ? void 0 : handle2.x) || pos.x,
            y: (handle2 == null ? void 0 : handle2.y) || pos.y
          },
          validHandleResult
        };
      }
    }
  }
  let closestHandles = [];
  let minDistance = Number.POSITIVE_INFINITY;
  for (const handle2 of handles) {
    const distance2 = Math.sqrt((handle2.x - pos.x) ** 2 + (handle2.y - pos.y) ** 2);
    if (distance2 <= connectionRadius) {
      const validHandleResult = validator(handle2);
      if (distance2 <= minDistance) {
        if (distance2 < minDistance) {
          closestHandles = [{ handle: handle2, validHandleResult }];
        } else if (distance2 === minDistance) {
          closestHandles.push({
            handle: handle2,
            validHandleResult
          });
        }
        minDistance = distance2;
      }
    }
  }
  if (!closestHandles.length) {
    return { handle: null, validHandleResult: defaultValidHandleResult() };
  }
  if (closestHandles.length === 1) {
    return closestHandles[0];
  }
  const hasValidHandle = closestHandles.some(({ validHandleResult }) => validHandleResult.isValid);
  const hasTargetHandle = closestHandles.some(({ handle: handle2 }) => handle2.type === "target");
  return closestHandles.find(
    ({ handle: handle2, validHandleResult }) => hasTargetHandle ? handle2.type === "target" : hasValidHandle ? validHandleResult.isValid : true
  ) || closestHandles[0];
}
function isValidHandle(event, handle2, connectionMode, fromNodeId, fromHandleId, fromType, isValidConnection, doc, edges, nodes, findNode) {
  const isTarget = fromType === "target";
  const handleDomNode = doc.querySelector(`.vue-flow__handle[data-id="${handle2 == null ? void 0 : handle2.nodeId}-${handle2 == null ? void 0 : handle2.id}-${handle2 == null ? void 0 : handle2.type}"]`);
  const { x, y } = getEventPosition(event);
  const elementBelow = doc.elementFromPoint(x, y);
  const handleToCheck = (elementBelow == null ? void 0 : elementBelow.classList.contains("vue-flow__handle")) ? elementBelow : handleDomNode;
  const result = defaultValidHandleResult();
  if (handleToCheck) {
    result.handleDomNode = handleToCheck;
    const handleType = getHandleType(void 0, handleToCheck);
    const handleNodeId = handleToCheck.getAttribute("data-nodeid");
    const handleId = handleToCheck.getAttribute("data-handleid");
    const connectable = handleToCheck.classList.contains("connectable");
    const connectableEnd = handleToCheck.classList.contains("connectableend");
    const connection = {
      source: isTarget ? handleNodeId : fromNodeId,
      sourceHandle: isTarget ? handleId : fromHandleId,
      target: isTarget ? fromNodeId : handleNodeId,
      targetHandle: isTarget ? fromHandleId : handleId
    };
    result.connection = connection;
    const isConnectable = connectable && connectableEnd;
    const isValid = isConnectable && (connectionMode === ConnectionMode.Strict ? isTarget && handleType === "source" || !isTarget && handleType === "target" : handleNodeId !== fromNodeId || handleId !== fromHandleId);
    if (isValid) {
      result.isValid = isValidConnection(connection, {
        edges,
        nodes,
        sourceNode: findNode(connection.source),
        targetNode: findNode(connection.target)
      });
      result.endHandle = {
        nodeId: handleNodeId,
        handleId,
        type: handleType,
        position: result.isValid ? handleToCheck.getAttribute("data-handlepos") : null
      };
    }
  }
  return result;
}
function getHandleLookup({ nodes, nodeId, handleId, handleType }) {
  const handleLookup = [];
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    const { handleBounds } = node2;
    let sourceHandles = [];
    let targetHandles = [];
    if (handleBounds) {
      sourceHandles = getHandles(node2, handleBounds, "source", `${nodeId}-${handleId}-${handleType}`);
      targetHandles = getHandles(node2, handleBounds, "target", `${nodeId}-${handleId}-${handleType}`);
    }
    handleLookup.push(...sourceHandles, ...targetHandles);
  }
  return handleLookup;
}
function getHandleType(edgeUpdaterType, handleDomNode) {
  if (edgeUpdaterType) {
    return edgeUpdaterType;
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("target")) {
    return "target";
  } else if (handleDomNode == null ? void 0 : handleDomNode.classList.contains("source")) {
    return "source";
  }
  return null;
}
function getConnectionStatus(isInsideConnectionRadius, isHandleValid) {
  let connectionStatus = null;
  if (isHandleValid) {
    connectionStatus = "valid";
  } else if (isInsideConnectionRadius && !isHandleValid) {
    connectionStatus = "invalid";
  }
  return connectionStatus;
}
const productionEnvs = ["production", "prod"];
function warn(message, ...args) {
  if (isDev()) {
    console.warn(`[Vue Flow]: ${message}`, ...args);
  }
}
function isDev() {
  return !productionEnvs.includes("production");
}
function getHandleBounds(selector2, nodeElement, nodeBounds, zoom2) {
  const handles = nodeElement.querySelectorAll(`.vue-flow__handle${selector2}`);
  const handlesArray = Array.from(handles);
  return handlesArray.map((handle2) => {
    const handleBounds = handle2.getBoundingClientRect();
    return {
      id: handle2.getAttribute("data-handleid"),
      position: handle2.getAttribute("data-handlepos"),
      x: (handleBounds.left - nodeBounds.left) / zoom2,
      y: (handleBounds.top - nodeBounds.top) / zoom2,
      ...getDimensions(handle2)
    };
  });
}
function handleNodeClick(node2, multiSelectionActive, addSelectedNodes, removeSelectedNodes, nodesSelectionActive, unselect = false, nodeEl) {
  nodesSelectionActive.value = false;
  if (!node2.selected) {
    addSelectedNodes([node2]);
  } else if (unselect || node2.selected && multiSelectionActive) {
    removeSelectedNodes([node2]);
    nextTick(() => {
      nodeEl.blur();
    });
  }
}
function isDef(val) {
  const unrefVal = unref(val);
  return typeof unrefVal !== "undefined";
}
function addEdgeToStore(edgeParams, edges, triggerError, defaultEdgeOptions) {
  if (!edgeParams || !edgeParams.source || !edgeParams.target) {
    triggerError(new VueFlowError(ErrorCode.EDGE_INVALID, (edgeParams == null ? void 0 : edgeParams.id) ?? `[ID UNKNOWN]`));
    return false;
  }
  let edge2;
  if (isEdge(edgeParams)) {
    edge2 = edgeParams;
  } else {
    edge2 = {
      ...edgeParams,
      id: getEdgeId(edgeParams)
    };
  }
  edge2 = parseEdge(edge2, void 0, defaultEdgeOptions);
  if (connectionExists(edge2, edges)) {
    return false;
  }
  return edge2;
}
function updateEdgeAction(edge2, newConnection, edges, findEdge, shouldReplaceId, triggerError) {
  if (!newConnection.source || !newConnection.target) {
    triggerError(new VueFlowError(ErrorCode.EDGE_INVALID, edge2.id));
    return false;
  }
  const foundEdge = findEdge(edge2.id);
  if (!foundEdge) {
    triggerError(new VueFlowError(ErrorCode.EDGE_NOT_FOUND, edge2.id));
    return false;
  }
  const { id: id2, ...rest } = edge2;
  const newEdge = {
    ...rest,
    id: shouldReplaceId ? getEdgeId(newConnection) : id2,
    source: newConnection.source,
    target: newConnection.target,
    sourceHandle: newConnection.sourceHandle,
    targetHandle: newConnection.targetHandle
  };
  edges.splice(edges.indexOf(foundEdge), 1, newEdge);
  return newEdge;
}
function createGraphNodes(nodes, findNode, triggerError) {
  const parentNodes = {};
  const nextNodes = [];
  for (let i = 0; i < nodes.length; ++i) {
    const node2 = nodes[i];
    if (!isNode(node2)) {
      triggerError(
        new VueFlowError(ErrorCode.NODE_INVALID, node2 == null ? void 0 : node2.id) || `[ID UNKNOWN|INDEX ${i}]`
      );
      continue;
    }
    const parsed = parseNode(node2, findNode(node2.id), node2.parentNode);
    if (node2.parentNode) {
      parentNodes[node2.parentNode] = true;
    }
    nextNodes[i] = parsed;
  }
  for (const node2 of nextNodes) {
    const parentNode = findNode(node2.parentNode) || nextNodes.find((n) => n.id === node2.parentNode);
    if (node2.parentNode && !parentNode) {
      triggerError(new VueFlowError(ErrorCode.NODE_MISSING_PARENT, node2.id, node2.parentNode));
    }
    if (node2.parentNode || parentNodes[node2.id]) {
      if (parentNodes[node2.id]) {
        node2.isParent = true;
      }
      if (parentNode) {
        parentNode.isParent = true;
      }
    }
  }
  return nextNodes;
}
function updateConnectionLookup(connectionLookup, edges) {
  connectionLookup.clear();
  for (const edge2 of edges) {
    const { id: edgeId, source, target: target2, sourceHandle = null, targetHandle = null } = edge2;
    const sourceKey = `${source}-source-${sourceHandle}`;
    const targetKey = `${target2}-target-${targetHandle}`;
    const prevSource = connectionLookup.get(sourceKey) || /* @__PURE__ */ new Map();
    const prevTarget = connectionLookup.get(targetKey) || /* @__PURE__ */ new Map();
    const connection = markRaw({ edgeId, source, target: target2, sourceHandle, targetHandle });
    connectionLookup.set(sourceKey, prevSource.set(`${target2}-${targetHandle}`, connection));
    connectionLookup.set(targetKey, prevTarget.set(`${source}-${sourceHandle}`, connection));
  }
}
function createGraphEdges(nextEdges, isValidConnection, findNode, findEdge, onError, defaultEdgeOptions, nodes, edges) {
  const validEdges = [];
  for (const edgeOrConnection of nextEdges) {
    const edge2 = isEdge(edgeOrConnection) ? edgeOrConnection : addEdgeToStore(edgeOrConnection, edges, onError, defaultEdgeOptions);
    if (!edge2) {
      continue;
    }
    const sourceNode = findNode(edge2.source);
    const targetNode = findNode(edge2.target);
    if (!sourceNode || !targetNode) {
      onError(new VueFlowError(ErrorCode.EDGE_SOURCE_TARGET_MISSING, edge2.id, edge2.source, edge2.target));
      continue;
    }
    if (!sourceNode) {
      onError(new VueFlowError(ErrorCode.EDGE_SOURCE_MISSING, edge2.id, edge2.source));
      continue;
    }
    if (!targetNode) {
      onError(new VueFlowError(ErrorCode.EDGE_TARGET_MISSING, edge2.id, edge2.target));
      continue;
    }
    if (isValidConnection) {
      const isValid = isValidConnection(edge2, {
        edges,
        nodes,
        sourceNode,
        targetNode
      });
      if (!isValid) {
        onError(new VueFlowError(ErrorCode.EDGE_INVALID, edge2.id));
        continue;
      }
    }
    const existingEdge = findEdge(edge2.id);
    validEdges.push({
      ...parseEdge(edge2, existingEdge, defaultEdgeOptions),
      sourceNode,
      targetNode
    });
  }
  return validEdges;
}
const VueFlow = Symbol("vueFlow");
const NodeId = Symbol("nodeId");
const NodeRef = Symbol("nodeRef");
const EdgeId = Symbol("edgeId");
const EdgeRef = Symbol("edgeRef");
const Slots$1 = Symbol("slots");
function useDrag(params) {
  const {
    vueFlowRef,
    snapToGrid,
    snapGrid,
    noDragClassName,
    nodes,
    nodeExtent,
    nodeDragThreshold,
    viewport,
    autoPanOnNodeDrag,
    autoPanSpeed,
    nodesDraggable,
    panBy,
    findNode,
    multiSelectionActive,
    nodesSelectionActive,
    selectNodesOnDrag,
    removeSelectedElements,
    addSelectedNodes,
    updateNodePositions,
    emits
  } = useVueFlow();
  const { onStart, onDrag, onStop, onClick, el, disabled: disabled2, id: id2, selectable, dragHandle } = params;
  const dragging2 = ref(false);
  let dragItems = [];
  let dragHandler;
  let containerBounds = null;
  let lastPos = { x: void 0, y: void 0 };
  let mousePosition = { x: 0, y: 0 };
  let dragEvent = null;
  let dragStarted = false;
  let autoPanId = 0;
  let autoPanStarted = false;
  const getPointerPosition = useGetPointerPosition();
  const updateNodes = ({ x, y }) => {
    lastPos = { x, y };
    let hasChange = false;
    dragItems = dragItems.map((n) => {
      const nextPosition = { x: x - n.distance.x, y: y - n.distance.y };
      if (snapToGrid.value) {
        nextPosition.x = snapGrid.value[0] * Math.round(nextPosition.x / snapGrid.value[0]);
        nextPosition.y = snapGrid.value[1] * Math.round(nextPosition.y / snapGrid.value[1]);
      }
      const { computedPosition } = calcNextPosition(
        n,
        nextPosition,
        emits.error,
        nodeExtent.value,
        n.parentNode ? findNode(n.parentNode) : void 0
      );
      hasChange = hasChange || n.position.x !== computedPosition.x || n.position.y !== computedPosition.y;
      n.position = computedPosition;
      return n;
    });
    if (!hasChange) {
      return;
    }
    updateNodePositions(dragItems, true, true);
    dragging2.value = true;
    if (dragEvent) {
      const [currentNode, nodes2] = getEventHandlerParams({
        id: id2,
        dragItems,
        findNode
      });
      onDrag({ event: dragEvent, node: currentNode, nodes: nodes2 });
    }
  };
  const autoPan = () => {
    if (!containerBounds) {
      return;
    }
    const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed.value);
    if (xMovement !== 0 || yMovement !== 0) {
      const nextPos = {
        x: (lastPos.x ?? 0) - xMovement / viewport.value.zoom,
        y: (lastPos.y ?? 0) - yMovement / viewport.value.zoom
      };
      if (panBy({ x: xMovement, y: yMovement })) {
        updateNodes(nextPos);
      }
    }
    autoPanId = requestAnimationFrame(autoPan);
  };
  const startDrag = (event, nodeEl) => {
    dragStarted = true;
    const node2 = findNode(id2);
    if (!selectNodesOnDrag.value && !multiSelectionActive.value && node2) {
      if (!node2.selected) {
        removeSelectedElements();
      }
    }
    if (node2 && toValue$1(selectable) && selectNodesOnDrag.value) {
      handleNodeClick(
        node2,
        multiSelectionActive.value,
        addSelectedNodes,
        removeSelectedElements,
        nodesSelectionActive,
        false,
        nodeEl
      );
    }
    const pointerPos = getPointerPosition(event);
    lastPos = pointerPos;
    dragItems = getDragItems(nodes.value, nodesDraggable.value, pointerPos, findNode, id2);
    if (dragItems.length) {
      const [currentNode, nodes2] = getEventHandlerParams({
        id: id2,
        dragItems,
        findNode
      });
      onStart({ event: event.sourceEvent, node: currentNode, nodes: nodes2 });
    }
  };
  const eventStart = (event, nodeEl) => {
    var _a;
    if (event.sourceEvent.type === "touchmove" && event.sourceEvent.touches.length > 1) {
      return;
    }
    if (nodeDragThreshold.value === 0) {
      startDrag(event, nodeEl);
    }
    lastPos = getPointerPosition(event);
    containerBounds = ((_a = vueFlowRef.value) == null ? void 0 : _a.getBoundingClientRect()) || null;
    mousePosition = getEventPosition(event.sourceEvent, containerBounds);
  };
  const eventDrag = (event, nodeEl) => {
    const pointerPos = getPointerPosition(event);
    if (!autoPanStarted && dragStarted && autoPanOnNodeDrag.value) {
      autoPanStarted = true;
      autoPan();
    }
    if (!dragStarted) {
      const x = pointerPos.xSnapped - (lastPos.x ?? 0);
      const y = pointerPos.ySnapped - (lastPos.y ?? 0);
      const distance2 = Math.sqrt(x * x + y * y);
      if (distance2 > nodeDragThreshold.value) {
        startDrag(event, nodeEl);
      }
    }
    if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems.length && dragStarted) {
      dragEvent = event.sourceEvent;
      mousePosition = getEventPosition(event.sourceEvent, containerBounds);
      updateNodes(pointerPos);
    }
  };
  const eventEnd = (event) => {
    if (!dragStarted && !dragging2.value && !multiSelectionActive.value) {
      const pointerPos = getPointerPosition(event);
      const x = pointerPos.xSnapped - (lastPos.x ?? 0);
      const y = pointerPos.ySnapped - (lastPos.y ?? 0);
      const distance2 = Math.sqrt(x * x + y * y);
      if (distance2 !== 0 && distance2 <= nodeDragThreshold.value) {
        onClick == null ? void 0 : onClick(event.sourceEvent);
      }
      return;
    }
    dragging2.value = false;
    autoPanStarted = false;
    dragStarted = false;
    lastPos = { x: void 0, y: void 0 };
    cancelAnimationFrame(autoPanId);
    if (dragItems.length) {
      updateNodePositions(dragItems, false, false);
      const [currentNode, nodes2] = getEventHandlerParams({
        id: id2,
        dragItems,
        findNode
      });
      onStop({ event: event.sourceEvent, node: currentNode, nodes: nodes2 });
    }
  };
  watch([() => toValue$1(disabled2), el], ([isDisabled, nodeEl], _, onCleanup) => {
    if (nodeEl) {
      const selection2 = select$2(nodeEl);
      if (!isDisabled) {
        dragHandler = drag$1().on("start", (event) => eventStart(event, nodeEl)).on("drag", (event) => eventDrag(event, nodeEl)).on("end", (event) => eventEnd(event)).filter((event) => {
          const target2 = event.target;
          const unrefDragHandle = toValue$1(dragHandle);
          return !event.button && (!noDragClassName.value || !hasSelector(target2, `.${noDragClassName.value}`, nodeEl) && (!unrefDragHandle || hasSelector(target2, unrefDragHandle, nodeEl)));
        });
        selection2.call(dragHandler);
      }
      onCleanup(() => {
        selection2.on(".drag", null);
        if (dragHandler) {
          dragHandler.on("start", null);
          dragHandler.on("drag", null);
          dragHandler.on("end", null);
        }
      });
    }
  });
  return dragging2;
}
function createEdgeHooks() {
  return {
    doubleClick: createExtendedEventHook(),
    click: createExtendedEventHook(),
    mouseEnter: createExtendedEventHook(),
    mouseMove: createExtendedEventHook(),
    mouseLeave: createExtendedEventHook(),
    contextMenu: createExtendedEventHook(),
    updateStart: createExtendedEventHook(),
    update: createExtendedEventHook(),
    updateEnd: createExtendedEventHook()
  };
}
function useEdgeHooks(edge2, emits) {
  const edgeHooks = createEdgeHooks();
  edgeHooks.doubleClick.on((event) => {
    var _a, _b;
    emits.edgeDoubleClick(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.doubleClick) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.click.on((event) => {
    var _a, _b;
    emits.edgeClick(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.click) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.mouseEnter.on((event) => {
    var _a, _b;
    emits.edgeMouseEnter(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.mouseEnter) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.mouseMove.on((event) => {
    var _a, _b;
    emits.edgeMouseMove(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.mouseMove) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.mouseLeave.on((event) => {
    var _a, _b;
    emits.edgeMouseLeave(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.mouseLeave) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.contextMenu.on((event) => {
    var _a, _b;
    emits.edgeContextMenu(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.contextMenu) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.updateStart.on((event) => {
    var _a, _b;
    emits.edgeUpdateStart(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.updateStart) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.update.on((event) => {
    var _a, _b;
    emits.edgeUpdate(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a, event);
  });
  edgeHooks.updateEnd.on((event) => {
    var _a, _b;
    emits.edgeUpdateEnd(event);
    (_b = (_a = edge2.events) == null ? void 0 : _a.updateEnd) == null ? void 0 : _b.call(_a, event);
  });
  return Object.entries(edgeHooks).reduce(
    (hooks, [key, value]) => {
      hooks.emit[key] = value.trigger;
      hooks.on[key] = value.on;
      return hooks;
    },
    { emit: {}, on: {} }
  );
}
function useGetPointerPosition() {
  const { viewport, snapGrid, snapToGrid } = useVueFlow();
  return ({ sourceEvent: sourceEvent2 }) => {
    const x = sourceEvent2.touches ? sourceEvent2.touches[0].clientX : sourceEvent2.clientX;
    const y = sourceEvent2.touches ? sourceEvent2.touches[0].clientY : sourceEvent2.clientY;
    const pointerPos = {
      x: (x - viewport.value.x) / viewport.value.zoom,
      y: (y - viewport.value.y) / viewport.value.zoom
    };
    return {
      xSnapped: snapToGrid.value ? snapGrid.value[0] * Math.round(pointerPos.x / snapGrid.value[0]) : pointerPos.x,
      ySnapped: snapToGrid.value ? snapGrid.value[1] * Math.round(pointerPos.y / snapGrid.value[1]) : pointerPos.y,
      ...pointerPos
    };
  };
}
function alwaysValid() {
  return true;
}
function useHandle({
  handleId,
  nodeId,
  type,
  isValidConnection,
  edgeUpdaterType,
  onEdgeUpdate,
  onEdgeUpdateEnd
}) {
  const {
    vueFlowRef,
    connectionMode,
    connectionRadius,
    connectOnClick,
    connectionClickStartHandle,
    nodesConnectable,
    autoPanOnConnect,
    autoPanSpeed,
    findNode,
    panBy,
    startConnection,
    updateConnection,
    endConnection,
    emits,
    viewport,
    edges,
    nodes,
    isValidConnection: isValidConnectionProp
  } = useVueFlow();
  let connection = null;
  let isValid = false;
  let handleDomNode = null;
  let previousConnection = null;
  function handlePointerDown(event) {
    var _a;
    const isTarget = toValue$1(type) === "target";
    const isMouseTriggered = isMouseEvent(event);
    const doc = getHostForElement(event.target);
    if (isMouseTriggered && event.button === 0 || !isMouseTriggered) {
      let onPointerMove = function(event2) {
        connectionPosition = getEventPosition(event2, containerBounds);
        const { handle: handle2, validHandleResult } = getClosestHandle(
          event2,
          doc,
          pointToRendererPoint(connectionPosition, viewport.value, false, [1, 1]),
          connectionRadius.value,
          handleLookup,
          (handle22) => isValidHandle(
            event2,
            handle22,
            connectionMode.value,
            toValue$1(nodeId),
            toValue$1(handleId),
            isTarget ? "target" : "source",
            isValidConnectionHandler,
            doc,
            edges.value,
            nodes.value,
            findNode
          )
        );
        closestHandle = handle2;
        if (!autoPanStarted) {
          autoPan();
          autoPanStarted = true;
        }
        connection = validHandleResult.connection;
        isValid = validHandleResult.isValid;
        handleDomNode = validHandleResult.handleDomNode;
        if (isValid && closestHandle && (previousConnection == null ? void 0 : previousConnection.endHandle) && validHandleResult.endHandle && previousConnection.endHandle.type === validHandleResult.endHandle.type && previousConnection.endHandle.nodeId === validHandleResult.endHandle.nodeId && previousConnection.endHandle.handleId === validHandleResult.endHandle.handleId) {
          return;
        }
        updateConnection(
          closestHandle && isValid ? rendererPointToPoint(
            {
              x: closestHandle.x,
              y: closestHandle.y
            },
            viewport.value
          ) : connectionPosition,
          validHandleResult.endHandle,
          getConnectionStatus(!!closestHandle, isValid)
        );
        previousConnection = validHandleResult;
        if (!closestHandle && !isValid && !handleDomNode) {
          return resetRecentHandle(prevActiveHandle);
        }
        if (connection && connection.source !== connection.target && handleDomNode) {
          resetRecentHandle(prevActiveHandle);
          prevActiveHandle = handleDomNode;
          handleDomNode.classList.add("connecting", "vue-flow__handle-connecting");
          handleDomNode.classList.toggle("valid", isValid);
          handleDomNode.classList.toggle("vue-flow__handle-valid", isValid);
        }
      }, onPointerUp = function(event2) {
        if ((closestHandle || handleDomNode) && connection && isValid) {
          if (!onEdgeUpdate) {
            emits.connect(connection);
          } else {
            onEdgeUpdate(event2, connection);
          }
        }
        emits.connectEnd(event2);
        if (edgeUpdaterType) {
          onEdgeUpdateEnd == null ? void 0 : onEdgeUpdateEnd(event2);
        }
        resetRecentHandle(prevActiveHandle);
        cancelAnimationFrame(autoPanId);
        endConnection(event2);
        autoPanStarted = false;
        isValid = false;
        connection = null;
        handleDomNode = null;
        doc.removeEventListener("mousemove", onPointerMove);
        doc.removeEventListener("mouseup", onPointerUp);
        doc.removeEventListener("touchmove", onPointerMove);
        doc.removeEventListener("touchend", onPointerUp);
      };
      const node2 = findNode(toValue$1(nodeId));
      let isValidConnectionHandler = toValue$1(isValidConnection) || isValidConnectionProp.value || alwaysValid;
      if (!isValidConnectionHandler && node2) {
        isValidConnectionHandler = (!isTarget ? node2.isValidTargetPos : node2.isValidSourcePos) || alwaysValid;
      }
      let closestHandle;
      let autoPanId = 0;
      const { x, y } = getEventPosition(event);
      const clickedHandle = doc == null ? void 0 : doc.elementFromPoint(x, y);
      const handleType = getHandleType(toValue$1(edgeUpdaterType), clickedHandle);
      const containerBounds = (_a = vueFlowRef.value) == null ? void 0 : _a.getBoundingClientRect();
      if (!containerBounds || !handleType) {
        return;
      }
      let prevActiveHandle;
      let connectionPosition = getEventPosition(event, containerBounds);
      let autoPanStarted = false;
      const handleLookup = getHandleLookup({
        nodes: nodes.value,
        nodeId: toValue$1(nodeId),
        handleId: toValue$1(handleId),
        handleType
      });
      const autoPan = () => {
        if (!autoPanOnConnect.value) {
          return;
        }
        const [xMovement, yMovement] = calcAutoPan(connectionPosition, containerBounds, autoPanSpeed.value);
        panBy({ x: xMovement, y: yMovement });
        autoPanId = requestAnimationFrame(autoPan);
      };
      startConnection(
        {
          nodeId: toValue$1(nodeId),
          handleId: toValue$1(handleId),
          type: handleType,
          position: (clickedHandle == null ? void 0 : clickedHandle.getAttribute("data-handlepos")) || Position.Top
        },
        {
          x: x - containerBounds.left,
          y: y - containerBounds.top
        }
      );
      emits.connectStart({ event, nodeId: toValue$1(nodeId), handleId: toValue$1(handleId), handleType });
      doc.addEventListener("mousemove", onPointerMove);
      doc.addEventListener("mouseup", onPointerUp);
      doc.addEventListener("touchmove", onPointerMove);
      doc.addEventListener("touchend", onPointerUp);
    }
  }
  function handleClick(event) {
    if (!connectOnClick.value) {
      return;
    }
    const isTarget = toValue$1(type) === "target";
    if (!connectionClickStartHandle.value) {
      emits.clickConnectStart({ event, nodeId: toValue$1(nodeId), handleId: toValue$1(handleId) });
      startConnection({ nodeId: toValue$1(nodeId), type: toValue$1(type), handleId: toValue$1(handleId) }, void 0, true);
    } else {
      let isValidConnectionHandler = toValue$1(isValidConnection) || isValidConnectionProp.value || alwaysValid;
      const node2 = findNode(toValue$1(nodeId));
      if (!isValidConnectionHandler && node2) {
        isValidConnectionHandler = (!isTarget ? node2.isValidTargetPos : node2.isValidSourcePos) || alwaysValid;
      }
      if (node2 && (typeof node2.connectable === "undefined" ? nodesConnectable.value : node2.connectable) === false) {
        return;
      }
      const doc = getHostForElement(event.target);
      const { connection: connection2, isValid: isValid2 } = isValidHandle(
        event,
        {
          nodeId: toValue$1(nodeId),
          id: toValue$1(handleId),
          type: toValue$1(type)
        },
        connectionMode.value,
        connectionClickStartHandle.value.nodeId,
        connectionClickStartHandle.value.handleId || null,
        connectionClickStartHandle.value.type,
        isValidConnectionHandler,
        doc,
        edges.value,
        nodes.value,
        findNode
      );
      const isOwnHandle = connection2.source === connection2.target;
      if (isValid2 && !isOwnHandle) {
        emits.connect(connection2);
      }
      emits.clickConnectEnd(event);
      endConnection(event, true);
    }
  }
  return {
    handlePointerDown,
    handleClick
  };
}
function useNodeId() {
  return inject(NodeId, "");
}
function useNode(id2) {
  const nodeId = id2 ?? useNodeId() ?? "";
  const nodeEl = inject(NodeRef, ref(null));
  const { findNode, edges, emits } = useVueFlow();
  const node2 = findNode(nodeId);
  if (!node2) {
    emits.error(new VueFlowError(ErrorCode.NODE_NOT_FOUND, nodeId));
  }
  return {
    id: nodeId,
    nodeEl,
    node: node2,
    parentNode: computed(() => findNode(node2.parentNode)),
    connectedEdges: computed(() => getConnectedEdges([node2], edges.value))
  };
}
function createNodeHooks() {
  return {
    doubleClick: createExtendedEventHook(),
    click: createExtendedEventHook(),
    mouseEnter: createExtendedEventHook(),
    mouseMove: createExtendedEventHook(),
    mouseLeave: createExtendedEventHook(),
    contextMenu: createExtendedEventHook(),
    dragStart: createExtendedEventHook(),
    drag: createExtendedEventHook(),
    dragStop: createExtendedEventHook()
  };
}
function useNodeHooks(node2, emits) {
  const nodeHooks = createNodeHooks();
  nodeHooks.doubleClick.on((event) => {
    var _a, _b;
    emits.nodeDoubleClick(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.doubleClick) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.click.on((event) => {
    var _a, _b;
    emits.nodeClick(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.click) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.mouseEnter.on((event) => {
    var _a, _b;
    emits.nodeMouseEnter(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.mouseEnter) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.mouseMove.on((event) => {
    var _a, _b;
    emits.nodeMouseMove(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.mouseMove) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.mouseLeave.on((event) => {
    var _a, _b;
    emits.nodeMouseLeave(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.mouseLeave) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.contextMenu.on((event) => {
    var _a, _b;
    emits.nodeContextMenu(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.contextMenu) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.dragStart.on((event) => {
    var _a, _b;
    emits.nodeDragStart(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.dragStart) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.drag.on((event) => {
    var _a, _b;
    emits.nodeDrag(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.drag) == null ? void 0 : _b.call(_a, event);
  });
  nodeHooks.dragStop.on((event) => {
    var _a, _b;
    emits.nodeDragStop(event);
    (_b = (_a = node2.events) == null ? void 0 : _a.dragStop) == null ? void 0 : _b.call(_a, event);
  });
  return Object.entries(nodeHooks).reduce(
    (hooks, [key, value]) => {
      hooks.emit[key] = value.trigger;
      hooks.on[key] = value.on;
      return hooks;
    },
    { emit: {}, on: {} }
  );
}
function useUpdateNodePositions() {
  const { getSelectedNodes, nodeExtent, updateNodePositions, findNode, snapGrid, snapToGrid, nodesDraggable, emits } = useVueFlow();
  return (positionDiff, isShiftPressed = false) => {
    const xVelo = snapToGrid.value ? snapGrid.value[0] : 5;
    const yVelo = snapToGrid.value ? snapGrid.value[1] : 5;
    const factor = isShiftPressed ? 4 : 1;
    const positionDiffX = positionDiff.x * xVelo * factor;
    const positionDiffY = positionDiff.y * yVelo * factor;
    const nodeUpdates = [];
    for (const node2 of getSelectedNodes.value) {
      if (node2.draggable || nodesDraggable && typeof node2.draggable === "undefined") {
        const nextPosition = { x: node2.computedPosition.x + positionDiffX, y: node2.computedPosition.y + positionDiffY };
        const { computedPosition } = calcNextPosition(
          node2,
          nextPosition,
          emits.error,
          nodeExtent.value,
          node2.parentNode ? findNode(node2.parentNode) : void 0
        );
        nodeUpdates.push({
          id: node2.id,
          position: computedPosition,
          from: node2.position,
          distance: { x: positionDiff.x, y: positionDiff.y },
          dimensions: node2.dimensions
        });
      }
    }
    updateNodePositions(nodeUpdates, true, false);
  };
}
const DEFAULT_PADDING = 0.1;
function noop$3() {
  warn("Viewport not initialized yet.");
  return Promise.resolve(false);
}
const initialViewportHelper = {
  zoomIn: noop$3,
  zoomOut: noop$3,
  zoomTo: noop$3,
  fitView: noop$3,
  setCenter: noop$3,
  fitBounds: noop$3,
  project: (position2) => position2,
  screenToFlowCoordinate: (position2) => position2,
  flowToScreenCoordinate: (position2) => position2,
  setViewport: noop$3,
  setTransform: noop$3,
  getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
  getTransform: () => ({ x: 0, y: 0, zoom: 1 }),
  viewportInitialized: false
};
function useViewportHelper(state2) {
  function zoom2(scale, duration) {
    return new Promise((resolve) => {
      if (state2.d3Selection && state2.d3Zoom) {
        state2.d3Zoom.scaleBy(
          transition(state2.d3Selection, duration, () => {
            resolve(true);
          }),
          scale
        );
      } else {
        resolve(false);
      }
    });
  }
  function transformViewport(x, y, zoom22, duration) {
    return new Promise((resolve) => {
      const { x: clampedX, y: clampedY } = clampPosition({ x: -x, y: -y }, state2.translateExtent);
      const nextTransform = identity$2.translate(-clampedX, -clampedY).scale(zoom22);
      if (state2.d3Selection && state2.d3Zoom) {
        state2.d3Zoom.transform(
          transition(state2.d3Selection, duration, () => {
            resolve(true);
          }),
          nextTransform
        );
      } else {
        resolve(false);
      }
    });
  }
  return computed(() => {
    const isInitialized = state2.d3Zoom && state2.d3Selection && state2.dimensions.width && state2.dimensions.height;
    if (!isInitialized) {
      return initialViewportHelper;
    }
    return {
      viewportInitialized: true,
      // todo: allow passing scale as option
      zoomIn: (options) => {
        return zoom2(1.2, options == null ? void 0 : options.duration);
      },
      zoomOut: (options) => {
        return zoom2(1 / 1.2, options == null ? void 0 : options.duration);
      },
      zoomTo: (zoomLevel, options) => {
        return new Promise((resolve) => {
          if (state2.d3Selection && state2.d3Zoom) {
            state2.d3Zoom.scaleTo(
              transition(state2.d3Selection, options == null ? void 0 : options.duration, () => {
                resolve(true);
              }),
              zoomLevel
            );
          } else {
            resolve(false);
          }
        });
      },
      setViewport: (transform, options) => {
        return transformViewport(transform.x, transform.y, transform.zoom, options == null ? void 0 : options.duration);
      },
      setTransform: (transform, options) => {
        return transformViewport(transform.x, transform.y, transform.zoom, options == null ? void 0 : options.duration);
      },
      getViewport: () => ({
        x: state2.viewport.x,
        y: state2.viewport.y,
        zoom: state2.viewport.zoom
      }),
      getTransform: () => {
        return {
          x: state2.viewport.x,
          y: state2.viewport.y,
          zoom: state2.viewport.zoom
        };
      },
      fitView: (options = {
        padding: DEFAULT_PADDING,
        includeHiddenNodes: false,
        duration: 0
      }) => {
        var _a, _b;
        const nodesToFit = [];
        for (const node2 of state2.nodes) {
          const isVisible = node2.dimensions.width && node2.dimensions.height && ((options == null ? void 0 : options.includeHiddenNodes) || !node2.hidden);
          if (isVisible) {
            if (!((_a = options.nodes) == null ? void 0 : _a.length) || ((_b = options.nodes) == null ? void 0 : _b.length) && options.nodes.includes(node2.id)) {
              nodesToFit.push(node2);
            }
          }
        }
        if (!nodesToFit.length) {
          return Promise.resolve(false);
        }
        const bounds = getRectOfNodes(nodesToFit);
        const { x, y, zoom: zoom22 } = getTransformForBounds(
          bounds,
          state2.dimensions.width,
          state2.dimensions.height,
          options.minZoom ?? state2.minZoom,
          options.maxZoom ?? state2.maxZoom,
          options.padding ?? DEFAULT_PADDING,
          options.offset
        );
        return transformViewport(x, y, zoom22, options == null ? void 0 : options.duration);
      },
      setCenter: (x, y, options) => {
        const nextZoom = typeof (options == null ? void 0 : options.zoom) !== "undefined" ? options.zoom : state2.maxZoom;
        const centerX = state2.dimensions.width / 2 - x * nextZoom;
        const centerY = state2.dimensions.height / 2 - y * nextZoom;
        return transformViewport(centerX, centerY, nextZoom, options == null ? void 0 : options.duration);
      },
      fitBounds: (bounds, options = { padding: DEFAULT_PADDING }) => {
        const { x, y, zoom: zoom22 } = getTransformForBounds(
          bounds,
          state2.dimensions.width,
          state2.dimensions.height,
          state2.minZoom,
          state2.maxZoom,
          options.padding
        );
        return transformViewport(x, y, zoom22, options == null ? void 0 : options.duration);
      },
      project: (position2) => pointToRendererPoint(position2, state2.viewport, state2.snapToGrid, state2.snapGrid),
      screenToFlowCoordinate: (position2) => {
        if (state2.vueFlowRef) {
          const { x: domX, y: domY } = state2.vueFlowRef.getBoundingClientRect();
          const correctedPosition = {
            x: position2.x - domX,
            y: position2.y - domY
          };
          return pointToRendererPoint(correctedPosition, state2.viewport, state2.snapToGrid, state2.snapGrid);
        }
        return { x: 0, y: 0 };
      },
      flowToScreenCoordinate: (position2) => {
        if (state2.vueFlowRef) {
          const { x: domX, y: domY } = state2.vueFlowRef.getBoundingClientRect();
          const correctedPosition = {
            x: position2.x + domX,
            y: position2.y + domY
          };
          return rendererPointToPoint(correctedPosition, state2.viewport);
        }
        return { x: 0, y: 0 };
      }
    };
  });
}
function transition(selection2, ms = 0, onEnd) {
  return selection2.transition().duration(ms).on("end", onEnd);
}
function useWatchProps(models, props, store) {
  const scope = effectScope(true);
  scope.run(() => {
    const watchModelValue = () => {
      scope.run(() => {
        let pauseModel;
        let pauseStore;
        let immediateStore = !!(store.nodes.value.length || store.edges.value.length);
        pauseModel = watchPausable([models.modelValue, () => {
          var _a, _b;
          return (_b = (_a = models.modelValue) == null ? void 0 : _a.value) == null ? void 0 : _b.length;
        }], ([elements]) => {
          if (elements && Array.isArray(elements)) {
            pauseStore == null ? void 0 : pauseStore.pause();
            store.setElements(elements);
            if (!pauseStore && !immediateStore && elements.length) {
              immediateStore = true;
            } else {
              pauseStore == null ? void 0 : pauseStore.resume();
            }
          }
        });
        pauseStore = watchPausable(
          [store.nodes, store.edges, () => store.edges.value.length, () => store.nodes.value.length],
          ([nodes, edges]) => {
            var _a;
            if (((_a = models.modelValue) == null ? void 0 : _a.value) && Array.isArray(models.modelValue.value)) {
              pauseModel == null ? void 0 : pauseModel.pause();
              models.modelValue.value = [...nodes, ...edges];
              nextTick(() => {
                pauseModel == null ? void 0 : pauseModel.resume();
              });
            }
          },
          { immediate: immediateStore }
        );
        onScopeDispose(() => {
          pauseModel == null ? void 0 : pauseModel.stop();
          pauseStore == null ? void 0 : pauseStore.stop();
        });
      });
    };
    const watchNodesValue = () => {
      scope.run(() => {
        let pauseModel;
        let pauseStore;
        let immediateStore = !!store.nodes.value.length;
        pauseModel = watchPausable([models.nodes, () => {
          var _a, _b;
          return (_b = (_a = models.nodes) == null ? void 0 : _a.value) == null ? void 0 : _b.length;
        }], ([nodes]) => {
          if (nodes && Array.isArray(nodes)) {
            pauseStore == null ? void 0 : pauseStore.pause();
            store.setNodes(nodes);
            if (!pauseStore && !immediateStore && nodes.length) {
              immediateStore = true;
            } else {
              pauseStore == null ? void 0 : pauseStore.resume();
            }
          }
        });
        pauseStore = watchPausable(
          [store.nodes, () => store.nodes.value.length],
          ([nodes]) => {
            var _a;
            if (((_a = models.nodes) == null ? void 0 : _a.value) && Array.isArray(models.nodes.value)) {
              pauseModel == null ? void 0 : pauseModel.pause();
              models.nodes.value = [...nodes];
              nextTick(() => {
                pauseModel == null ? void 0 : pauseModel.resume();
              });
            }
          },
          { immediate: immediateStore }
        );
        onScopeDispose(() => {
          pauseModel == null ? void 0 : pauseModel.stop();
          pauseStore == null ? void 0 : pauseStore.stop();
        });
      });
    };
    const watchEdgesValue = () => {
      scope.run(() => {
        let pauseModel;
        let pauseStore;
        let immediateStore = !!store.edges.value.length;
        pauseModel = watchPausable([models.edges, () => {
          var _a, _b;
          return (_b = (_a = models.edges) == null ? void 0 : _a.value) == null ? void 0 : _b.length;
        }], ([edges]) => {
          if (edges && Array.isArray(edges)) {
            pauseStore == null ? void 0 : pauseStore.pause();
            store.setEdges(edges);
            if (!pauseStore && !immediateStore && edges.length) {
              immediateStore = true;
            } else {
              pauseStore == null ? void 0 : pauseStore.resume();
            }
          }
        });
        pauseStore = watchPausable(
          [store.edges, () => store.edges.value.length],
          ([edges]) => {
            var _a;
            if (((_a = models.edges) == null ? void 0 : _a.value) && Array.isArray(models.edges.value)) {
              pauseModel == null ? void 0 : pauseModel.pause();
              models.edges.value = [...edges];
              nextTick(() => {
                pauseModel == null ? void 0 : pauseModel.resume();
              });
            }
          },
          { immediate: immediateStore }
        );
        onScopeDispose(() => {
          pauseModel == null ? void 0 : pauseModel.stop();
          pauseStore == null ? void 0 : pauseStore.stop();
        });
      });
    };
    const watchMaxZoom = () => {
      scope.run(() => {
        watch(
          () => props.maxZoom,
          () => {
            if (props.maxZoom && isDef(props.maxZoom)) {
              store.setMaxZoom(props.maxZoom);
            }
          },
          {
            immediate: true
          }
        );
      });
    };
    const watchMinZoom = () => {
      scope.run(() => {
        watch(
          () => props.minZoom,
          () => {
            if (props.minZoom && isDef(props.minZoom)) {
              store.setMinZoom(props.minZoom);
            }
          },
          { immediate: true }
        );
      });
    };
    const watchTranslateExtent = () => {
      scope.run(() => {
        watch(
          () => props.translateExtent,
          () => {
            if (props.translateExtent && isDef(props.translateExtent)) {
              store.setTranslateExtent(props.translateExtent);
            }
          },
          {
            immediate: true
          }
        );
      });
    };
    const watchNodeExtent = () => {
      scope.run(() => {
        watch(
          () => props.nodeExtent,
          () => {
            if (props.nodeExtent && isDef(props.nodeExtent)) {
              store.setNodeExtent(props.nodeExtent);
            }
          },
          {
            immediate: true
          }
        );
      });
    };
    const watchApplyDefault = () => {
      scope.run(() => {
        watch(
          () => props.applyDefault,
          () => {
            if (isDef(props.applyDefault)) {
              store.applyDefault.value = props.applyDefault;
            }
          },
          {
            immediate: true
          }
        );
      });
    };
    const watchAutoConnect = () => {
      scope.run(() => {
        const autoConnector = async (params) => {
          let connection = params;
          if (typeof props.autoConnect === "function") {
            connection = await props.autoConnect(params);
          }
          if (connection !== false) {
            store.addEdges([connection]);
          }
        };
        watch(
          () => props.autoConnect,
          () => {
            if (isDef(props.autoConnect)) {
              store.autoConnect.value = props.autoConnect;
            }
          },
          { immediate: true }
        );
        watch(
          store.autoConnect,
          (autoConnectEnabled, _, onCleanup) => {
            if (autoConnectEnabled) {
              store.onConnect(autoConnector);
            } else {
              store.hooks.value.connect.off(autoConnector);
            }
            onCleanup(() => {
              store.hooks.value.connect.off(autoConnector);
            });
          },
          { immediate: true }
        );
      });
    };
    const watchRest = () => {
      const skip = [
        "id",
        "modelValue",
        "translateExtent",
        "nodeExtent",
        "edges",
        "nodes",
        "maxZoom",
        "minZoom",
        "applyDefault",
        "autoConnect"
      ];
      for (const key of Object.keys(props)) {
        const propKey = key;
        if (!skip.includes(propKey)) {
          const propValue = toRef(() => props[propKey]);
          const storeRef = store[propKey];
          if (isRef(storeRef)) {
            scope.run(() => {
              watch(
                propValue,
                (nextValue) => {
                  if (isDef(nextValue)) {
                    storeRef.value = nextValue;
                  }
                },
                { immediate: true }
              );
            });
          }
        }
      }
    };
    const runAll = () => {
      watchModelValue();
      watchNodesValue();
      watchEdgesValue();
      watchMinZoom();
      watchMaxZoom();
      watchTranslateExtent();
      watchNodeExtent();
      watchApplyDefault();
      watchAutoConnect();
      watchRest();
    };
    runAll();
  });
  return () => scope.stop();
}
function createHooks() {
  return {
    edgesChange: createExtendedEventHook(),
    nodesChange: createExtendedEventHook(),
    nodeDoubleClick: createExtendedEventHook(),
    nodeClick: createExtendedEventHook(),
    nodeMouseEnter: createExtendedEventHook(),
    nodeMouseMove: createExtendedEventHook(),
    nodeMouseLeave: createExtendedEventHook(),
    nodeContextMenu: createExtendedEventHook(),
    nodeDragStart: createExtendedEventHook(),
    nodeDrag: createExtendedEventHook(),
    nodeDragStop: createExtendedEventHook(),
    nodesInitialized: createExtendedEventHook(),
    miniMapNodeClick: createExtendedEventHook(),
    miniMapNodeDoubleClick: createExtendedEventHook(),
    miniMapNodeMouseEnter: createExtendedEventHook(),
    miniMapNodeMouseMove: createExtendedEventHook(),
    miniMapNodeMouseLeave: createExtendedEventHook(),
    connect: createExtendedEventHook(),
    connectStart: createExtendedEventHook(),
    connectEnd: createExtendedEventHook(),
    clickConnectStart: createExtendedEventHook(),
    clickConnectEnd: createExtendedEventHook(),
    paneReady: createExtendedEventHook(),
    init: createExtendedEventHook(),
    move: createExtendedEventHook(),
    moveStart: createExtendedEventHook(),
    moveEnd: createExtendedEventHook(),
    selectionDragStart: createExtendedEventHook(),
    selectionDrag: createExtendedEventHook(),
    selectionDragStop: createExtendedEventHook(),
    selectionContextMenu: createExtendedEventHook(),
    selectionStart: createExtendedEventHook(),
    selectionEnd: createExtendedEventHook(),
    viewportChangeStart: createExtendedEventHook(),
    viewportChange: createExtendedEventHook(),
    viewportChangeEnd: createExtendedEventHook(),
    paneScroll: createExtendedEventHook(),
    paneClick: createExtendedEventHook(),
    paneContextMenu: createExtendedEventHook(),
    paneMouseEnter: createExtendedEventHook(),
    paneMouseMove: createExtendedEventHook(),
    paneMouseLeave: createExtendedEventHook(),
    edgeContextMenu: createExtendedEventHook(),
    edgeMouseEnter: createExtendedEventHook(),
    edgeMouseMove: createExtendedEventHook(),
    edgeMouseLeave: createExtendedEventHook(),
    edgeDoubleClick: createExtendedEventHook(),
    edgeClick: createExtendedEventHook(),
    edgeUpdateStart: createExtendedEventHook(),
    edgeUpdate: createExtendedEventHook(),
    edgeUpdateEnd: createExtendedEventHook(),
    updateNodeInternals: createExtendedEventHook(),
    error: createExtendedEventHook((err) => warn(err.message))
  };
}
function useHooks(emit, hooks) {
  onBeforeMount(() => {
    for (const [key, value] of Object.entries(hooks.value)) {
      const listener = (data) => {
        emit(key, data);
      };
      value.fns.add(listener);
      tryOnScopeDispose(() => {
        value.off(listener);
      });
    }
  });
}
function useState() {
  return {
    vueFlowRef: null,
    viewportRef: null,
    nodes: [],
    edges: [],
    connectionLookup: /* @__PURE__ */ new Map(),
    nodeTypes: {},
    edgeTypes: {},
    initialized: false,
    dimensions: {
      width: 0,
      height: 0
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    nodeExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    selectionMode: SelectionMode.Full,
    paneDragging: false,
    preventScrolling: true,
    zoomOnScroll: true,
    zoomOnPinch: true,
    zoomOnDoubleClick: true,
    panOnScroll: false,
    panOnScrollSpeed: 0.5,
    panOnScrollMode: PanOnScrollMode.Free,
    paneClickDistance: 0,
    panOnDrag: true,
    edgeUpdaterRadius: 10,
    onlyRenderVisibleElements: false,
    defaultViewport: { x: 0, y: 0, zoom: 1 },
    nodesSelectionActive: false,
    userSelectionActive: false,
    userSelectionRect: null,
    defaultMarkerColor: "#b1b1b7",
    connectionLineStyle: {},
    connectionLineType: null,
    connectionLineOptions: {
      type: ConnectionLineType.Bezier,
      style: {}
    },
    connectionMode: ConnectionMode.Loose,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectionPosition: { x: Number.NaN, y: Number.NaN },
    connectionRadius: 20,
    connectOnClick: true,
    connectionStatus: null,
    isValidConnection: null,
    snapGrid: [15, 15],
    snapToGrid: false,
    edgesUpdatable: false,
    edgesFocusable: true,
    nodesFocusable: true,
    nodesConnectable: true,
    nodesDraggable: true,
    nodeDragThreshold: 1,
    elementsSelectable: true,
    selectNodesOnDrag: true,
    multiSelectionActive: false,
    selectionKeyCode: "Shift",
    multiSelectionKeyCode: isMacOs() ? "Meta" : "Control",
    zoomActivationKeyCode: isMacOs() ? "Meta" : "Control",
    deleteKeyCode: "Backspace",
    panActivationKeyCode: "Space",
    hooks: createHooks(),
    applyDefault: true,
    autoConnect: false,
    fitViewOnInit: false,
    fitViewOnInitDone: false,
    noDragClassName: "nodrag",
    noWheelClassName: "nowheel",
    noPanClassName: "nopan",
    defaultEdgeOptions: void 0,
    elevateEdgesOnSelect: false,
    elevateNodesOnSelect: true,
    autoPanOnNodeDrag: true,
    autoPanOnConnect: true,
    autoPanSpeed: 15,
    disableKeyboardA11y: false,
    ariaLiveMessage: ""
  };
}
const storeOptionsToSkip = [
  "id",
  "vueFlowRef",
  "viewportRef",
  "initialized",
  "modelValue",
  "nodes",
  "edges",
  "maxZoom",
  "minZoom",
  "translateExtent",
  "hooks",
  "defaultEdgeOptions"
];
function useActions(state2, nodeLookup, edgeLookup) {
  const viewportHelper = useViewportHelper(state2);
  const updateNodeInternals = (ids) => {
    const updateIds = ids ?? [];
    state2.hooks.updateNodeInternals.trigger(updateIds);
  };
  const getIncomers$1 = (nodeOrId) => {
    return getIncomers(nodeOrId, state2.nodes, state2.edges);
  };
  const getOutgoers$1 = (nodeOrId) => {
    return getOutgoers(nodeOrId, state2.nodes, state2.edges);
  };
  const getConnectedEdges$1 = (nodesOrId) => {
    return getConnectedEdges(nodesOrId, state2.edges);
  };
  const getHandleConnections = ({ id: id2, type, nodeId }) => {
    var _a;
    return Array.from(((_a = state2.connectionLookup.get(`${nodeId}-${type}-${id2 ?? null}`)) == null ? void 0 : _a.values()) ?? []);
  };
  const findNode = (id2) => {
    if (!id2) {
      return;
    }
    return nodeLookup.value.get(id2);
  };
  const findEdge = (id2) => {
    if (!id2) {
      return;
    }
    return edgeLookup.value.get(id2);
  };
  const updateNodePositions = (dragItems, changed, dragging2) => {
    var _a, _b;
    const changes = [];
    for (const node2 of dragItems) {
      const change = {
        id: node2.id,
        type: "position",
        dragging: dragging2,
        from: node2.from
      };
      if (changed) {
        change.position = node2.position;
        if (node2.parentNode) {
          const parentNode = findNode(node2.parentNode);
          change.position = {
            x: change.position.x - (((_a = parentNode == null ? void 0 : parentNode.computedPosition) == null ? void 0 : _a.x) ?? 0),
            y: change.position.y - (((_b = parentNode == null ? void 0 : parentNode.computedPosition) == null ? void 0 : _b.y) ?? 0)
          };
        }
      }
      changes.push(change);
    }
    if (changes == null ? void 0 : changes.length) {
      state2.hooks.nodesChange.trigger(changes);
    }
  };
  const updateNodeDimensions = (updates) => {
    if (!state2.vueFlowRef) {
      return;
    }
    const viewportNode = state2.vueFlowRef.querySelector(".vue-flow__transformationpane");
    if (!viewportNode) {
      return;
    }
    const style = window.getComputedStyle(viewportNode);
    const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
    const changes = [];
    for (let i = 0; i < updates.length; ++i) {
      const update = updates[i];
      const node2 = findNode(update.id);
      if (node2) {
        const dimensions = getDimensions(update.nodeElement);
        const doUpdate = !!(dimensions.width && dimensions.height && (node2.dimensions.width !== dimensions.width || node2.dimensions.height !== dimensions.height || update.forceUpdate));
        if (doUpdate) {
          const nodeBounds = update.nodeElement.getBoundingClientRect();
          node2.dimensions = dimensions;
          node2.handleBounds.source = getHandleBounds(".source", update.nodeElement, nodeBounds, zoom2);
          node2.handleBounds.target = getHandleBounds(".target", update.nodeElement, nodeBounds, zoom2);
          changes.push({
            id: node2.id,
            type: "dimensions",
            dimensions
          });
        }
      }
    }
    if (!state2.fitViewOnInitDone && state2.fitViewOnInit) {
      viewportHelper.value.fitView().then(() => {
        state2.fitViewOnInitDone = true;
      });
    }
    if (changes.length) {
      state2.hooks.nodesChange.trigger(changes);
    }
  };
  const elementSelectionHandler = (elements, selected2) => {
    const nodeIds = /* @__PURE__ */ new Set();
    const edgeIds = /* @__PURE__ */ new Set();
    for (const element of elements) {
      if (isNode(element)) {
        nodeIds.add(element.id);
      } else if (isEdge(element)) {
        edgeIds.add(element.id);
      }
    }
    const changedNodes = getSelectionChanges(nodeLookup.value, nodeIds, true);
    const changedEdges = getSelectionChanges(edgeLookup.value, edgeIds);
    if (state2.multiSelectionActive) {
      for (const nodeId of nodeIds) {
        changedNodes.push(createSelectionChange(nodeId, selected2));
      }
      for (const edgeId of edgeIds) {
        changedEdges.push(createSelectionChange(edgeId, selected2));
      }
    }
    if (changedNodes.length) {
      state2.hooks.nodesChange.trigger(changedNodes);
    }
    if (changedEdges.length) {
      state2.hooks.edgesChange.trigger(changedEdges);
    }
  };
  const addSelectedNodes = (nodes) => {
    if (state2.multiSelectionActive) {
      const nodeChanges = nodes.map((node2) => createSelectionChange(node2.id, true));
      state2.hooks.nodesChange.trigger(nodeChanges);
      return;
    }
    state2.hooks.nodesChange.trigger(getSelectionChanges(nodeLookup.value, new Set(nodes.map((n) => n.id)), true));
    state2.hooks.edgesChange.trigger(getSelectionChanges(edgeLookup.value));
  };
  const addSelectedEdges = (edges) => {
    if (state2.multiSelectionActive) {
      const changedEdges = edges.map((edge2) => createSelectionChange(edge2.id, true));
      state2.hooks.edgesChange.trigger(changedEdges);
      return;
    }
    state2.hooks.edgesChange.trigger(getSelectionChanges(edgeLookup.value, new Set(edges.map((e) => e.id))));
    state2.hooks.nodesChange.trigger(getSelectionChanges(nodeLookup.value, /* @__PURE__ */ new Set(), true));
  };
  const addSelectedElements = (elements) => {
    elementSelectionHandler(elements, true);
  };
  const removeSelectedNodes = (nodes) => {
    const nodesToUnselect = nodes || state2.nodes;
    const nodeChanges = nodesToUnselect.map((n) => {
      n.selected = false;
      return createSelectionChange(n.id, false);
    });
    state2.hooks.nodesChange.trigger(nodeChanges);
  };
  const removeSelectedEdges = (edges) => {
    const edgesToUnselect = edges || state2.edges;
    const edgeChanges = edgesToUnselect.map((e) => {
      e.selected = false;
      return createSelectionChange(e.id, false);
    });
    state2.hooks.edgesChange.trigger(edgeChanges);
  };
  const removeSelectedElements = (elements) => {
    if (!elements || !elements.length) {
      return elementSelectionHandler([], false);
    }
    const changes = elements.reduce(
      (changes2, curr) => {
        const selectionChange = createSelectionChange(curr.id, false);
        if (isNode(curr)) {
          changes2.nodes.push(selectionChange);
        } else {
          changes2.edges.push(selectionChange);
        }
        return changes2;
      },
      { nodes: [], edges: [] }
    );
    if (changes.nodes.length) {
      state2.hooks.nodesChange.trigger(changes.nodes);
    }
    if (changes.edges.length) {
      state2.hooks.edgesChange.trigger(changes.edges);
    }
  };
  const setMinZoom = (minZoom) => {
    var _a;
    (_a = state2.d3Zoom) == null ? void 0 : _a.scaleExtent([minZoom, state2.maxZoom]);
    state2.minZoom = minZoom;
  };
  const setMaxZoom = (maxZoom) => {
    var _a;
    (_a = state2.d3Zoom) == null ? void 0 : _a.scaleExtent([state2.minZoom, maxZoom]);
    state2.maxZoom = maxZoom;
  };
  const setTranslateExtent = (translateExtent) => {
    var _a;
    (_a = state2.d3Zoom) == null ? void 0 : _a.translateExtent(translateExtent);
    state2.translateExtent = translateExtent;
  };
  const setNodeExtent = (nodeExtent) => {
    state2.nodeExtent = nodeExtent;
    updateNodeInternals();
  };
  const setPaneClickDistance = (clickDistance) => {
    var _a;
    (_a = state2.d3Zoom) == null ? void 0 : _a.clickDistance(clickDistance);
  };
  const setInteractive = (isInteractive) => {
    state2.nodesDraggable = isInteractive;
    state2.nodesConnectable = isInteractive;
    state2.elementsSelectable = isInteractive;
  };
  const setNodes = (nodes) => {
    const nextNodes = nodes instanceof Function ? nodes(state2.nodes) : nodes;
    if (!state2.initialized && !nextNodes.length) {
      return;
    }
    state2.nodes = createGraphNodes(nextNodes, findNode, state2.hooks.error.trigger);
  };
  const setEdges = (edges) => {
    const nextEdges = edges instanceof Function ? edges(state2.edges) : edges;
    if (!state2.initialized && !nextEdges.length) {
      return;
    }
    const validEdges = createGraphEdges(
      nextEdges,
      state2.isValidConnection,
      findNode,
      findEdge,
      state2.hooks.error.trigger,
      state2.defaultEdgeOptions,
      state2.nodes,
      state2.edges
    );
    updateConnectionLookup(state2.connectionLookup, validEdges);
    state2.edges = validEdges;
  };
  const setElements = (elements) => {
    const nextElements = elements instanceof Function ? elements([...state2.nodes, ...state2.edges]) : elements;
    if (!state2.initialized && !nextElements.length) {
      return;
    }
    setNodes(nextElements.filter(isNode));
    setEdges(nextElements.filter(isEdge));
  };
  const addNodes2 = (nodes) => {
    let nextNodes = nodes instanceof Function ? nodes(state2.nodes) : nodes;
    nextNodes = Array.isArray(nextNodes) ? nextNodes : [nextNodes];
    const graphNodes = createGraphNodes(nextNodes, findNode, state2.hooks.error.trigger);
    const changes = [];
    for (const node2 of graphNodes) {
      changes.push(createAdditionChange(node2));
    }
    if (changes.length) {
      state2.hooks.nodesChange.trigger(changes);
    }
  };
  const addEdges = (params) => {
    let nextEdges = params instanceof Function ? params(state2.edges) : params;
    nextEdges = Array.isArray(nextEdges) ? nextEdges : [nextEdges];
    const validEdges = createGraphEdges(
      nextEdges,
      state2.isValidConnection,
      findNode,
      findEdge,
      state2.hooks.error.trigger,
      state2.defaultEdgeOptions,
      state2.nodes,
      state2.edges
    );
    const changes = [];
    for (const edge2 of validEdges) {
      changes.push(createAdditionChange(edge2));
    }
    if (changes.length) {
      state2.hooks.edgesChange.trigger(changes);
    }
  };
  const removeNodes = (nodes, removeConnectedEdges = true, removeChildren = false) => {
    const nextNodes = nodes instanceof Function ? nodes(state2.nodes) : nodes;
    const nodesToRemove = Array.isArray(nextNodes) ? nextNodes : [nextNodes];
    const nodeChanges = [];
    const edgeChanges = [];
    function createEdgeRemovalChanges(nodes2) {
      const connectedEdges = getConnectedEdges$1(nodes2);
      for (const edge2 of connectedEdges) {
        if (isDef(edge2.deletable) ? edge2.deletable : true) {
          edgeChanges.push(createEdgeRemoveChange(edge2.id, edge2.source, edge2.target, edge2.sourceHandle, edge2.targetHandle));
        }
      }
    }
    function createChildrenRemovalChanges(id2) {
      const children2 = [];
      for (const node2 of state2.nodes) {
        if (node2.parentNode === id2) {
          children2.push(node2);
        }
      }
      if (children2.length) {
        for (const child of children2) {
          nodeChanges.push(createNodeRemoveChange(child.id));
        }
        if (removeConnectedEdges) {
          createEdgeRemovalChanges(children2);
        }
        for (const child of children2) {
          createChildrenRemovalChanges(child.id);
        }
      }
    }
    for (const item of nodesToRemove) {
      const currNode = typeof item === "string" ? findNode(item) : item;
      if (!currNode) {
        continue;
      }
      if (isDef(currNode.deletable) && !currNode.deletable) {
        continue;
      }
      nodeChanges.push(createNodeRemoveChange(currNode.id));
      if (removeConnectedEdges) {
        createEdgeRemovalChanges([currNode]);
      }
      if (removeChildren) {
        createChildrenRemovalChanges(currNode.id);
      }
    }
    if (edgeChanges.length) {
      state2.hooks.edgesChange.trigger(edgeChanges);
    }
    if (nodeChanges.length) {
      state2.hooks.nodesChange.trigger(nodeChanges);
    }
  };
  const removeEdges = (edges) => {
    const nextEdges = edges instanceof Function ? edges(state2.edges) : edges;
    const edgesToRemove = Array.isArray(nextEdges) ? nextEdges : [nextEdges];
    const changes = [];
    for (const item of edgesToRemove) {
      const currEdge = typeof item === "string" ? findEdge(item) : item;
      if (!currEdge) {
        continue;
      }
      if (isDef(currEdge.deletable) && !currEdge.deletable) {
        continue;
      }
      changes.push(
        createEdgeRemoveChange(
          typeof item === "string" ? item : item.id,
          currEdge.source,
          currEdge.target,
          currEdge.sourceHandle,
          currEdge.targetHandle
        )
      );
    }
    state2.hooks.edgesChange.trigger(changes);
  };
  const updateEdge2 = (oldEdge, newConnection, shouldReplaceId = true) => {
    return updateEdgeAction(oldEdge, newConnection, state2.edges, findEdge, shouldReplaceId, state2.hooks.error.trigger);
  };
  const updateEdgeData = (id2, dataUpdate, options = { replace: false }) => {
    const edge2 = findEdge(id2);
    if (!edge2) {
      return;
    }
    const nextData = typeof dataUpdate === "function" ? dataUpdate(edge2) : dataUpdate;
    edge2.data = options.replace ? nextData : { ...edge2.data, ...nextData };
  };
  const applyNodeChanges2 = (changes) => {
    return applyChanges(changes, state2.nodes);
  };
  const applyEdgeChanges2 = (changes) => {
    const changedEdges = applyChanges(changes, state2.edges);
    updateConnectionLookup(state2.connectionLookup, changedEdges);
    return changedEdges;
  };
  const updateNode = (id2, nodeUpdate, options = { replace: false }) => {
    const node2 = findNode(id2);
    if (!node2) {
      return;
    }
    const nextNode = typeof nodeUpdate === "function" ? nodeUpdate(node2) : nodeUpdate;
    if (options.replace) {
      state2.nodes.splice(state2.nodes.indexOf(node2), 1, nextNode);
    } else {
      Object.assign(node2, nextNode);
    }
  };
  const updateNodeData = (id2, dataUpdate, options = { replace: false }) => {
    const node2 = findNode(id2);
    if (!node2) {
      return;
    }
    const nextData = typeof dataUpdate === "function" ? dataUpdate(node2) : dataUpdate;
    node2.data = options.replace ? nextData : { ...node2.data, ...nextData };
  };
  const startConnection = (startHandle, position2, isClick = false) => {
    if (isClick) {
      state2.connectionClickStartHandle = startHandle;
    } else {
      state2.connectionStartHandle = startHandle;
    }
    state2.connectionEndHandle = null;
    state2.connectionStatus = null;
    if (position2) {
      state2.connectionPosition = position2;
    }
  };
  const updateConnection = (position2, result = null, status2 = null) => {
    if (state2.connectionStartHandle) {
      state2.connectionPosition = position2;
      state2.connectionEndHandle = result;
      state2.connectionStatus = status2;
    }
  };
  const endConnection = (event, isClick) => {
    state2.connectionPosition = { x: Number.NaN, y: Number.NaN };
    state2.connectionEndHandle = null;
    state2.connectionStatus = null;
    if (isClick) {
      state2.connectionClickStartHandle = null;
    } else {
      state2.connectionStartHandle = null;
    }
  };
  const getNodeRect = (nodeOrRect) => {
    const isRectObj = isRect(nodeOrRect);
    const node2 = isRectObj ? null : isGraphNode(nodeOrRect) ? nodeOrRect : findNode(nodeOrRect.id);
    if (!isRectObj && !node2) {
      return [null, null, isRectObj];
    }
    const nodeRect = isRectObj ? nodeOrRect : nodeToRect(node2);
    return [nodeRect, node2, isRectObj];
  };
  const getIntersectingNodes = (nodeOrRect, partially = true, nodes = state2.nodes) => {
    const [nodeRect, node2, isRect2] = getNodeRect(nodeOrRect);
    if (!nodeRect) {
      return [];
    }
    const intersections = [];
    for (const n of nodes || state2.nodes) {
      if (!isRect2 && (n.id === node2.id || !n.computedPosition)) {
        continue;
      }
      const currNodeRect = nodeToRect(n);
      const overlappingArea = getOverlappingArea(currNodeRect, nodeRect);
      const partiallyVisible = partially && overlappingArea > 0;
      if (partiallyVisible || overlappingArea >= Number(nodeRect.width) * Number(nodeRect.height)) {
        intersections.push(n);
      }
    }
    return intersections;
  };
  const isNodeIntersecting = (nodeOrRect, area, partially = true) => {
    const [nodeRect] = getNodeRect(nodeOrRect);
    if (!nodeRect) {
      return false;
    }
    const overlappingArea = getOverlappingArea(nodeRect, area);
    const partiallyVisible = partially && overlappingArea > 0;
    return partiallyVisible || overlappingArea >= Number(nodeRect.width) * Number(nodeRect.height);
  };
  const panBy = (delta) => {
    const { viewport, dimensions, d3Zoom, d3Selection, translateExtent } = state2;
    if (!d3Zoom || !d3Selection || !delta.x && !delta.y) {
      return false;
    }
    const nextTransform = identity$2.translate(viewport.x + delta.x, viewport.y + delta.y).scale(viewport.zoom);
    const extent = [
      [0, 0],
      [dimensions.width, dimensions.height]
    ];
    const constrainedTransform = d3Zoom.constrain()(nextTransform, extent, translateExtent);
    const transformChanged = state2.viewport.x !== constrainedTransform.x || state2.viewport.y !== constrainedTransform.y || state2.viewport.zoom !== constrainedTransform.k;
    d3Zoom.transform(d3Selection, constrainedTransform);
    return transformChanged;
  };
  const setState = (options) => {
    const opts = options instanceof Function ? options(state2) : options;
    const exclude = [
      "d3Zoom",
      "d3Selection",
      "d3ZoomHandler",
      "viewportRef",
      "vueFlowRef",
      "dimensions",
      "hooks"
    ];
    if (isDef(opts.defaultEdgeOptions)) {
      state2.defaultEdgeOptions = opts.defaultEdgeOptions;
    }
    const elements = opts.modelValue || opts.nodes || opts.edges ? [] : void 0;
    if (elements) {
      if (opts.modelValue) {
        elements.push(...opts.modelValue);
      }
      if (opts.nodes) {
        elements.push(...opts.nodes);
      }
      if (opts.edges) {
        elements.push(...opts.edges);
      }
      setElements(elements);
    }
    const setSkippedOptions = () => {
      if (isDef(opts.maxZoom)) {
        setMaxZoom(opts.maxZoom);
      }
      if (isDef(opts.minZoom)) {
        setMinZoom(opts.minZoom);
      }
      if (isDef(opts.translateExtent)) {
        setTranslateExtent(opts.translateExtent);
      }
    };
    for (const o of Object.keys(opts)) {
      const key = o;
      const option2 = opts[key];
      if (![...storeOptionsToSkip, ...exclude].includes(key) && isDef(option2)) {
        state2[key] = option2;
      }
    }
    until(() => state2.d3Zoom).not.toBeNull().then(setSkippedOptions);
    if (!state2.initialized) {
      state2.initialized = true;
    }
  };
  const toObject = () => {
    const nodes = [];
    const edges = [];
    for (const node2 of state2.nodes) {
      const {
        computedPosition: _,
        handleBounds: __,
        selected: ___,
        dimensions: ____,
        isParent: _____,
        resizing: ______,
        dragging: _______,
        events: _________,
        ...rest
      } = node2;
      nodes.push(rest);
    }
    for (const edge2 of state2.edges) {
      const { selected: _, sourceNode: __, targetNode: ___, events: ____, ...rest } = edge2;
      edges.push(rest);
    }
    return JSON.parse(
      JSON.stringify({
        nodes,
        edges,
        position: [state2.viewport.x, state2.viewport.y],
        zoom: state2.viewport.zoom,
        viewport: state2.viewport
      })
    );
  };
  const fromObject = (obj) => {
    return new Promise((resolve) => {
      const { nodes, edges, position: position2, zoom: zoom2, viewport } = obj;
      if (nodes) {
        setNodes(nodes);
      }
      if (edges) {
        setEdges(edges);
      }
      if ((viewport == null ? void 0 : viewport.x) && (viewport == null ? void 0 : viewport.y) || position2) {
        const x = (viewport == null ? void 0 : viewport.x) || position2[0];
        const y = (viewport == null ? void 0 : viewport.y) || position2[1];
        const nextZoom = (viewport == null ? void 0 : viewport.zoom) || zoom2 || state2.viewport.zoom;
        return until(() => viewportHelper.value.viewportInitialized).toBe(true).then(() => {
          viewportHelper.value.setViewport({
            x,
            y,
            zoom: nextZoom
          }).then(() => {
            resolve(true);
          });
        });
      } else {
        resolve(true);
      }
    });
  };
  const $reset = () => {
    const resetState = useState();
    state2.edges = [];
    state2.nodes = [];
    if (state2.d3Zoom && state2.d3Selection) {
      const updatedTransform = identity$2.translate(resetState.defaultViewport.x ?? 0, resetState.defaultViewport.y ?? 0).scale(clamp(resetState.defaultViewport.zoom ?? 1, resetState.minZoom, resetState.maxZoom));
      const bbox = state2.viewportRef.getBoundingClientRect();
      const extent = [
        [0, 0],
        [bbox.width, bbox.height]
      ];
      const constrainedTransform = state2.d3Zoom.constrain()(updatedTransform, extent, resetState.translateExtent);
      state2.d3Zoom.transform(state2.d3Selection, constrainedTransform);
    }
    setState(resetState);
  };
  return {
    updateNodePositions,
    updateNodeDimensions,
    setElements,
    setNodes,
    setEdges,
    addNodes: addNodes2,
    addEdges,
    removeNodes,
    removeEdges,
    findNode,
    findEdge,
    updateEdge: updateEdge2,
    updateEdgeData,
    updateNode,
    updateNodeData,
    applyEdgeChanges: applyEdgeChanges2,
    applyNodeChanges: applyNodeChanges2,
    addSelectedElements,
    addSelectedNodes,
    addSelectedEdges,
    setMinZoom,
    setMaxZoom,
    setTranslateExtent,
    setNodeExtent,
    setPaneClickDistance,
    removeSelectedElements,
    removeSelectedNodes,
    removeSelectedEdges,
    startConnection,
    updateConnection,
    endConnection,
    setInteractive,
    setState,
    getIntersectingNodes,
    getIncomers: getIncomers$1,
    getOutgoers: getOutgoers$1,
    getConnectedEdges: getConnectedEdges$1,
    getHandleConnections,
    isNodeIntersecting,
    panBy,
    fitView: (params) => viewportHelper.value.fitView(params),
    zoomIn: (transitionOpts) => viewportHelper.value.zoomIn(transitionOpts),
    zoomOut: (transitionOpts) => viewportHelper.value.zoomOut(transitionOpts),
    zoomTo: (zoomLevel, transitionOpts) => viewportHelper.value.zoomTo(zoomLevel, transitionOpts),
    setViewport: (params, transitionOpts) => viewportHelper.value.setViewport(params, transitionOpts),
    setTransform: (params, transitionOpts) => viewportHelper.value.setTransform(params, transitionOpts),
    getViewport: () => viewportHelper.value.getViewport(),
    getTransform: () => viewportHelper.value.getTransform(),
    setCenter: (x, y, opts) => viewportHelper.value.setCenter(x, y, opts),
    fitBounds: (params, opts) => viewportHelper.value.fitBounds(params, opts),
    project: (params) => viewportHelper.value.project(params),
    screenToFlowCoordinate: (params) => viewportHelper.value.screenToFlowCoordinate(params),
    flowToScreenCoordinate: (params) => viewportHelper.value.flowToScreenCoordinate(params),
    toObject,
    fromObject,
    updateNodeInternals,
    viewportHelper,
    $reset,
    $destroy: () => {
    }
  };
}
const _hoisted_1$9 = ["data-id", "data-handleid", "data-nodeid", "data-handlepos"];
const __default__$f = {
  name: "Handle",
  compatConfig: { MODE: 3 }
};
const _sfc_main$f$1 = /* @__PURE__ */ defineComponent({
  ...__default__$f,
  props: {
    id: { default: null },
    type: {},
    position: { default: () => Position.Top },
    isValidConnection: { type: Function },
    connectable: { type: [Boolean, Number, String, Function], default: void 0 },
    connectableStart: { type: Boolean, default: true },
    connectableEnd: { type: Boolean, default: true }
  },
  setup(__props, { expose: __expose }) {
    const props = createPropsRestProxy(__props, ["position", "connectable", "connectableStart", "connectableEnd", "id"]);
    const type = toRef(() => props.type ?? "source");
    const isValidConnection = toRef(() => props.isValidConnection ?? null);
    const {
      connectionStartHandle,
      connectionClickStartHandle,
      connectionEndHandle,
      vueFlowRef,
      nodesConnectable,
      noDragClassName,
      noPanClassName
    } = useVueFlow();
    const { id: nodeId, node: node2, nodeEl, connectedEdges } = useNode();
    const handle2 = ref();
    const isConnectableStart = toRef(() => typeof __props.connectableStart !== "undefined" ? __props.connectableStart : true);
    const isConnectableEnd = toRef(() => typeof __props.connectableEnd !== "undefined" ? __props.connectableEnd : true);
    const isConnecting = toRef(
      () => {
        var _a, _b, _c, _d, _e, _f;
        return ((_a = connectionStartHandle.value) == null ? void 0 : _a.nodeId) === nodeId && ((_b = connectionStartHandle.value) == null ? void 0 : _b.handleId) === __props.id && ((_c = connectionStartHandle.value) == null ? void 0 : _c.type) === type.value || ((_d = connectionEndHandle.value) == null ? void 0 : _d.nodeId) === nodeId && ((_e = connectionEndHandle.value) == null ? void 0 : _e.handleId) === __props.id && ((_f = connectionEndHandle.value) == null ? void 0 : _f.type) === type.value;
      }
    );
    const isClickConnecting = toRef(
      () => {
        var _a, _b, _c;
        return ((_a = connectionClickStartHandle.value) == null ? void 0 : _a.nodeId) === nodeId && ((_b = connectionClickStartHandle.value) == null ? void 0 : _b.handleId) === __props.id && ((_c = connectionClickStartHandle.value) == null ? void 0 : _c.type) === type.value;
      }
    );
    const { handlePointerDown, handleClick } = useHandle({
      nodeId,
      handleId: __props.id,
      isValidConnection,
      type
    });
    const isConnectable = computed(() => {
      if (typeof __props.connectable === "string" && __props.connectable === "single") {
        return !connectedEdges.value.some((edge2) => {
          const id2 = edge2[`${type.value}Handle`];
          if (edge2[type.value] !== nodeId) {
            return false;
          }
          return id2 ? id2 === __props.id : true;
        });
      }
      if (typeof __props.connectable === "number") {
        return connectedEdges.value.filter((edge2) => {
          const id2 = edge2[`${type.value}Handle`];
          if (edge2[type.value] !== nodeId) {
            return false;
          }
          return id2 ? id2 === __props.id : true;
        }).length < __props.connectable;
      }
      if (typeof __props.connectable === "function") {
        return __props.connectable(node2, connectedEdges.value);
      }
      return isDef(__props.connectable) ? __props.connectable : nodesConnectable.value;
    });
    onMounted(() => {
      var _a;
      if (!node2.dimensions.width || !node2.dimensions.height) {
        return;
      }
      const existingBounds = (_a = node2.handleBounds[type.value]) == null ? void 0 : _a.find((b) => b.id === __props.id);
      if (!vueFlowRef.value || existingBounds) {
        return;
      }
      const viewportNode = vueFlowRef.value.querySelector(".vue-flow__transformationpane");
      if (!nodeEl.value || !handle2.value || !viewportNode || !__props.id) {
        return;
      }
      const nodeBounds = nodeEl.value.getBoundingClientRect();
      const handleBounds = handle2.value.getBoundingClientRect();
      const style = window.getComputedStyle(viewportNode);
      const { m22: zoom2 } = new window.DOMMatrixReadOnly(style.transform);
      const nextBounds = {
        id: __props.id,
        position: __props.position,
        x: (handleBounds.left - nodeBounds.left) / zoom2,
        y: (handleBounds.top - nodeBounds.top) / zoom2,
        ...getDimensions(handle2.value)
      };
      node2.handleBounds[type.value] = [...node2.handleBounds[type.value] ?? [], nextBounds];
    });
    onUnmounted(() => {
      const handleBounds = node2.handleBounds[type.value];
      if (handleBounds) {
        node2.handleBounds[type.value] = handleBounds.filter((b) => b.id !== __props.id);
      }
    });
    function onPointerDown(event) {
      const isMouseTriggered = isMouseEvent(event);
      if (isConnectable.value && isConnectableStart.value && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {
        handlePointerDown(event);
      }
    }
    function onClick(event) {
      if (!nodeId || !connectionClickStartHandle.value && !isConnectableStart.value) {
        return;
      }
      if (isConnectable.value) {
        handleClick(event);
      }
    }
    __expose({
      handleClick,
      handlePointerDown,
      onClick,
      onPointerDown
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "handle",
        ref: handle2,
        "data-id": `${unref(nodeId)}-${__props.id}-${type.value}`,
        "data-handleid": __props.id,
        "data-nodeid": unref(nodeId),
        "data-handlepos": _ctx.position,
        class: normalizeClass(["vue-flow__handle", [
          `vue-flow__handle-${_ctx.position}`,
          `vue-flow__handle-${__props.id}`,
          unref(noDragClassName),
          unref(noPanClassName),
          type.value,
          {
            connectable: isConnectable.value,
            connecting: isClickConnecting.value,
            connectablestart: isConnectableStart.value,
            connectableend: isConnectableEnd.value,
            connectionindicator: isConnectable.value && (isConnectableStart.value && !isConnecting.value || isConnectableEnd.value && isConnecting.value)
          }
        ]]),
        onMousedown: onPointerDown,
        onTouchstartPassive: onPointerDown,
        onClick
      }, [
        renderSlot(_ctx.$slots, "default", { id: _ctx.id })
      ], 42, _hoisted_1$9);
    };
  }
});
const DefaultNode = function({
  sourcePosition = Position.Bottom,
  targetPosition = Position.Top,
  label: _label,
  connectable = true,
  isValidTargetPos,
  isValidSourcePos,
  data
}) {
  const label2 = data.label || _label;
  return [
    h(_sfc_main$f$1, { type: "target", position: targetPosition, connectable, isValidConnection: isValidTargetPos }),
    typeof label2 !== "string" && label2 ? h(label2) : h("div", { innerHTML: label2 }),
    h(_sfc_main$f$1, { type: "source", position: sourcePosition, connectable, isValidConnection: isValidSourcePos })
  ];
};
DefaultNode.props = ["sourcePosition", "targetPosition", "label", "isValidTargetPos", "isValidSourcePos", "connectable", "data"];
DefaultNode.inheritAttrs = false;
DefaultNode.compatConfig = { MODE: 3 };
const DefaultNode$1 = DefaultNode;
const OutputNode = function({
  targetPosition = Position.Top,
  label: _label,
  connectable = true,
  isValidTargetPos,
  data
}) {
  const label2 = data.label || _label;
  return [
    h(_sfc_main$f$1, { type: "target", position: targetPosition, connectable, isValidConnection: isValidTargetPos }),
    typeof label2 !== "string" && label2 ? h(label2) : h("div", { innerHTML: label2 })
  ];
};
OutputNode.props = ["targetPosition", "label", "isValidTargetPos", "connectable", "data"];
OutputNode.inheritAttrs = false;
OutputNode.compatConfig = { MODE: 3 };
const OutputNode$1 = OutputNode;
const InputNode = function({
  sourcePosition = Position.Bottom,
  label: _label,
  connectable = true,
  isValidSourcePos,
  data
}) {
  const label2 = data.label || _label;
  return [
    typeof label2 !== "string" && label2 ? h(label2) : h("div", { innerHTML: label2 }),
    h(_sfc_main$f$1, { type: "source", position: sourcePosition, connectable, isValidConnection: isValidSourcePos })
  ];
};
InputNode.props = ["sourcePosition", "label", "isValidSourcePos", "connectable", "data"];
InputNode.inheritAttrs = false;
InputNode.compatConfig = { MODE: 3 };
const InputNode$1 = InputNode;
const _hoisted_1$8$1 = ["transform"];
const _hoisted_2$2$2 = ["width", "height", "x", "y", "rx", "ry"];
const _hoisted_3$1$2 = ["y"];
const __default__$e = {
  name: "EdgeText",
  compatConfig: { MODE: 3 }
};
const _sfc_main$e$1 = /* @__PURE__ */ defineComponent({
  ...__default__$e,
  props: {
    x: {},
    y: {},
    label: {},
    labelStyle: { default: () => ({}) },
    labelShowBg: { type: Boolean, default: true },
    labelBgStyle: { default: () => ({}) },
    labelBgPadding: { default: () => [2, 4] },
    labelBgBorderRadius: { default: 2 }
  },
  setup(__props) {
    const box = ref({ x: 0, y: 0, width: 0, height: 0 });
    const el = ref(null);
    const transform = computed(() => `translate(${__props.x - box.value.width / 2} ${__props.y - box.value.height / 2})`);
    onMounted(getBox);
    watch([() => __props.x, () => __props.y, el, () => __props.label], getBox);
    function getBox() {
      if (!el.value) {
        return;
      }
      const nextBox = el.value.getBBox();
      if (nextBox.width !== box.value.width || nextBox.height !== box.value.height) {
        box.value = nextBox;
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        transform: transform.value,
        class: "vue-flow__edge-textwrapper"
      }, [
        _ctx.labelShowBg ? (openBlock(), createElementBlock("rect", {
          key: 0,
          class: "vue-flow__edge-textbg",
          width: `${box.value.width + 2 * _ctx.labelBgPadding[0]}px`,
          height: `${box.value.height + 2 * _ctx.labelBgPadding[1]}px`,
          x: -_ctx.labelBgPadding[0],
          y: -_ctx.labelBgPadding[1],
          style: normalizeStyle(_ctx.labelBgStyle),
          rx: _ctx.labelBgBorderRadius,
          ry: _ctx.labelBgBorderRadius
        }, null, 12, _hoisted_2$2$2)) : createCommentVNode("", true),
        createBaseVNode("text", mergeProps(_ctx.$attrs, {
          ref_key: "el",
          ref: el,
          class: "vue-flow__edge-text",
          y: box.value.height / 2,
          dy: "0.3em",
          style: _ctx.labelStyle
        }), [
          renderSlot(_ctx.$slots, "default", {}, () => [
            typeof _ctx.label !== "string" ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.label), { key: 0 })) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ], 64))
          ])
        ], 16, _hoisted_3$1$2)
      ], 8, _hoisted_1$8$1);
    };
  }
});
const _hoisted_1$7$1 = ["id", "d", "marker-end", "marker-start"];
const _hoisted_2$1$2 = ["d", "stroke-width"];
const __default__$d = {
  name: "BaseEdge",
  inheritAttrs: false,
  compatConfig: { MODE: 3 }
};
const _sfc_main$d$1 = /* @__PURE__ */ defineComponent({
  ...__default__$d,
  props: {
    id: {},
    labelX: {},
    labelY: {},
    path: {},
    label: {},
    markerStart: {},
    markerEnd: {},
    interactionWidth: { default: 20 },
    style: {},
    labelStyle: {},
    labelShowBg: { type: Boolean, default: true },
    labelBgStyle: {},
    labelBgPadding: {},
    labelBgBorderRadius: {}
  },
  setup(__props, { expose: __expose }) {
    const props = createPropsRestProxy(__props, ["interactionWidth", "labelShowBg"]);
    const pathEl = ref(null);
    const interactionEl = ref(null);
    const labelEl = ref(null);
    const attrs = useAttrs();
    __expose({
      pathEl,
      interactionEl,
      labelEl
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("path", {
          id: _ctx.id,
          ref_key: "pathEl",
          ref: pathEl,
          d: _ctx.path,
          style: normalizeStyle(props.style),
          class: normalizeClass(["vue-flow__edge-path", unref(attrs).class]),
          "marker-end": _ctx.markerEnd,
          "marker-start": _ctx.markerStart
        }, null, 14, _hoisted_1$7$1),
        _ctx.interactionWidth ? (openBlock(), createElementBlock("path", {
          key: 0,
          ref_key: "interactionEl",
          ref: interactionEl,
          fill: "none",
          d: _ctx.path,
          "stroke-width": _ctx.interactionWidth,
          "stroke-opacity": 0,
          class: "vue-flow__edge-interaction"
        }, null, 8, _hoisted_2$1$2)) : createCommentVNode("", true),
        _ctx.label && _ctx.labelX && _ctx.labelY ? (openBlock(), createBlock(_sfc_main$e$1, {
          key: 1,
          ref_key: "labelEl",
          ref: labelEl,
          x: _ctx.labelX,
          y: _ctx.labelY,
          label: _ctx.label,
          "label-show-bg": _ctx.labelShowBg,
          "label-bg-style": _ctx.labelBgStyle,
          "label-bg-padding": _ctx.labelBgPadding,
          "label-bg-border-radius": _ctx.labelBgBorderRadius,
          "label-style": _ctx.labelStyle
        }, null, 8, ["x", "y", "label", "label-show-bg", "label-bg-style", "label-bg-padding", "label-bg-border-radius", "label-style"])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
function getSimpleEdgeCenter({
  sourceX,
  sourceY,
  targetX,
  targetY
}) {
  const xOffset = Math.abs(targetX - sourceX) / 2;
  const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;
  const yOffset = Math.abs(targetY - sourceY) / 2;
  const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;
  return [centerX, centerY, xOffset, yOffset];
}
function getBezierEdgeCenter({
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourceControlX,
  sourceControlY,
  targetControlX,
  targetControlY
}) {
  const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;
  const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;
  const offsetX = Math.abs(centerX - sourceX);
  const offsetY = Math.abs(centerY - sourceY);
  return [centerX, centerY, offsetX, offsetY];
}
function calculateControlOffset(distance2, curvature) {
  if (distance2 >= 0) {
    return 0.5 * distance2;
  } else {
    return curvature * 25 * Math.sqrt(-distance2);
  }
}
function getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {
  let ctX, ctY;
  switch (pos) {
    case Position.Left:
      ctX = x1 - calculateControlOffset(x1 - x2, c);
      ctY = y1;
      break;
    case Position.Right:
      ctX = x1 + calculateControlOffset(x2 - x1, c);
      ctY = y1;
      break;
    case Position.Top:
      ctX = x1;
      ctY = y1 - calculateControlOffset(y1 - y2, c);
      break;
    case Position.Bottom:
      ctX = x1;
      ctY = y1 + calculateControlOffset(y2 - y1, c);
      break;
  }
  return [ctX, ctY];
}
function getBezierPath(bezierPathParams) {
  const {
    sourceX,
    sourceY,
    sourcePosition = Position.Bottom,
    targetX,
    targetY,
    targetPosition = Position.Top,
    curvature = 0.25
  } = bezierPathParams;
  const [sourceControlX, sourceControlY] = getControlWithCurvature({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY,
    c: curvature
  });
  const [targetControlX, targetControlY] = getControlWithCurvature({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY,
    c: curvature
  });
  const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    labelX,
    labelY,
    offsetX,
    offsetY
  ];
}
function getControl({ pos, x1, y1, x2, y2 }) {
  let ctX, ctY;
  switch (pos) {
    case Position.Left:
    case Position.Right:
      ctX = 0.5 * (x1 + x2);
      ctY = y1;
      break;
    case Position.Top:
    case Position.Bottom:
      ctX = x1;
      ctY = 0.5 * (y1 + y2);
      break;
  }
  return [ctX, ctY];
}
function getSimpleBezierPath(simpleBezierPathParams) {
  const {
    sourceX,
    sourceY,
    sourcePosition = Position.Bottom,
    targetX,
    targetY,
    targetPosition = Position.Top
  } = simpleBezierPathParams;
  const [sourceControlX, sourceControlY] = getControl({
    pos: sourcePosition,
    x1: sourceX,
    y1: sourceY,
    x2: targetX,
    y2: targetY
  });
  const [targetControlX, targetControlY] = getControl({
    pos: targetPosition,
    x1: targetX,
    y1: targetY,
    x2: sourceX,
    y2: sourceY
  });
  const [centerX, centerY, offsetX, offsetY] = getBezierEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY,
    sourceControlX,
    sourceControlY,
    targetControlX,
    targetControlY
  });
  return [
    `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,
    centerX,
    centerY,
    offsetX,
    offsetY
  ];
}
const handleDirections = {
  [Position.Left]: { x: -1, y: 0 },
  [Position.Right]: { x: 1, y: 0 },
  [Position.Top]: { x: 0, y: -1 },
  [Position.Bottom]: { x: 0, y: 1 }
};
function getDirection$1({
  source,
  sourcePosition = Position.Bottom,
  target: target2
}) {
  if (sourcePosition === Position.Left || sourcePosition === Position.Right) {
    return source.x < target2.x ? { x: 1, y: 0 } : { x: -1, y: 0 };
  }
  return source.y < target2.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
}
function distance(a, b) {
  return Math.sqrt((b.x - a.x) ** 2 + (b.y - a.y) ** 2);
}
function getPoints({
  source,
  sourcePosition = Position.Bottom,
  target: target2,
  targetPosition = Position.Top,
  center: center2,
  offset
}) {
  const sourceDir = handleDirections[sourcePosition];
  const targetDir = handleDirections[targetPosition];
  const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };
  const targetGapped = { x: target2.x + targetDir.x * offset, y: target2.y + targetDir.y * offset };
  const dir = getDirection$1({
    source: sourceGapped,
    sourcePosition,
    target: targetGapped
  });
  const dirAccessor = dir.x !== 0 ? "x" : "y";
  const currDir = dir[dirAccessor];
  let points;
  let centerX, centerY;
  const sourceGapOffset = { x: 0, y: 0 };
  const targetGapOffset = { x: 0, y: 0 };
  const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getSimpleEdgeCenter({
    sourceX: source.x,
    sourceY: source.y,
    targetX: target2.x,
    targetY: target2.y
  });
  if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {
    centerX = center2.x ?? defaultCenterX;
    centerY = center2.y ?? defaultCenterY;
    const verticalSplit = [
      { x: centerX, y: sourceGapped.y },
      { x: centerX, y: targetGapped.y }
    ];
    const horizontalSplit = [
      { x: sourceGapped.x, y: centerY },
      { x: targetGapped.x, y: centerY }
    ];
    if (sourceDir[dirAccessor] === currDir) {
      points = dirAccessor === "x" ? verticalSplit : horizontalSplit;
    } else {
      points = dirAccessor === "x" ? horizontalSplit : verticalSplit;
    }
  } else {
    const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];
    const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];
    if (dirAccessor === "x") {
      points = sourceDir.x === currDir ? targetSource : sourceTarget;
    } else {
      points = sourceDir.y === currDir ? sourceTarget : targetSource;
    }
    if (sourcePosition === targetPosition) {
      const diff = Math.abs(source[dirAccessor] - target2[dirAccessor]);
      if (diff <= offset) {
        const gapOffset = Math.min(offset - 1, offset - diff);
        if (sourceDir[dirAccessor] === currDir) {
          sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;
        } else {
          targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target2[dirAccessor] ? -1 : 1) * gapOffset;
        }
      }
    }
    if (sourcePosition !== targetPosition) {
      const dirAccessorOpposite = dirAccessor === "x" ? "y" : "x";
      const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];
      const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];
      const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];
      const flipSourceTarget = sourceDir[dirAccessor] === 1 && (!isSameDir && sourceGtTargetOppo || isSameDir && sourceLtTargetOppo) || sourceDir[dirAccessor] !== 1 && (!isSameDir && sourceLtTargetOppo || isSameDir && sourceGtTargetOppo);
      if (flipSourceTarget) {
        points = dirAccessor === "x" ? sourceTarget : targetSource;
      }
    }
    const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };
    const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };
    const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));
    const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));
    if (maxXDistance >= maxYDistance) {
      centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;
      centerY = points[0].y;
    } else {
      centerX = points[0].x;
      centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;
    }
  }
  const pathPoints = [
    source,
    { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },
    ...points,
    { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },
    target2
  ];
  return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];
}
function getBend(a, b, c, size) {
  const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);
  const { x, y } = b;
  if (a.x === x && x === c.x || a.y === y && y === c.y) {
    return `L${x} ${y}`;
  }
  if (a.y === y) {
    const xDir2 = a.x < c.x ? -1 : 1;
    const yDir2 = a.y < c.y ? 1 : -1;
    return `L ${x + bendSize * xDir2},${y}Q ${x},${y} ${x},${y + bendSize * yDir2}`;
  }
  const xDir = a.x < c.x ? 1 : -1;
  const yDir = a.y < c.y ? -1 : 1;
  return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;
}
function getSmoothStepPath(smoothStepPathParams) {
  const {
    sourceX,
    sourceY,
    sourcePosition = Position.Bottom,
    targetX,
    targetY,
    targetPosition = Position.Top,
    borderRadius = 5,
    centerX,
    centerY,
    offset = 20
  } = smoothStepPathParams;
  const [points, labelX, labelY, offsetX, offsetY] = getPoints({
    source: { x: sourceX, y: sourceY },
    sourcePosition,
    target: { x: targetX, y: targetY },
    targetPosition,
    center: { x: centerX, y: centerY },
    offset
  });
  const path = points.reduce((res, p, i) => {
    let segment;
    if (i > 0 && i < points.length - 1) {
      segment = getBend(points[i - 1], p, points[i + 1], borderRadius);
    } else {
      segment = `${i === 0 ? "M" : "L"}${p.x} ${p.y}`;
    }
    res += segment;
    return res;
  }, "");
  return [path, labelX, labelY, offsetX, offsetY];
}
function getStraightPath(straightEdgeParams) {
  const { sourceX, sourceY, targetX, targetY } = straightEdgeParams;
  const [centerX, centerY, offsetX, offsetY] = getSimpleEdgeCenter({
    sourceX,
    sourceY,
    targetX,
    targetY
  });
  return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, centerX, centerY, offsetX, offsetY];
}
const StraightEdge = defineComponent({
  name: "StraightEdge",
  props: [
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(props, { attrs }) {
    return () => {
      const [path, labelX, labelY] = getStraightPath(props);
      return h(_sfc_main$d$1, {
        path,
        labelX,
        labelY,
        ...attrs,
        ...props
      });
    };
  }
});
const StraightEdge$1 = StraightEdge;
const SmoothStepEdge = defineComponent({
  name: "SmoothStepEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "borderRadius",
    "markerEnd",
    "markerStart",
    "interactionWidth",
    "offset"
  ],
  compatConfig: { MODE: 3 },
  setup(props, { attrs }) {
    return () => {
      const [path, labelX, labelY] = getSmoothStepPath({
        ...props,
        sourcePosition: props.sourcePosition ?? Position.Bottom,
        targetPosition: props.targetPosition ?? Position.Top
      });
      return h(_sfc_main$d$1, {
        path,
        labelX,
        labelY,
        ...attrs,
        ...props
      });
    };
  }
});
const SmoothStepEdge$1 = SmoothStepEdge;
const StepEdge = defineComponent({
  name: "StepEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  setup(props, { attrs }) {
    return () => h(SmoothStepEdge$1, { ...props, ...attrs, borderRadius: 0 });
  }
});
const StepEdge$1 = StepEdge;
const BezierEdge = defineComponent({
  name: "BezierEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "curvature",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(props, { attrs }) {
    return () => {
      const [path, labelX, labelY] = getBezierPath({
        ...props,
        sourcePosition: props.sourcePosition ?? Position.Bottom,
        targetPosition: props.targetPosition ?? Position.Top
      });
      return h(_sfc_main$d$1, {
        path,
        labelX,
        labelY,
        ...attrs,
        ...props
      });
    };
  }
});
const BezierEdge$1 = BezierEdge;
const SimpleBezierEdge = defineComponent({
  name: "SimpleBezierEdge",
  props: [
    "sourcePosition",
    "targetPosition",
    "label",
    "labelStyle",
    "labelShowBg",
    "labelBgStyle",
    "labelBgPadding",
    "labelBgBorderRadius",
    "sourceY",
    "sourceX",
    "targetX",
    "targetY",
    "markerEnd",
    "markerStart",
    "interactionWidth"
  ],
  compatConfig: { MODE: 3 },
  setup(props, { attrs }) {
    return () => {
      const [path, labelX, labelY] = getSimpleBezierPath({
        ...props,
        sourcePosition: props.sourcePosition ?? Position.Bottom,
        targetPosition: props.targetPosition ?? Position.Top
      });
      return h(_sfc_main$d$1, {
        path,
        labelX,
        labelY,
        ...attrs,
        ...props
      });
    };
  }
});
const SimpleBezierEdge$1 = SimpleBezierEdge;
const defaultNodeTypes = {
  input: InputNode$1,
  default: DefaultNode$1,
  output: OutputNode$1
};
const defaultEdgeTypes = {
  default: BezierEdge$1,
  straight: StraightEdge$1,
  step: StepEdge$1,
  smoothstep: SmoothStepEdge$1,
  simplebezier: SimpleBezierEdge$1
};
function useGetters(state2, nodeLookup, edgeLookup) {
  const getNode = computed(() => (id2) => nodeLookup.value.get(id2));
  const getEdge = computed(() => (id2) => edgeLookup.value.get(id2));
  const getEdgeTypes = computed(() => {
    const edgeTypes = {
      ...defaultEdgeTypes,
      ...state2.edgeTypes
    };
    const keys = Object.keys(edgeTypes);
    for (const e of state2.edges) {
      e.type && !keys.includes(e.type) && (edgeTypes[e.type] = e.type);
    }
    return edgeTypes;
  });
  const getNodeTypes = computed(() => {
    const nodeTypes = {
      ...defaultNodeTypes,
      ...state2.nodeTypes
    };
    const keys = Object.keys(nodeTypes);
    for (const n of state2.nodes) {
      n.type && !keys.includes(n.type) && (nodeTypes[n.type] = n.type);
    }
    return nodeTypes;
  });
  const getNodes = computed(() => {
    if (state2.onlyRenderVisibleElements) {
      return getNodesInside(
        state2.nodes,
        {
          x: 0,
          y: 0,
          width: state2.dimensions.width,
          height: state2.dimensions.height
        },
        state2.viewport,
        true
      );
    }
    return state2.nodes;
  });
  const getEdges = computed(() => {
    if (state2.onlyRenderVisibleElements) {
      const visibleEdges = [];
      for (const edge2 of state2.edges) {
        const source = nodeLookup.value.get(edge2.source);
        const target2 = nodeLookup.value.get(edge2.target);
        if (isEdgeVisible({
          sourcePos: source.computedPosition || { x: 0, y: 0 },
          targetPos: target2.computedPosition || { x: 0, y: 0 },
          sourceWidth: source.dimensions.width,
          sourceHeight: source.dimensions.height,
          targetWidth: target2.dimensions.width,
          targetHeight: target2.dimensions.height,
          width: state2.dimensions.width,
          height: state2.dimensions.height,
          viewport: state2.viewport
        })) {
          visibleEdges.push(edge2);
        }
      }
      return visibleEdges;
    }
    return state2.edges;
  });
  const getElements = computed(() => [...getNodes.value, ...getEdges.value]);
  const getSelectedNodes = computed(() => {
    const selectedNodes = [];
    for (const node2 of state2.nodes) {
      if (node2.selected) {
        selectedNodes.push(node2);
      }
    }
    return selectedNodes;
  });
  const getSelectedEdges = computed(() => {
    const selectedEdges = [];
    for (const edge2 of state2.edges) {
      if (edge2.selected) {
        selectedEdges.push(edge2);
      }
    }
    return selectedEdges;
  });
  const getSelectedElements = computed(() => [
    ...getSelectedNodes.value,
    ...getSelectedEdges.value
  ]);
  const getNodesInitialized = computed(() => {
    const initializedNodes = [];
    for (const node2 of state2.nodes) {
      if (!!node2.dimensions.width && !!node2.dimensions.height && node2.handleBounds !== void 0) {
        initializedNodes.push(node2);
      }
    }
    return initializedNodes;
  });
  const areNodesInitialized = computed(
    () => getNodes.value.length > 0 && getNodesInitialized.value.length === getNodes.value.length
  );
  return {
    getNode,
    getEdge,
    getElements,
    getEdgeTypes,
    getNodeTypes,
    getEdges,
    getNodes,
    getSelectedElements,
    getSelectedNodes,
    getSelectedEdges,
    getNodesInitialized,
    areNodesInitialized
  };
}
class Storage {
  constructor() {
    this.currentId = 0;
    this.flows = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    var _a;
    const vueApp = (_a = getCurrentInstance()) == null ? void 0 : _a.appContext.app;
    const existingInstance = (vueApp == null ? void 0 : vueApp.config.globalProperties.$vueFlowStorage) ?? Storage.instance;
    Storage.instance = existingInstance ?? new Storage();
    if (vueApp) {
      vueApp.config.globalProperties.$vueFlowStorage = Storage.instance;
    }
    return Storage.instance;
  }
  set(id2, flow) {
    return this.flows.set(id2, flow);
  }
  get(id2) {
    return this.flows.get(id2);
  }
  remove(id2) {
    return this.flows.delete(id2);
  }
  create(id2, preloadedState) {
    const state2 = useState();
    const reactiveState = reactive(state2);
    const hooksOn = {};
    for (const [n, h2] of Object.entries(reactiveState.hooks)) {
      const name = `on${n.charAt(0).toUpperCase() + n.slice(1)}`;
      hooksOn[name] = h2.on;
    }
    const emits = {};
    for (const [n, h2] of Object.entries(reactiveState.hooks)) {
      emits[n] = h2.trigger;
    }
    const nodeLookup = computed(() => {
      const nodesMap = /* @__PURE__ */ new Map();
      for (const node2 of reactiveState.nodes) {
        nodesMap.set(node2.id, node2);
      }
      return nodesMap;
    });
    const edgeLookup = computed(() => {
      const edgesMap = /* @__PURE__ */ new Map();
      for (const edge2 of reactiveState.edges) {
        edgesMap.set(edge2.id, edge2);
      }
      return edgesMap;
    });
    const getters = useGetters(reactiveState, nodeLookup, edgeLookup);
    const actions2 = useActions(reactiveState, nodeLookup, edgeLookup);
    actions2.setState({ ...reactiveState, ...preloadedState });
    const flow = {
      ...hooksOn,
      ...getters,
      ...actions2,
      ...toRefs(reactiveState),
      nodeLookup,
      edgeLookup,
      emits,
      id: id2,
      vueFlowVersion: "1.41.2",
      $destroy: () => {
        this.remove(id2);
      }
    };
    this.set(id2, flow);
    return flow;
  }
  getId() {
    return `vue-flow-${this.currentId++}`;
  }
}
function useVueFlow(idOrOpts) {
  const storage = Storage.getInstance();
  const scope = getCurrentScope();
  const isOptsObj = typeof idOrOpts === "object";
  const options = isOptsObj ? idOrOpts : { id: idOrOpts };
  const id2 = options.id;
  const vueFlowId = id2 ?? (scope == null ? void 0 : scope.vueFlowId);
  let vueFlow;
  if (scope) {
    const injectedState = inject(VueFlow, null);
    if (typeof injectedState !== "undefined" && injectedState !== null && (!vueFlowId || injectedState.id === vueFlowId)) {
      vueFlow = injectedState;
    }
  }
  if (!vueFlow) {
    if (vueFlowId) {
      vueFlow = storage.get(vueFlowId);
    }
  }
  if (!vueFlow || vueFlowId && vueFlow.id !== vueFlowId) {
    const name = id2 ?? storage.getId();
    const state2 = storage.create(name, options);
    vueFlow = state2;
    const vfScope = scope ?? effectScope(true);
    vfScope.run(() => {
      watch(
        state2.applyDefault,
        (shouldApplyDefault, __, onCleanup) => {
          const nodesChangeHandler = (changes) => {
            state2.applyNodeChanges(changes);
          };
          const edgesChangeHandler = (changes) => {
            state2.applyEdgeChanges(changes);
          };
          if (shouldApplyDefault) {
            state2.onNodesChange(nodesChangeHandler);
            state2.onEdgesChange(edgesChangeHandler);
          } else {
            state2.hooks.value.nodesChange.off(nodesChangeHandler);
            state2.hooks.value.edgesChange.off(edgesChangeHandler);
          }
          onCleanup(() => {
            state2.hooks.value.nodesChange.off(nodesChangeHandler);
            state2.hooks.value.edgesChange.off(edgesChangeHandler);
          });
        },
        { immediate: true }
      );
      tryOnScopeDispose(() => {
        if (vueFlow) {
          const storedInstance = storage.get(vueFlow.id);
          if (storedInstance) {
            storedInstance.$destroy();
          } else {
            warn(`No store instance found for id ${vueFlow.id} in storage.`);
          }
        }
      });
    });
  } else {
    if (isOptsObj) {
      vueFlow.setState(options);
    }
  }
  if (scope) {
    provide(VueFlow, vueFlow);
    scope.vueFlowId = vueFlow.id;
  }
  if (isOptsObj) {
    const instance = getCurrentInstance();
    if ((instance == null ? void 0 : instance.type.name) !== "VueFlow") {
      vueFlow.emits.error(new VueFlowError(ErrorCode.USEVUEFLOW_OPTIONS));
    }
  }
  return vueFlow;
}
function useResizeHandler(viewportEl) {
  const { emits, dimensions } = useVueFlow();
  let resizeObserver;
  onMounted(() => {
    const rendererNode = viewportEl.value;
    const updateDimensions = () => {
      if (!rendererNode) {
        return;
      }
      const size = getDimensions(rendererNode);
      if (size.width === 0 || size.height === 0) {
        emits.error(new VueFlowError(ErrorCode.MISSING_VIEWPORT_DIMENSIONS));
      }
      dimensions.value = { width: size.width || 500, height: size.height || 500 };
    };
    updateDimensions();
    window.addEventListener("resize", updateDimensions);
    if (rendererNode) {
      resizeObserver = new ResizeObserver(() => updateDimensions());
      resizeObserver.observe(rendererNode);
    }
    onBeforeUnmount(() => {
      window.removeEventListener("resize", updateDimensions);
      if (resizeObserver && rendererNode) {
        resizeObserver.unobserve(rendererNode);
      }
    });
  });
}
const __default__$c = {
  name: "UserSelection",
  compatConfig: { MODE: 3 }
};
const _sfc_main$c$1 = /* @__PURE__ */ defineComponent({
  ...__default__$c,
  props: {
    userSelectionRect: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "vue-flow__selection vue-flow__container",
        style: normalizeStyle({
          width: `${_ctx.userSelectionRect.width}px`,
          height: `${_ctx.userSelectionRect.height}px`,
          transform: `translate(${_ctx.userSelectionRect.x}px, ${_ctx.userSelectionRect.y}px)`
        })
      }, null, 4);
    };
  }
});
const _hoisted_1$6$1 = ["tabIndex"];
const __default__$b = {
  name: "NodesSelection",
  compatConfig: { MODE: 3 }
};
const _sfc_main$b$1 = /* @__PURE__ */ defineComponent({
  ...__default__$b,
  setup(__props) {
    const { emits, viewport, getSelectedNodes, noPanClassName, disableKeyboardA11y, userSelectionActive } = useVueFlow();
    const updatePositions = useUpdateNodePositions();
    const el = ref(null);
    const dragging2 = useDrag({
      el,
      onStart(args) {
        emits.selectionDragStart(args);
      },
      onDrag(args) {
        emits.selectionDrag(args);
      },
      onStop(args) {
        emits.selectionDragStop(args);
      }
    });
    onMounted(() => {
      var _a;
      if (!disableKeyboardA11y.value) {
        (_a = el.value) == null ? void 0 : _a.focus({ preventScroll: true });
      }
    });
    const selectedNodesBBox = computed(() => getRectOfNodes(getSelectedNodes.value));
    const innerStyle = computed(() => ({
      width: `${selectedNodesBBox.value.width}px`,
      height: `${selectedNodesBBox.value.height}px`,
      top: `${selectedNodesBBox.value.y}px`,
      left: `${selectedNodesBBox.value.x}px`
    }));
    function onContextMenu(event) {
      emits.selectionContextMenu({ event, nodes: getSelectedNodes.value });
    }
    function onKeyDown2(event) {
      if (disableKeyboardA11y) {
        return;
      }
      if (arrowKeyDiffs[event.key]) {
        updatePositions(
          {
            x: arrowKeyDiffs[event.key].x,
            y: arrowKeyDiffs[event.key].y
          },
          event.shiftKey
        );
      }
    }
    return (_ctx, _cache) => {
      return !unref(userSelectionActive) && selectedNodesBBox.value.width && selectedNodesBBox.value.height ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["vue-flow__nodesselection vue-flow__container", unref(noPanClassName)]),
        style: normalizeStyle({ transform: `translate(${unref(viewport).x}px,${unref(viewport).y}px) scale(${unref(viewport).zoom})` })
      }, [
        createBaseVNode("div", {
          ref_key: "el",
          ref: el,
          class: normalizeClass([{ dragging: unref(dragging2) }, "vue-flow__nodesselection-rect"]),
          style: normalizeStyle(innerStyle.value),
          tabIndex: unref(disableKeyboardA11y) ? void 0 : -1,
          onContextmenu: onContextMenu,
          onKeydown: onKeyDown2
        }, null, 46, _hoisted_1$6$1)
      ], 6)) : createCommentVNode("", true);
    };
  }
});
function getMousePosition(event, containerBounds) {
  return {
    x: event.clientX - containerBounds.left,
    y: event.clientY - containerBounds.top
  };
}
const __default__$a = {
  name: "Pane",
  compatConfig: { MODE: 3 }
};
const _sfc_main$a$1 = /* @__PURE__ */ defineComponent({
  ...__default__$a,
  props: {
    isSelecting: { type: Boolean },
    selectionKeyPressed: { type: Boolean }
  },
  setup(__props) {
    const {
      vueFlowRef,
      nodes,
      viewport,
      emits,
      userSelectionActive,
      removeSelectedElements,
      panOnDrag,
      userSelectionRect,
      elementsSelectable,
      nodesSelectionActive,
      getSelectedEdges,
      getSelectedNodes,
      removeNodes,
      removeEdges,
      selectionMode,
      deleteKeyCode,
      multiSelectionKeyCode,
      multiSelectionActive,
      edgeLookup,
      nodeLookup
    } = useVueFlow();
    const container2 = ref(null);
    const prevSelectedNodesCount = ref(0);
    const prevSelectedEdgesCount = ref(0);
    const containerBounds = ref();
    const edgeIdLookup = ref(/* @__PURE__ */ new Map());
    const hasActiveSelection = toRef(() => elementsSelectable.value && (__props.isSelecting || userSelectionActive.value));
    let selectionInProgress = false;
    let selectionStarted = false;
    const deleteKeyPressed = useKeyPress(deleteKeyCode, { actInsideInputWithModifier: false });
    const multiSelectKeyPressed = useKeyPress(multiSelectionKeyCode);
    watch(deleteKeyPressed, (isKeyPressed) => {
      if (!isKeyPressed) {
        return;
      }
      removeNodes(getSelectedNodes.value);
      removeEdges(getSelectedEdges.value);
      nodesSelectionActive.value = false;
    });
    watch(multiSelectKeyPressed, (isKeyPressed) => {
      multiSelectionActive.value = isKeyPressed;
    });
    function wrapHandler(handler, containerRef) {
      return (event) => {
        if (event.target !== containerRef) {
          return;
        }
        handler == null ? void 0 : handler(event);
      };
    }
    function resetUserSelection() {
      userSelectionActive.value = false;
      userSelectionRect.value = null;
      prevSelectedNodesCount.value = 0;
      prevSelectedEdgesCount.value = 0;
    }
    function onClick(event) {
      if (selectionInProgress) {
        selectionInProgress = false;
        return;
      }
      emits.paneClick(event);
      removeSelectedElements();
      nodesSelectionActive.value = false;
    }
    function onContextMenu(event) {
      var _a;
      if (Array.isArray(panOnDrag.value) && ((_a = panOnDrag.value) == null ? void 0 : _a.includes(2))) {
        event.preventDefault();
        return;
      }
      emits.paneContextMenu(event);
    }
    function onWheel(event) {
      emits.paneScroll(event);
    }
    function onPointerDown(event) {
      var _a, _b, _c, _d, _e;
      containerBounds.value = (_a = vueFlowRef.value) == null ? void 0 : _a.getBoundingClientRect();
      if (!elementsSelectable.value || !__props.isSelecting || event.button !== 0 || event.target !== container2.value || !containerBounds.value) {
        return;
      }
      (_c = (_b = event.target) == null ? void 0 : _b.setPointerCapture) == null ? void 0 : _c.call(_b, event.pointerId);
      const { x, y } = getMousePosition(event, containerBounds.value);
      selectionStarted = true;
      selectionInProgress = false;
      edgeIdLookup.value = /* @__PURE__ */ new Map();
      for (const [id2, edge2] of edgeLookup.value) {
        edgeIdLookup.value.set(edge2.source, ((_d = edgeIdLookup.value.get(edge2.source)) == null ? void 0 : _d.add(id2)) || /* @__PURE__ */ new Set([id2]));
        edgeIdLookup.value.set(edge2.target, ((_e = edgeIdLookup.value.get(edge2.target)) == null ? void 0 : _e.add(id2)) || /* @__PURE__ */ new Set([id2]));
      }
      removeSelectedElements();
      userSelectionRect.value = {
        width: 0,
        height: 0,
        startX: x,
        startY: y,
        x,
        y
      };
      emits.selectionStart(event);
    }
    function onPointerMove(event) {
      if (!containerBounds.value || !userSelectionRect.value) {
        return;
      }
      selectionInProgress = true;
      const { x: mouseX, y: mouseY } = getEventPosition(event, containerBounds.value);
      const { startX = 0, startY = 0 } = userSelectionRect.value;
      const nextUserSelectRect = {
        startX,
        startY,
        x: mouseX < startX ? mouseX : startX,
        y: mouseY < startY ? mouseY : startY,
        width: Math.abs(mouseX - startX),
        height: Math.abs(mouseY - startY)
      };
      const selectedNodes = getNodesInside(
        nodes.value,
        nextUserSelectRect,
        viewport.value,
        selectionMode.value === SelectionMode.Partial,
        true
      );
      const selectedEdgeIds = /* @__PURE__ */ new Set();
      const selectedNodeIds = /* @__PURE__ */ new Set();
      for (const selectedNode of selectedNodes) {
        selectedNodeIds.add(selectedNode.id);
        const edgeIds = edgeIdLookup.value.get(selectedNode.id);
        if (edgeIds) {
          for (const edgeId of edgeIds) {
            selectedEdgeIds.add(edgeId);
          }
        }
      }
      if (prevSelectedNodesCount.value !== selectedNodeIds.size) {
        prevSelectedNodesCount.value = selectedNodeIds.size;
        const changes = getSelectionChanges(nodeLookup.value, selectedNodeIds, true);
        emits.nodesChange(changes);
      }
      if (prevSelectedEdgesCount.value !== selectedEdgeIds.size) {
        prevSelectedEdgesCount.value = selectedEdgeIds.size;
        const changes = getSelectionChanges(edgeLookup.value, selectedEdgeIds);
        emits.edgesChange(changes);
      }
      userSelectionRect.value = nextUserSelectRect;
      userSelectionActive.value = true;
      nodesSelectionActive.value = false;
    }
    function onPointerUp(event) {
      var _a;
      if (event.button !== 0 || !selectionStarted) {
        return;
      }
      (_a = event.target) == null ? void 0 : _a.releasePointerCapture(event.pointerId);
      if (!userSelectionActive.value && userSelectionRect.value && event.target === container2.value) {
        onClick(event);
      }
      if (prevSelectedNodesCount.value > 0) {
        nodesSelectionActive.value = true;
      }
      resetUserSelection();
      emits.selectionEnd(event);
      if (__props.selectionKeyPressed) {
        selectionInProgress = false;
      }
      selectionStarted = false;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "container",
        ref: container2,
        class: normalizeClass(["vue-flow__pane vue-flow__container", { selection: _ctx.isSelecting }]),
        onClick: _cache[0] || (_cache[0] = (event) => hasActiveSelection.value ? void 0 : wrapHandler(onClick, container2.value)(event)),
        onContextmenu: _cache[1] || (_cache[1] = ($event) => wrapHandler(onContextMenu, container2.value)($event)),
        onWheelPassive: _cache[2] || (_cache[2] = ($event) => wrapHandler(onWheel, container2.value)($event)),
        onPointerenter: _cache[3] || (_cache[3] = (event) => hasActiveSelection.value ? void 0 : unref(emits).paneMouseEnter(event)),
        onPointerdown: _cache[4] || (_cache[4] = (event) => hasActiveSelection.value ? onPointerDown(event) : unref(emits).paneMouseMove(event)),
        onPointermove: _cache[5] || (_cache[5] = (event) => hasActiveSelection.value ? onPointerMove(event) : unref(emits).paneMouseMove(event)),
        onPointerup: _cache[6] || (_cache[6] = (event) => hasActiveSelection.value ? onPointerUp(event) : void 0),
        onPointerleave: _cache[7] || (_cache[7] = ($event) => unref(emits).paneMouseLeave($event))
      }, [
        renderSlot(_ctx.$slots, "default"),
        unref(userSelectionActive) && unref(userSelectionRect) ? (openBlock(), createBlock(_sfc_main$c$1, {
          key: 0,
          "user-selection-rect": unref(userSelectionRect)
        }, null, 8, ["user-selection-rect"])) : createCommentVNode("", true),
        unref(nodesSelectionActive) && unref(getSelectedNodes).length ? (openBlock(), createBlock(_sfc_main$b$1, { key: 1 })) : createCommentVNode("", true)
      ], 34);
    };
  }
});
const __default__$9 = {
  name: "Transform",
  compatConfig: { MODE: 3 }
};
const _sfc_main$9$1 = /* @__PURE__ */ defineComponent({
  ...__default__$9,
  setup(__props) {
    const { viewport, fitViewOnInit, fitViewOnInitDone } = useVueFlow();
    const isHidden = computed(() => {
      if (fitViewOnInit.value) {
        return !fitViewOnInitDone.value;
      }
      return false;
    });
    const transform = computed(() => `translate(${viewport.value.x}px,${viewport.value.y}px) scale(${viewport.value.zoom})`);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "vue-flow__transformationpane vue-flow__container",
        style: normalizeStyle({ transform: transform.value, opacity: isHidden.value ? 0 : void 0 })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
const __default__$8 = {
  name: "Viewport",
  compatConfig: { MODE: 3 }
};
const _sfc_main$8$1 = /* @__PURE__ */ defineComponent({
  ...__default__$8,
  setup(__props) {
    const {
      minZoom,
      maxZoom,
      defaultViewport,
      translateExtent,
      zoomActivationKeyCode,
      selectionKeyCode,
      panActivationKeyCode,
      panOnScroll,
      panOnScrollMode,
      panOnScrollSpeed,
      panOnDrag,
      zoomOnDoubleClick,
      zoomOnPinch,
      zoomOnScroll,
      preventScrolling,
      noWheelClassName,
      noPanClassName,
      emits,
      connectionStartHandle,
      userSelectionActive,
      paneDragging,
      d3Zoom: storeD3Zoom,
      d3Selection: storeD3Selection,
      d3ZoomHandler: storeD3ZoomHandler,
      viewport,
      viewportRef,
      paneClickDistance
    } = useVueFlow();
    useResizeHandler(viewportRef);
    const isZoomingOrPanning = ref(false);
    const isPanScrolling = ref(false);
    let panScrollTimeout = null;
    let zoomedWithRightMouseButton = false;
    let mouseButton = 0;
    let prevTransform = {
      x: 0,
      y: 0,
      zoom: 0
    };
    const panKeyPressed = useKeyPress(panActivationKeyCode);
    const selectionKeyPressed = useKeyPress(selectionKeyCode);
    const zoomKeyPressed = useKeyPress(zoomActivationKeyCode);
    const shouldPanOnDrag = toRef(() => !selectionKeyPressed.value && (panKeyPressed.value || panOnDrag.value));
    const shouldPanOnScroll = toRef(() => panKeyPressed.value || panOnScroll.value);
    const isSelecting = toRef(() => selectionKeyPressed.value || selectionKeyCode.value === true && shouldPanOnDrag.value !== true);
    onMounted(() => {
      if (!viewportRef.value) {
        warn("Viewport element is missing");
        return;
      }
      const viewportElement = viewportRef.value;
      const bbox = viewportElement.getBoundingClientRect();
      const d3Zoom = zoom$1().clickDistance(paneClickDistance.value).scaleExtent([minZoom.value, maxZoom.value]).translateExtent(translateExtent.value);
      const d3Selection = select$2(viewportElement).call(d3Zoom);
      const d3ZoomHandler = d3Selection.on("wheel.zoom");
      const updatedTransform = identity$2.translate(defaultViewport.value.x ?? 0, defaultViewport.value.y ?? 0).scale(clamp(defaultViewport.value.zoom ?? 1, minZoom.value, maxZoom.value));
      const extent = [
        [0, 0],
        [bbox.width, bbox.height]
      ];
      const constrainedTransform = d3Zoom.constrain()(updatedTransform, extent, translateExtent.value);
      d3Zoom.transform(d3Selection, constrainedTransform);
      d3Zoom.wheelDelta(wheelDelta);
      storeD3Zoom.value = d3Zoom;
      storeD3Selection.value = d3Selection;
      storeD3ZoomHandler.value = d3ZoomHandler;
      viewport.value = { x: constrainedTransform.x, y: constrainedTransform.y, zoom: constrainedTransform.k };
      d3Zoom.on("start", (event) => {
        var _a;
        if (!event.sourceEvent) {
          return null;
        }
        mouseButton = event.sourceEvent.button;
        isZoomingOrPanning.value = true;
        const flowTransform = eventToFlowTransform(event.transform);
        if (((_a = event.sourceEvent) == null ? void 0 : _a.type) === "mousedown") {
          paneDragging.value = true;
        }
        prevTransform = flowTransform;
        emits.viewportChangeStart(flowTransform);
        emits.moveStart({ event, flowTransform });
      });
      d3Zoom.on("end", (event) => {
        if (!event.sourceEvent) {
          return null;
        }
        isZoomingOrPanning.value = false;
        paneDragging.value = false;
        if (isRightClickPan(shouldPanOnDrag.value, mouseButton ?? 0) && !zoomedWithRightMouseButton) {
          emits.paneContextMenu(event.sourceEvent);
        }
        zoomedWithRightMouseButton = false;
        if (viewChanged(prevTransform, event.transform)) {
          const flowTransform = eventToFlowTransform(event.transform);
          prevTransform = flowTransform;
          emits.viewportChangeEnd(flowTransform);
          emits.moveEnd({ event, flowTransform });
        }
      });
      d3Zoom.filter((event) => {
        var _a, _b, _c;
        const zoomScroll = zoomKeyPressed.value || zoomOnScroll.value;
        const pinchZoom = zoomOnPinch.value && event.ctrlKey;
        const eventButton = event.button;
        if ((shouldPanOnDrag.value === true || Array.isArray(shouldPanOnDrag.value) && shouldPanOnDrag.value.includes(1)) && eventButton === 1 && event.type === "mousedown" && (((_a = event.target) == null ? void 0 : _a.closest(".vue-flow__node")) || ((_b = event.target) == null ? void 0 : _b.closest(".vue-flow__edge")))) {
          return true;
        }
        if (!shouldPanOnDrag.value && !zoomScroll && !shouldPanOnScroll.value && !zoomOnDoubleClick.value && !zoomOnPinch.value) {
          return false;
        }
        if (userSelectionActive.value) {
          return false;
        }
        if (!zoomOnDoubleClick.value && event.type === "dblclick") {
          return false;
        }
        if (isWrappedWithClass(event, noWheelClassName.value) && event.type === "wheel") {
          return false;
        }
        if (isWrappedWithClass(event, noPanClassName.value) && (event.type !== "wheel" || shouldPanOnScroll.value && event.type === "wheel" && !zoomKeyPressed.value)) {
          return false;
        }
        if (!zoomOnPinch.value && event.ctrlKey && event.type === "wheel") {
          return false;
        }
        if (!zoomScroll && !shouldPanOnScroll.value && !pinchZoom && event.type === "wheel") {
          return false;
        }
        if (!zoomOnPinch && event.type === "touchstart" && ((_c = event.touches) == null ? void 0 : _c.length) > 1) {
          event.preventDefault();
          return false;
        }
        if (!shouldPanOnDrag.value && (event.type === "mousedown" || event.type === "touchstart")) {
          return false;
        }
        if (Array.isArray(shouldPanOnDrag.value) && !shouldPanOnDrag.value.includes(eventButton) && (event.type === "mousedown" || event.type === "touchstart")) {
          return false;
        }
        const buttonAllowed = Array.isArray(shouldPanOnDrag.value) && shouldPanOnDrag.value.includes(eventButton) || !eventButton || eventButton <= 1;
        return (!event.ctrlKey || event.type === "wheel") && buttonAllowed;
      });
      watch(
        [userSelectionActive, shouldPanOnDrag],
        () => {
          if (userSelectionActive.value && !isZoomingOrPanning.value) {
            d3Zoom.on("zoom", null);
          } else if (!userSelectionActive.value) {
            d3Zoom.on("zoom", (event) => {
              viewport.value = { x: event.transform.x, y: event.transform.y, zoom: event.transform.k };
              const flowTransform = eventToFlowTransform(event.transform);
              zoomedWithRightMouseButton = isRightClickPan(shouldPanOnDrag.value, mouseButton ?? 0);
              emits.viewportChange(flowTransform);
              emits.move({ event, flowTransform });
            });
          }
        },
        { immediate: true }
      );
      watch(
        [userSelectionActive, shouldPanOnScroll, panOnScrollMode, zoomKeyPressed, zoomOnPinch, preventScrolling, noWheelClassName],
        () => {
          if (shouldPanOnScroll.value && !zoomKeyPressed.value && !userSelectionActive.value) {
            d3Selection.on(
              "wheel.zoom",
              (event) => {
                if (isWrappedWithClass(event, noWheelClassName.value)) {
                  return false;
                }
                const zoomScroll = zoomKeyPressed.value || zoomOnScroll.value;
                const pinchZoom = zoomOnPinch.value && event.ctrlKey;
                const scrollEventEnabled = !preventScrolling.value || shouldPanOnScroll.value || zoomScroll || pinchZoom;
                if (!scrollEventEnabled) {
                  return false;
                }
                event.preventDefault();
                event.stopImmediatePropagation();
                const currentZoom = d3Selection.property("__zoom").k || 1;
                const _isMacOs = isMacOs();
                if (event.ctrlKey && zoomOnPinch.value && _isMacOs) {
                  const point = pointer$2(event);
                  const pinchDelta = wheelDelta(event);
                  const zoom2 = currentZoom * 2 ** pinchDelta;
                  d3Zoom.scaleTo(d3Selection, zoom2, point, event);
                  return;
                }
                const deltaNormalize = event.deltaMode === 1 ? 20 : 1;
                let deltaX = panOnScrollMode.value === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;
                let deltaY = panOnScrollMode.value === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;
                if (!_isMacOs && event.shiftKey && panOnScrollMode.value !== PanOnScrollMode.Vertical && !deltaX && deltaY) {
                  deltaX = deltaY;
                  deltaY = 0;
                }
                d3Zoom.translateBy(
                  d3Selection,
                  -(deltaX / currentZoom) * panOnScrollSpeed.value,
                  -(deltaY / currentZoom) * panOnScrollSpeed.value
                );
                const nextViewport = eventToFlowTransform(d3Selection.property("__zoom"));
                if (panScrollTimeout) {
                  clearTimeout(panScrollTimeout);
                }
                if (!isPanScrolling.value) {
                  isPanScrolling.value = true;
                  emits.moveStart({ event, flowTransform: nextViewport });
                  emits.viewportChangeStart(nextViewport);
                } else {
                  emits.move({ event, flowTransform: nextViewport });
                  emits.viewportChange(nextViewport);
                  panScrollTimeout = setTimeout(() => {
                    emits.moveEnd({ event, flowTransform: nextViewport });
                    emits.viewportChangeEnd(nextViewport);
                    isPanScrolling.value = false;
                  }, 150);
                }
              },
              { passive: false }
            );
          } else if (typeof d3ZoomHandler !== "undefined") {
            d3Selection.on(
              "wheel.zoom",
              function(event, d) {
                const invalidEvent = !preventScrolling.value && event.type === "wheel" && !event.ctrlKey;
                const zoomScroll = zoomKeyPressed.value || zoomOnScroll.value;
                const pinchZoom = zoomOnPinch.value && event.ctrlKey;
                const scrollEventsDisabled = !zoomScroll && !panOnScroll.value && !pinchZoom && event.type === "wheel";
                if (scrollEventsDisabled || invalidEvent || isWrappedWithClass(event, noWheelClassName.value)) {
                  return null;
                }
                event.preventDefault();
                d3ZoomHandler.call(this, event, d);
              },
              { passive: false }
            );
          }
        },
        { immediate: true }
      );
    });
    function isRightClickPan(pan, usedButton) {
      return usedButton === 2 && Array.isArray(pan) && pan.includes(2);
    }
    function wheelDelta(event) {
      const factor = event.ctrlKey && isMacOs() ? 10 : 1;
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * factor;
    }
    function viewChanged(prevViewport, eventTransform) {
      return prevViewport.x !== eventTransform.x && !Number.isNaN(eventTransform.x) || prevViewport.y !== eventTransform.y && !Number.isNaN(eventTransform.y) || prevViewport.zoom !== eventTransform.k && !Number.isNaN(eventTransform.k);
    }
    function eventToFlowTransform(eventTransform) {
      return {
        x: eventTransform.x,
        y: eventTransform.y,
        zoom: eventTransform.k
      };
    }
    function isWrappedWithClass(event, className) {
      return event.target.closest(`.${className}`);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "viewportRef",
        ref: viewportRef,
        class: "vue-flow__viewport vue-flow__container"
      }, [
        createVNode(_sfc_main$a$1, {
          "is-selecting": isSelecting.value,
          "selection-key-pressed": unref(selectionKeyPressed),
          class: normalizeClass({
            connecting: !!unref(connectionStartHandle),
            dragging: unref(paneDragging),
            draggable: unref(panOnDrag) === true || Array.isArray(unref(panOnDrag)) && unref(panOnDrag).includes(0)
          })
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$9$1, null, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["is-selecting", "selection-key-pressed", "class"])
      ], 512);
    };
  }
});
const _hoisted_1$5$2 = ["id"];
const _hoisted_2$6 = ["id"];
const _hoisted_3$6 = ["id"];
const __default__$7 = {
  name: "A11yDescriptions",
  compatConfig: { MODE: 3 }
};
const _sfc_main$7$1 = /* @__PURE__ */ defineComponent({
  ...__default__$7,
  setup(__props) {
    const { id: id2, disableKeyboardA11y, ariaLiveMessage } = useVueFlow();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("div", {
          id: `${unref(ARIA_NODE_DESC_KEY)}-${unref(id2)}`,
          style: { "display": "none" }
        }, " Press enter or space to select a node. " + toDisplayString(!unref(disableKeyboardA11y) ? "You can then use the arrow keys to move the node around." : "") + " You can then use the arrow keys to move the node around, press delete to remove it and press escape to cancel. ", 9, _hoisted_1$5$2),
        createBaseVNode("div", {
          id: `${unref(ARIA_EDGE_DESC_KEY)}-${unref(id2)}`,
          style: { "display": "none" }
        }, " Press enter or space to select an edge. You can then press delete to remove it or press escape to cancel. ", 8, _hoisted_2$6),
        !unref(disableKeyboardA11y) ? (openBlock(), createElementBlock("div", {
          key: 0,
          id: `${unref(ARIA_LIVE_MESSAGE)}-${unref(id2)}`,
          "aria-live": "assertive",
          "aria-atomic": "true",
          style: { "position": "absolute", "width": "1px", "height": "1px", "margin": "-1px", "border": "0", "padding": "0", "overflow": "hidden", "clip": "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(100%)" }
        }, toDisplayString(unref(ariaLiveMessage)), 9, _hoisted_3$6)) : createCommentVNode("", true)
      ], 64);
    };
  }
});
function useOnInitHandler() {
  const vfInstance = useVueFlow();
  watch(
    () => vfInstance.viewportHelper.value.viewportInitialized,
    (isInitialized) => {
      if (isInitialized) {
        setTimeout(() => {
          vfInstance.emits.init(vfInstance);
          vfInstance.emits.paneReady(vfInstance);
        }, 1);
      }
    }
  );
}
function shiftX(x, shift, position2) {
  if (position2 === Position.Left) {
    return x - shift;
  }
  if (position2 === Position.Right) {
    return x + shift;
  }
  return x;
}
function shiftY(y, shift, position2) {
  if (position2 === Position.Top) {
    return y - shift;
  }
  if (position2 === Position.Bottom) {
    return y + shift;
  }
  return y;
}
const EdgeAnchor = function({
  radius = 10,
  centerX = 0,
  centerY = 0,
  position: position2 = Position.Top,
  type
}) {
  return h("circle", {
    class: `vue-flow__edgeupdater vue-flow__edgeupdater-${type}`,
    cx: shiftX(centerX, radius, position2),
    cy: shiftY(centerY, radius, position2),
    r: radius,
    stroke: "transparent",
    fill: "transparent"
  });
};
EdgeAnchor.props = ["radius", "centerX", "centerY", "position", "type"];
EdgeAnchor.compatConfig = { MODE: 3 };
const EdgeAnchor$1 = EdgeAnchor;
const EdgeWrapper = defineComponent({
  name: "Edge",
  compatConfig: { MODE: 3 },
  props: ["id"],
  setup(props) {
    const {
      id: vueFlowId,
      addSelectedEdges,
      connectionMode,
      edgeUpdaterRadius,
      emits,
      nodesSelectionActive,
      noPanClassName,
      getEdgeTypes,
      removeSelectedEdges,
      findEdge,
      findNode,
      isValidConnection,
      multiSelectionActive,
      disableKeyboardA11y,
      elementsSelectable,
      edgesUpdatable,
      edgesFocusable,
      hooks
    } = useVueFlow();
    const edge2 = computed(() => findEdge(props.id));
    const { emit, on } = useEdgeHooks(edge2.value, emits);
    const slots = inject(Slots$1);
    const instance = getCurrentInstance();
    const mouseOver = ref(false);
    const updating = ref(false);
    const nodeId = ref("");
    const handleId = ref(null);
    const edgeUpdaterType = ref("source");
    const edgeEl = ref(null);
    const isSelectable = toRef(
      () => typeof edge2.value.selectable === "undefined" ? elementsSelectable.value : edge2.value.selectable
    );
    const isUpdatable = toRef(() => typeof edge2.value.updatable === "undefined" ? edgesUpdatable.value : edge2.value.updatable);
    const isFocusable = toRef(() => typeof edge2.value.focusable === "undefined" ? edgesFocusable.value : edge2.value.focusable);
    provide(EdgeId, props.id);
    provide(EdgeRef, edgeEl);
    const edgeClass = computed(() => edge2.value.class instanceof Function ? edge2.value.class(edge2.value) : edge2.value.class);
    const edgeStyle = computed(() => edge2.value.style instanceof Function ? edge2.value.style(edge2.value) : edge2.value.style);
    const edgeCmp = computed(() => {
      const name = edge2.value.type || "default";
      const slot = slots == null ? void 0 : slots[`edge-${name}`];
      if (slot) {
        return slot;
      }
      let edgeType = edge2.value.template ?? getEdgeTypes.value[name];
      if (typeof edgeType === "string") {
        if (instance) {
          const components = Object.keys(instance.appContext.components);
          if (components && components.includes(name)) {
            edgeType = resolveComponent(name, false);
          }
        }
      }
      if (edgeType && typeof edgeType !== "string") {
        return edgeType;
      }
      emits.error(new VueFlowError(ErrorCode.EDGE_TYPE_MISSING, edgeType));
      return false;
    });
    const { handlePointerDown } = useHandle({
      nodeId,
      handleId,
      type: edgeUpdaterType,
      isValidConnection,
      edgeUpdaterType,
      onEdgeUpdate,
      onEdgeUpdateEnd
    });
    return () => {
      const sourceNode = findNode(edge2.value.source);
      const targetNode = findNode(edge2.value.target);
      const pathOptions = "pathOptions" in edge2.value ? edge2.value.pathOptions : {};
      if (!sourceNode && !targetNode) {
        emits.error(new VueFlowError(ErrorCode.EDGE_SOURCE_TARGET_MISSING, edge2.value.id, edge2.value.source, edge2.value.target));
        return null;
      }
      if (!sourceNode) {
        emits.error(new VueFlowError(ErrorCode.EDGE_SOURCE_MISSING, edge2.value.id, edge2.value.source));
        return null;
      }
      if (!targetNode) {
        emits.error(new VueFlowError(ErrorCode.EDGE_TARGET_MISSING, edge2.value.id, edge2.value.target));
        return null;
      }
      if (!edge2.value || edge2.value.hidden || sourceNode.hidden || targetNode.hidden) {
        return null;
      }
      let sourceNodeHandles;
      if (connectionMode.value === ConnectionMode.Strict) {
        sourceNodeHandles = sourceNode.handleBounds.source;
      } else {
        sourceNodeHandles = [...sourceNode.handleBounds.source || [], ...sourceNode.handleBounds.target || []];
      }
      const sourceHandle = getHandle(sourceNodeHandles, edge2.value.sourceHandle);
      let targetNodeHandles;
      if (connectionMode.value === ConnectionMode.Strict) {
        targetNodeHandles = targetNode.handleBounds.target;
      } else {
        targetNodeHandles = [...targetNode.handleBounds.target || [], ...targetNode.handleBounds.source || []];
      }
      const targetHandle = getHandle(targetNodeHandles, edge2.value.targetHandle);
      const sourcePosition = (sourceHandle == null ? void 0 : sourceHandle.position) || Position.Bottom;
      const targetPosition = (targetHandle == null ? void 0 : targetHandle.position) || Position.Top;
      const { x: sourceX, y: sourceY } = getHandlePosition(sourceNode, sourceHandle, sourcePosition);
      const { x: targetX, y: targetY } = getHandlePosition(targetNode, targetHandle, targetPosition);
      edge2.value.sourceX = sourceX;
      edge2.value.sourceY = sourceY;
      edge2.value.targetX = targetX;
      edge2.value.targetY = targetY;
      return h(
        "g",
        {
          "ref": edgeEl,
          "key": props.id,
          "data-id": props.id,
          "class": [
            "vue-flow__edge",
            `vue-flow__edge-${edgeCmp.value === false ? "default" : edge2.value.type || "default"}`,
            noPanClassName.value,
            edgeClass.value,
            {
              updating: mouseOver.value,
              selected: edge2.value.selected,
              animated: edge2.value.animated,
              inactive: !isSelectable.value && !hooks.value.edgeClick.hasListeners()
            }
          ],
          "onClick": onEdgeClick,
          "onContextmenu": onEdgeContextMenu,
          "onDblclick": onDoubleClick,
          "onMouseenter": onEdgeMouseEnter,
          "onMousemove": onEdgeMouseMove,
          "onMouseleave": onEdgeMouseLeave,
          "onKeyDown": isFocusable.value ? onKeyDown2 : void 0,
          "tabIndex": isFocusable.value ? 0 : void 0,
          "aria-label": edge2.value.ariaLabel === null ? void 0 : edge2.value.ariaLabel || `Edge from ${edge2.value.source} to ${edge2.value.target}`,
          "aria-describedby": isFocusable.value ? `${ARIA_EDGE_DESC_KEY}-${vueFlowId}` : void 0,
          "role": isFocusable.value ? "button" : "img"
        },
        [
          updating.value ? null : h(edgeCmp.value === false ? getEdgeTypes.value.default : edgeCmp.value, {
            id: props.id,
            sourceNode,
            targetNode,
            source: edge2.value.source,
            target: edge2.value.target,
            type: edge2.value.type,
            updatable: isUpdatable.value,
            selected: edge2.value.selected,
            animated: edge2.value.animated,
            label: edge2.value.label,
            labelStyle: edge2.value.labelStyle,
            labelShowBg: edge2.value.labelShowBg,
            labelBgStyle: edge2.value.labelBgStyle,
            labelBgPadding: edge2.value.labelBgPadding,
            labelBgBorderRadius: edge2.value.labelBgBorderRadius,
            data: edge2.value.data,
            events: { ...edge2.value.events, ...on },
            style: edgeStyle.value,
            markerStart: `url('#${getMarkerId(edge2.value.markerStart, vueFlowId)}')`,
            markerEnd: `url('#${getMarkerId(edge2.value.markerEnd, vueFlowId)}')`,
            sourcePosition,
            targetPosition,
            sourceX,
            sourceY,
            targetX,
            targetY,
            sourceHandleId: edge2.value.sourceHandle,
            targetHandleId: edge2.value.targetHandle,
            interactionWidth: edge2.value.interactionWidth,
            ...pathOptions
          }),
          [
            isUpdatable.value === "source" || isUpdatable.value === true ? [
              h(
                "g",
                {
                  onMousedown: onEdgeUpdaterSourceMouseDown,
                  onMouseenter: onEdgeUpdaterMouseEnter,
                  onMouseout: onEdgeUpdaterMouseOut
                },
                h(EdgeAnchor$1, {
                  "position": sourcePosition,
                  "centerX": sourceX,
                  "centerY": sourceY,
                  "radius": edgeUpdaterRadius.value,
                  "type": "source",
                  "data-type": "source"
                })
              )
            ] : null,
            isUpdatable.value === "target" || isUpdatable.value === true ? [
              h(
                "g",
                {
                  onMousedown: onEdgeUpdaterTargetMouseDown,
                  onMouseenter: onEdgeUpdaterMouseEnter,
                  onMouseout: onEdgeUpdaterMouseOut
                },
                h(EdgeAnchor$1, {
                  "position": targetPosition,
                  "centerX": targetX,
                  "centerY": targetY,
                  "radius": edgeUpdaterRadius.value,
                  "type": "target",
                  "data-type": "target"
                })
              )
            ] : null
          ]
        ]
      );
    };
    function onEdgeUpdaterMouseEnter() {
      mouseOver.value = true;
    }
    function onEdgeUpdaterMouseOut() {
      mouseOver.value = false;
    }
    function onEdgeUpdate(event, connection) {
      emit.update({ event, edge: edge2.value, connection });
    }
    function onEdgeUpdateEnd(event) {
      emit.updateEnd({ event, edge: edge2.value });
      updating.value = false;
    }
    function handleEdgeUpdater(event, isSourceHandle) {
      if (event.button !== 0) {
        return;
      }
      updating.value = true;
      nodeId.value = isSourceHandle ? edge2.value.target : edge2.value.source;
      handleId.value = (isSourceHandle ? edge2.value.targetHandle : edge2.value.sourceHandle) ?? "";
      edgeUpdaterType.value = isSourceHandle ? "target" : "source";
      emit.updateStart({ event, edge: edge2.value });
      handlePointerDown(event);
    }
    function onEdgeClick(event) {
      var _a;
      const data = { event, edge: edge2.value };
      if (isSelectable.value) {
        nodesSelectionActive.value = false;
        if (edge2.value.selected && multiSelectionActive.value) {
          removeSelectedEdges([edge2.value]);
          (_a = edgeEl.value) == null ? void 0 : _a.blur();
        } else {
          addSelectedEdges([edge2.value]);
        }
      }
      emit.click(data);
    }
    function onEdgeContextMenu(event) {
      emit.contextMenu({ event, edge: edge2.value });
    }
    function onDoubleClick(event) {
      emit.doubleClick({ event, edge: edge2.value });
    }
    function onEdgeMouseEnter(event) {
      emit.mouseEnter({ event, edge: edge2.value });
    }
    function onEdgeMouseMove(event) {
      emit.mouseMove({ event, edge: edge2.value });
    }
    function onEdgeMouseLeave(event) {
      emit.mouseLeave({ event, edge: edge2.value });
    }
    function onEdgeUpdaterSourceMouseDown(event) {
      handleEdgeUpdater(event, true);
    }
    function onEdgeUpdaterTargetMouseDown(event) {
      handleEdgeUpdater(event, false);
    }
    function onKeyDown2(event) {
      var _a;
      if (!disableKeyboardA11y.value && elementSelectionKeys.includes(event.key) && isSelectable.value) {
        const unselect = event.key === "Escape";
        if (unselect) {
          (_a = edgeEl.value) == null ? void 0 : _a.blur();
          removeSelectedEdges([findEdge(props.id)]);
        } else {
          addSelectedEdges([findEdge(props.id)]);
        }
      }
    }
  }
});
const EdgeWrapper$1 = EdgeWrapper;
const oppositePosition = {
  [Position.Left]: Position.Right,
  [Position.Right]: Position.Left,
  [Position.Top]: Position.Bottom,
  [Position.Bottom]: Position.Top
};
const ConnectionLine = defineComponent({
  name: "ConnectionLine",
  compatConfig: { MODE: 3 },
  setup() {
    var _a;
    const {
      id: id2,
      connectionMode,
      connectionStartHandle,
      connectionEndHandle,
      connectionPosition,
      connectionLineType,
      connectionLineStyle,
      connectionLineOptions,
      connectionStatus,
      viewport,
      findNode
    } = useVueFlow();
    const connectionLineComponent = (_a = inject(Slots$1)) == null ? void 0 : _a["connection-line"];
    const fromNode = computed(() => {
      var _a2;
      return findNode((_a2 = connectionStartHandle.value) == null ? void 0 : _a2.nodeId);
    });
    const toNode = computed(() => {
      var _a2;
      return findNode((_a2 = connectionEndHandle.value) == null ? void 0 : _a2.nodeId) ?? null;
    });
    const toXY = computed(() => {
      return {
        x: (connectionPosition.value.x - viewport.value.x) / viewport.value.zoom,
        y: (connectionPosition.value.y - viewport.value.y) / viewport.value.zoom
      };
    });
    const markerStart = computed(
      () => connectionLineOptions.value.markerStart ? `url(#${getMarkerId(connectionLineOptions.value.markerStart, id2)})` : ""
    );
    const markerEnd = computed(
      () => connectionLineOptions.value.markerEnd ? `url(#${getMarkerId(connectionLineOptions.value.markerEnd, id2)})` : ""
    );
    return () => {
      var _a2, _b, _c, _d;
      if (!fromNode.value || !connectionStartHandle.value) {
        return null;
      }
      const startHandleId = connectionStartHandle.value.handleId;
      const handleType = connectionStartHandle.value.type;
      const fromHandleBounds = fromNode.value.handleBounds;
      let handleBounds = fromHandleBounds == null ? void 0 : fromHandleBounds[handleType];
      if (connectionMode.value === ConnectionMode.Loose) {
        handleBounds = handleBounds || (fromHandleBounds == null ? void 0 : fromHandleBounds[handleType === "source" ? "target" : "source"]);
      }
      if (!handleBounds) {
        return null;
      }
      const fromHandle = (startHandleId ? handleBounds.find((d) => d.id === startHandleId) : handleBounds[0]) ?? null;
      const fromPosition = (fromHandle == null ? void 0 : fromHandle.position) || Position.Top;
      const { x: fromX, y: fromY } = getHandlePosition(fromNode.value, fromHandle, fromPosition);
      let toHandle = null;
      if (toNode.value && ((_a2 = connectionEndHandle.value) == null ? void 0 : _a2.handleId)) {
        if (connectionMode.value === ConnectionMode.Strict) {
          toHandle = ((_b = toNode.value.handleBounds[handleType === "source" ? "target" : "source"]) == null ? void 0 : _b.find(
            (d) => {
              var _a3;
              return d.id === ((_a3 = connectionEndHandle.value) == null ? void 0 : _a3.handleId);
            }
          )) || null;
        } else {
          toHandle = ((_c = [...toNode.value.handleBounds.source || [], ...toNode.value.handleBounds.target || []]) == null ? void 0 : _c.find(
            (d) => {
              var _a3;
              return d.id === ((_a3 = connectionEndHandle.value) == null ? void 0 : _a3.handleId);
            }
          )) || null;
        }
      }
      const toPosition = ((_d = connectionEndHandle.value) == null ? void 0 : _d.position) ?? (fromPosition ? oppositePosition[fromPosition] : null);
      if (!fromPosition || !toPosition) {
        return null;
      }
      const type = connectionLineType.value ?? connectionLineOptions.value.type ?? ConnectionLineType.Bezier;
      let dAttr = "";
      const pathParams = {
        sourceX: fromX,
        sourceY: fromY,
        sourcePosition: fromPosition,
        targetX: toXY.value.x,
        targetY: toXY.value.y,
        targetPosition: toPosition
      };
      if (type === ConnectionLineType.Bezier) {
        [dAttr] = getBezierPath(pathParams);
      } else if (type === ConnectionLineType.Step) {
        [dAttr] = getSmoothStepPath({
          ...pathParams,
          borderRadius: 0
        });
      } else if (type === ConnectionLineType.SmoothStep) {
        [dAttr] = getSmoothStepPath(pathParams);
      } else if (type === ConnectionLineType.SimpleBezier) {
        [dAttr] = getSimpleBezierPath(pathParams);
      } else {
        dAttr = `M${fromX},${fromY} ${toXY.value.x},${toXY.value.y}`;
      }
      return h(
        "svg",
        { class: "vue-flow__edges vue-flow__connectionline vue-flow__container" },
        h(
          "g",
          { class: "vue-flow__connection" },
          connectionLineComponent ? h(connectionLineComponent, {
            sourceX: fromX,
            sourceY: fromY,
            sourcePosition: fromPosition,
            targetX: toXY.value.x,
            targetY: toXY.value.y,
            targetPosition: toPosition,
            sourceNode: fromNode.value,
            sourceHandle: fromHandle,
            targetNode: toNode.value,
            targetHandle: toHandle,
            markerEnd: markerEnd.value,
            markerStart: markerStart.value,
            connectionStatus: connectionStatus.value
          }) : h("path", {
            "d": dAttr,
            "class": [connectionLineOptions.value.class, connectionStatus, "vue-flow__connection-path"],
            "style": {
              ...connectionLineStyle.value,
              ...connectionLineOptions.value.style
            },
            "marker-end": markerEnd.value,
            "marker-start": markerStart.value
          })
        )
      );
    };
  }
});
const ConnectionLine$1 = ConnectionLine;
const _hoisted_1$4$2 = ["id", "markerWidth", "markerHeight", "markerUnits", "orient"];
const __default__$6 = {
  name: "MarkerType",
  compatConfig: { MODE: 3 }
};
const _sfc_main$6$1 = /* @__PURE__ */ defineComponent({
  ...__default__$6,
  props: {
    id: {},
    type: {},
    color: { default: "none" },
    width: { default: 12.5 },
    height: { default: 12.5 },
    markerUnits: { default: "strokeWidth" },
    orient: { default: "auto-start-reverse" },
    strokeWidth: { default: 1 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("marker", {
        id: _ctx.id,
        class: "vue-flow__arrowhead",
        viewBox: "-10 -10 20 20",
        refX: "0",
        refY: "0",
        markerWidth: `${_ctx.width}`,
        markerHeight: `${_ctx.height}`,
        markerUnits: _ctx.markerUnits,
        orient: _ctx.orient
      }, [
        _ctx.type === unref(MarkerType).ArrowClosed ? (openBlock(), createElementBlock("polyline", {
          key: 0,
          style: normalizeStyle({
            stroke: _ctx.color,
            fill: _ctx.color,
            strokeWidth: _ctx.strokeWidth
          }),
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          points: "-5,-4 0,0 -5,4 -5,-4"
        }, null, 4)) : createCommentVNode("", true),
        _ctx.type === unref(MarkerType).Arrow ? (openBlock(), createElementBlock("polyline", {
          key: 1,
          style: normalizeStyle({
            stroke: _ctx.color,
            strokeWidth: _ctx.strokeWidth
          }),
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          fill: "none",
          points: "-5,-4 0,0 -5,4"
        }, null, 4)) : createCommentVNode("", true)
      ], 8, _hoisted_1$4$2);
    };
  }
});
const _hoisted_1$3$2 = { class: "vue-flow__marker vue-flow__container" };
const __default__$5 = {
  name: "MarkerDefinitions",
  compatConfig: { MODE: 3 }
};
const _sfc_main$5$1 = /* @__PURE__ */ defineComponent({
  ...__default__$5,
  setup(__props) {
    const { id: vueFlowId, edges, connectionLineOptions, defaultMarkerColor: defaultColor } = useVueFlow();
    const markers = computed(() => {
      const ids = /* @__PURE__ */ new Set();
      const markers2 = [];
      const createMarkers = (marker) => {
        if (marker) {
          const markerId = getMarkerId(marker, vueFlowId);
          if (!ids.has(markerId)) {
            if (typeof marker === "object") {
              markers2.push({ ...marker, id: markerId, color: marker.color || defaultColor.value });
            } else {
              markers2.push({ id: markerId, color: defaultColor.value, type: marker });
            }
            ids.add(markerId);
          }
        }
      };
      for (const marker of [connectionLineOptions.value.markerEnd, connectionLineOptions.value.markerStart]) {
        createMarkers(marker);
      }
      for (const edge2 of edges.value) {
        for (const marker of [edge2.markerStart, edge2.markerEnd]) {
          createMarkers(marker);
        }
      }
      return markers2.sort((a, b) => a.id.localeCompare(b.id));
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", _hoisted_1$3$2, [
        createBaseVNode("defs", null, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(markers.value, (marker) => {
            return openBlock(), createBlock(_sfc_main$6$1, {
              id: marker.id,
              key: marker.id,
              type: marker.type,
              color: marker.color,
              width: marker.width,
              height: marker.height,
              markerUnits: marker.markerUnits,
              "stroke-width": marker.strokeWidth,
              orient: marker.orient
            }, null, 8, ["id", "type", "color", "width", "height", "markerUnits", "stroke-width", "orient"]);
          }), 128))
        ])
      ]);
    };
  }
});
const __default__$4$1 = {
  name: "Edges",
  compatConfig: { MODE: 3 }
};
const _sfc_main$4$1 = /* @__PURE__ */ defineComponent({
  ...__default__$4$1,
  setup(__props) {
    const { findNode, getEdges, elevateEdgesOnSelect } = useVueFlow();
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(_sfc_main$5$1),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getEdges), (edge2) => {
          return openBlock(), createElementBlock("svg", {
            key: edge2.id,
            class: "vue-flow__edges vue-flow__container",
            style: normalizeStyle({ zIndex: unref(getEdgeZIndex)(edge2, unref(findNode), unref(elevateEdgesOnSelect)) })
          }, [
            createVNode(unref(EdgeWrapper$1), {
              id: edge2.id
            }, null, 8, ["id"])
          ], 4);
        }), 128)),
        createVNode(unref(ConnectionLine$1))
      ], 64);
    };
  }
});
const NodeWrapper = defineComponent({
  name: "Node",
  compatConfig: { MODE: 3 },
  props: ["id", "resizeObserver"],
  setup(props) {
    const {
      id: vueFlowId,
      noPanClassName,
      selectNodesOnDrag,
      nodesSelectionActive,
      multiSelectionActive,
      emits,
      removeSelectedNodes,
      addSelectedNodes,
      updateNodeDimensions,
      onUpdateNodeInternals,
      getNodeTypes,
      nodeExtent,
      elevateNodesOnSelect,
      disableKeyboardA11y,
      ariaLiveMessage,
      snapToGrid,
      snapGrid,
      nodeDragThreshold,
      nodesDraggable,
      elementsSelectable,
      nodesConnectable,
      nodesFocusable,
      hooks
    } = useVueFlow();
    const nodeElement = ref(null);
    provide(NodeRef, nodeElement);
    provide(NodeId, props.id);
    const slots = inject(Slots$1);
    const instance = getCurrentInstance();
    const updateNodePositions = useUpdateNodePositions();
    const { node: node2, parentNode } = useNode(props.id);
    const { emit, on } = useNodeHooks(node2, emits);
    const isDraggable = toRef(() => typeof node2.draggable === "undefined" ? nodesDraggable.value : node2.draggable);
    const isSelectable = toRef(() => typeof node2.selectable === "undefined" ? elementsSelectable.value : node2.selectable);
    const isConnectable = toRef(() => typeof node2.connectable === "undefined" ? nodesConnectable.value : node2.connectable);
    const isFocusable = toRef(() => typeof node2.focusable === "undefined" ? nodesFocusable.value : node2.focusable);
    const hasPointerEvents = toRef(
      () => isSelectable.value || isDraggable.value || hooks.value.nodeClick.hasListeners() || hooks.value.nodeDoubleClick.hasListeners() || hooks.value.nodeMouseEnter.hasListeners() || hooks.value.nodeMouseMove.hasListeners() || hooks.value.nodeMouseLeave.hasListeners()
    );
    const isInit = toRef(() => !!node2.dimensions.width && !!node2.dimensions.height);
    const nodeCmp = computed(() => {
      const name = node2.type || "default";
      const slot = slots == null ? void 0 : slots[`node-${name}`];
      if (slot) {
        return slot;
      }
      let nodeType = node2.template || getNodeTypes.value[name];
      if (typeof nodeType === "string") {
        if (instance) {
          const components = Object.keys(instance.appContext.components);
          if (components && components.includes(name)) {
            nodeType = resolveComponent(name, false);
          }
        }
      }
      if (nodeType && typeof nodeType !== "string") {
        return nodeType;
      }
      emits.error(new VueFlowError(ErrorCode.NODE_TYPE_MISSING, nodeType));
      return false;
    });
    const dragging2 = useDrag({
      id: props.id,
      el: nodeElement,
      disabled: () => !isDraggable.value,
      selectable: isSelectable,
      dragHandle: () => node2.dragHandle,
      onStart(event) {
        emit.dragStart(event);
      },
      onDrag(event) {
        emit.drag(event);
      },
      onStop(event) {
        emit.dragStop(event);
      },
      onClick(event) {
        onSelectNode(event);
      }
    });
    const getClass = computed(() => node2.class instanceof Function ? node2.class(node2) : node2.class);
    const getStyle = computed(() => {
      const styles = (node2.style instanceof Function ? node2.style(node2) : node2.style) || {};
      const width = node2.width instanceof Function ? node2.width(node2) : node2.width;
      const height = node2.height instanceof Function ? node2.height(node2) : node2.height;
      if (!styles.width && width) {
        styles.width = typeof width === "string" ? width : `${width}px`;
      }
      if (!styles.height && height) {
        styles.height = typeof height === "string" ? height : `${height}px`;
      }
      return styles;
    });
    const zIndex = toRef(() => Number(node2.zIndex ?? getStyle.value.zIndex ?? 0));
    onUpdateNodeInternals((updateIds) => {
      if (updateIds.includes(props.id) || !updateIds.length) {
        updateInternals();
      }
    });
    onMounted(() => {
      watch(
        () => node2.hidden,
        (isHidden = false, _, onCleanup) => {
          if (!isHidden && nodeElement.value) {
            props.resizeObserver.observe(nodeElement.value);
            onCleanup(() => {
              if (nodeElement.value) {
                props.resizeObserver.unobserve(nodeElement.value);
              }
            });
          }
        },
        { immediate: true, flush: "post" }
      );
    });
    watch([() => node2.type, () => node2.sourcePosition, () => node2.targetPosition], () => {
      nextTick(() => {
        updateNodeDimensions([{ id: props.id, nodeElement: nodeElement.value, forceUpdate: true }]);
      });
    });
    watch(
      [
        () => node2.position.x,
        () => node2.position.y,
        () => {
          var _a;
          return (_a = parentNode.value) == null ? void 0 : _a.computedPosition.x;
        },
        () => {
          var _a;
          return (_a = parentNode.value) == null ? void 0 : _a.computedPosition.y;
        },
        () => {
          var _a;
          return (_a = parentNode.value) == null ? void 0 : _a.computedPosition.z;
        },
        zIndex,
        () => node2.selected,
        () => node2.dimensions.height,
        () => node2.dimensions.width,
        () => {
          var _a;
          return (_a = parentNode.value) == null ? void 0 : _a.dimensions.height;
        },
        () => {
          var _a;
          return (_a = parentNode.value) == null ? void 0 : _a.dimensions.width;
        }
      ],
      ([newX, newY, parentX, parentY, parentZ, nodeZIndex]) => {
        const xyzPos = {
          x: newX,
          y: newY,
          z: nodeZIndex + (elevateNodesOnSelect.value ? node2.selected ? 1e3 : 0 : 0)
        };
        if (typeof parentX !== "undefined" && typeof parentY !== "undefined") {
          node2.computedPosition = getXYZPos({ x: parentX, y: parentY, z: parentZ }, xyzPos);
        } else {
          node2.computedPosition = xyzPos;
        }
      },
      { flush: "post", immediate: true }
    );
    watch([() => node2.extent, nodeExtent], ([nodeExtent2, globalExtent], [oldNodeExtent, oldGlobalExtent]) => {
      if (nodeExtent2 !== oldNodeExtent || globalExtent !== oldGlobalExtent) {
        clampPosition2();
      }
    });
    if (node2.extent === "parent" || typeof node2.extent === "object" && "range" in node2.extent && node2.extent.range === "parent") {
      until(() => isInit).toBe(true).then(clampPosition2);
    } else {
      clampPosition2();
    }
    return () => {
      if (node2.hidden) {
        return null;
      }
      return h(
        "div",
        {
          "ref": nodeElement,
          "data-id": node2.id,
          "class": [
            "vue-flow__node",
            `vue-flow__node-${nodeCmp.value === false ? "default" : node2.type || "default"}`,
            {
              [noPanClassName.value]: isDraggable.value,
              dragging: dragging2 == null ? void 0 : dragging2.value,
              draggable: isDraggable.value,
              selected: node2.selected,
              selectable: isSelectable.value,
              parent: node2.isParent
            },
            getClass.value
          ],
          "style": {
            visibility: isInit.value ? "visible" : "hidden",
            zIndex: node2.computedPosition.z ?? zIndex.value,
            transform: `translate(${node2.computedPosition.x}px,${node2.computedPosition.y}px)`,
            pointerEvents: hasPointerEvents.value ? "all" : "none",
            ...getStyle.value
          },
          "tabIndex": isFocusable.value ? 0 : void 0,
          "role": isFocusable.value ? "button" : void 0,
          "aria-describedby": disableKeyboardA11y.value ? void 0 : `${ARIA_NODE_DESC_KEY}-${vueFlowId}`,
          "aria-label": node2.ariaLabel,
          "onMouseenter": onMouseEnter,
          "onMousemove": onMouseMove,
          "onMouseleave": onMouseLeave,
          "onContextmenu": onContextMenu,
          "onClick": onSelectNode,
          "onDblclick": onDoubleClick,
          "onKeydown": onKeyDown2
        },
        [
          h(nodeCmp.value === false ? getNodeTypes.value.default : nodeCmp.value, {
            id: node2.id,
            type: node2.type,
            data: node2.data,
            events: { ...node2.events, ...on },
            selected: node2.selected,
            resizing: node2.resizing,
            dragging: dragging2.value,
            connectable: isConnectable.value,
            position: node2.computedPosition,
            dimensions: node2.dimensions,
            isValidTargetPos: node2.isValidTargetPos,
            isValidSourcePos: node2.isValidSourcePos,
            parent: node2.parentNode,
            parentNodeId: node2.parentNode,
            zIndex: node2.computedPosition.z ?? zIndex.value,
            targetPosition: node2.targetPosition,
            sourcePosition: node2.sourcePosition,
            label: node2.label,
            dragHandle: node2.dragHandle,
            onUpdateNodeInternals: updateInternals
          })
        ]
      );
    };
    function clampPosition2() {
      const nextPos = node2.computedPosition;
      if (snapToGrid.value) {
        nextPos.x = snapGrid.value[0] * Math.round(nextPos.x / snapGrid.value[0]);
        nextPos.y = snapGrid.value[1] * Math.round(nextPos.y / snapGrid.value[1]);
      }
      const { computedPosition, position: position2 } = calcNextPosition(node2, nextPos, emits.error, nodeExtent.value, parentNode.value);
      if (node2.computedPosition.x !== computedPosition.x || node2.computedPosition.y !== computedPosition.y) {
        node2.computedPosition = { ...node2.computedPosition, ...computedPosition };
      }
      if (node2.position.x !== position2.x || node2.position.y !== position2.y) {
        node2.position = position2;
      }
    }
    function updateInternals() {
      if (nodeElement.value) {
        updateNodeDimensions([{ id: props.id, nodeElement: nodeElement.value, forceUpdate: true }]);
      }
    }
    function onMouseEnter(event) {
      if (!(dragging2 == null ? void 0 : dragging2.value)) {
        emit.mouseEnter({ event, node: node2 });
      }
    }
    function onMouseMove(event) {
      if (!(dragging2 == null ? void 0 : dragging2.value)) {
        emit.mouseMove({ event, node: node2 });
      }
    }
    function onMouseLeave(event) {
      if (!(dragging2 == null ? void 0 : dragging2.value)) {
        emit.mouseLeave({ event, node: node2 });
      }
    }
    function onContextMenu(event) {
      return emit.contextMenu({ event, node: node2 });
    }
    function onDoubleClick(event) {
      return emit.doubleClick({ event, node: node2 });
    }
    function onSelectNode(event) {
      if (isSelectable.value && (!selectNodesOnDrag.value || !isDraggable.value || nodeDragThreshold.value > 0)) {
        handleNodeClick(
          node2,
          multiSelectionActive.value,
          addSelectedNodes,
          removeSelectedNodes,
          nodesSelectionActive,
          false,
          nodeElement.value
        );
      }
      emit.click({ event, node: node2 });
    }
    function onKeyDown2(event) {
      if (isInputDOMNode(event) || disableKeyboardA11y.value) {
        return;
      }
      if (elementSelectionKeys.includes(event.key) && isSelectable.value) {
        const unselect = event.key === "Escape";
        handleNodeClick(
          node2,
          multiSelectionActive.value,
          addSelectedNodes,
          removeSelectedNodes,
          nodesSelectionActive,
          unselect,
          nodeElement.value
        );
      } else if (isDraggable.value && node2.selected && arrowKeyDiffs[event.key]) {
        ariaLiveMessage.value = `Moved selected node ${event.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~node2.position.x}, y: ${~~node2.position.y}`;
        updateNodePositions(
          {
            x: arrowKeyDiffs[event.key].x,
            y: arrowKeyDiffs[event.key].y
          },
          event.shiftKey
        );
      }
    }
  }
});
const NodeWrapper$1 = NodeWrapper;
const _hoisted_1$2$2 = {
  height: "0",
  width: "0"
};
const __default__$3$1 = {
  name: "EdgeLabelRenderer",
  compatConfig: { MODE: 3 }
};
const _sfc_main$3$1 = /* @__PURE__ */ defineComponent({
  ...__default__$3$1,
  setup(__props) {
    const { viewportRef } = useVueFlow();
    const teleportTarget = toRef(() => {
      var _a;
      return (_a = viewportRef.value) == null ? void 0 : _a.getElementsByClassName("vue-flow__edge-labels")[0];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", null, [
        (openBlock(), createElementBlock("foreignObject", _hoisted_1$2$2, [
          (openBlock(), createBlock(Teleport, {
            to: teleportTarget.value,
            disabled: !teleportTarget.value
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 8, ["to", "disabled"]))
        ]))
      ]);
    };
  }
});
function useNodesInitialized(options = { includeHiddenNodes: false }) {
  const { nodes } = useVueFlow();
  return computed(() => {
    if (nodes.value.length === 0) {
      return false;
    }
    for (const node2 of nodes.value) {
      if (options.includeHiddenNodes || !node2.hidden) {
        if ((node2 == null ? void 0 : node2.handleBounds) === void 0 || node2.dimensions.width === 0 || node2.dimensions.height === 0) {
          return false;
        }
      }
    }
    return true;
  });
}
const _hoisted_1$1$3 = { class: "vue-flow__nodes vue-flow__container" };
const __default__$2$1 = {
  name: "Nodes",
  compatConfig: { MODE: 3 }
};
const _sfc_main$2$1 = /* @__PURE__ */ defineComponent({
  ...__default__$2$1,
  setup(__props) {
    const { getNodes, updateNodeDimensions, emits } = useVueFlow();
    const nodesInitialized = useNodesInitialized();
    const resizeObserver = ref();
    watch(
      nodesInitialized,
      (isInit) => {
        if (isInit) {
          nextTick(() => {
            emits.nodesInitialized(getNodes.value);
          });
        }
      },
      { immediate: true }
    );
    onMounted(() => {
      resizeObserver.value = new ResizeObserver((entries) => {
        const updates = entries.map((entry) => {
          const id2 = entry.target.getAttribute("data-id");
          return {
            id: id2,
            nodeElement: entry.target,
            forceUpdate: true
          };
        });
        nextTick(() => updateNodeDimensions(updates));
      });
    });
    onBeforeUnmount(() => {
      var _a;
      return (_a = resizeObserver.value) == null ? void 0 : _a.disconnect();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1$3, [
        resizeObserver.value ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(getNodes), (node2, __, ___, _cached) => {
          const _memo = [node2.id];
          if (_cached && _cached.key === node2.id && isMemoSame(_cached, _memo))
            return _cached;
          const _item = (openBlock(), createBlock(unref(NodeWrapper$1), {
            id: node2.id,
            key: node2.id,
            "resize-observer": resizeObserver.value
          }, null, 8, ["id", "resize-observer"]));
          _item.memo = _memo;
          return _item;
        }, _cache, 0), 128)) : createCommentVNode("", true)
      ]);
    };
  }
});
function useStylesLoadedWarning() {
  const { emits } = useVueFlow();
  onMounted(() => {
    if (isDev()) {
      const pane = document.querySelector(".vue-flow__pane");
      if (pane && !(window.getComputedStyle(pane).zIndex === "1")) {
        emits.error(new VueFlowError(ErrorCode.MISSING_STYLES));
      }
    }
  });
}
const _hoisted_1$a = /* @__PURE__ */ createBaseVNode("div", { class: "vue-flow__edge-labels" }, null, -1);
const __default__$1$2 = {
  name: "VueFlow",
  compatConfig: { MODE: 3 }
};
const _sfc_main$1$4 = /* @__PURE__ */ defineComponent({
  ...__default__$1$2,
  props: {
    id: {},
    modelValue: {},
    nodes: {},
    edges: {},
    edgeTypes: {},
    nodeTypes: {},
    connectionMode: {},
    connectionLineType: {},
    connectionLineStyle: { default: void 0 },
    connectionLineOptions: { default: void 0 },
    connectionRadius: {},
    isValidConnection: { type: [Function, null], default: void 0 },
    deleteKeyCode: { default: void 0 },
    selectionKeyCode: { default: void 0 },
    multiSelectionKeyCode: { default: void 0 },
    zoomActivationKeyCode: { default: void 0 },
    panActivationKeyCode: { default: void 0 },
    snapToGrid: { type: Boolean, default: void 0 },
    snapGrid: {},
    onlyRenderVisibleElements: { type: Boolean, default: void 0 },
    edgesUpdatable: { type: [Boolean, String], default: void 0 },
    nodesDraggable: { type: Boolean, default: void 0 },
    nodesConnectable: { type: Boolean, default: void 0 },
    nodeDragThreshold: {},
    elementsSelectable: { type: Boolean, default: void 0 },
    selectNodesOnDrag: { type: Boolean, default: void 0 },
    panOnDrag: { type: [Boolean, Array], default: void 0 },
    minZoom: {},
    maxZoom: {},
    defaultViewport: {},
    translateExtent: {},
    nodeExtent: {},
    defaultMarkerColor: {},
    zoomOnScroll: { type: Boolean, default: void 0 },
    zoomOnPinch: { type: Boolean, default: void 0 },
    panOnScroll: { type: Boolean, default: void 0 },
    panOnScrollSpeed: {},
    panOnScrollMode: {},
    paneClickDistance: {},
    zoomOnDoubleClick: { type: Boolean, default: void 0 },
    preventScrolling: { type: Boolean, default: void 0 },
    selectionMode: {},
    edgeUpdaterRadius: {},
    fitViewOnInit: { type: Boolean, default: void 0 },
    connectOnClick: { type: Boolean, default: void 0 },
    applyDefault: { type: Boolean, default: void 0 },
    autoConnect: { type: [Boolean, Function], default: void 0 },
    noDragClassName: {},
    noWheelClassName: {},
    noPanClassName: {},
    defaultEdgeOptions: {},
    elevateEdgesOnSelect: { type: Boolean, default: void 0 },
    elevateNodesOnSelect: { type: Boolean, default: void 0 },
    disableKeyboardA11y: { type: Boolean, default: void 0 },
    edgesFocusable: { type: Boolean, default: void 0 },
    nodesFocusable: { type: Boolean, default: void 0 },
    autoPanOnConnect: { type: Boolean, default: void 0 },
    autoPanOnNodeDrag: { type: Boolean, default: void 0 },
    autoPanSpeed: {}
  },
  emits: ["nodesChange", "edgesChange", "nodesInitialized", "paneReady", "init", "updateNodeInternals", "error", "connect", "connectStart", "connectEnd", "clickConnectStart", "clickConnectEnd", "moveStart", "move", "moveEnd", "selectionDragStart", "selectionDrag", "selectionDragStop", "selectionContextMenu", "selectionStart", "selectionEnd", "viewportChangeStart", "viewportChange", "viewportChangeEnd", "paneScroll", "paneClick", "paneContextMenu", "paneMouseEnter", "paneMouseMove", "paneMouseLeave", "edgeUpdate", "edgeContextMenu", "edgeMouseEnter", "edgeMouseMove", "edgeMouseLeave", "edgeDoubleClick", "edgeClick", "edgeUpdateStart", "edgeUpdateEnd", "nodeContextMenu", "nodeMouseEnter", "nodeMouseMove", "nodeMouseLeave", "nodeDoubleClick", "nodeClick", "nodeDragStart", "nodeDrag", "nodeDragStop", "miniMapNodeClick", "miniMapNodeDoubleClick", "miniMapNodeMouseEnter", "miniMapNodeMouseMove", "miniMapNodeMouseLeave", "update:modelValue", "update:nodes", "update:edges"],
  setup(__props, { expose: __expose, emit }) {
    const props = __props;
    const slots = useSlots();
    const modelValue = useVModel(props, "modelValue", emit);
    const modelNodes = useVModel(props, "nodes", emit);
    const modelEdges = useVModel(props, "edges", emit);
    const instance = useVueFlow(props);
    const dispose = useWatchProps({ modelValue, nodes: modelNodes, edges: modelEdges }, props, instance);
    useHooks(emit, instance.hooks);
    useOnInitHandler();
    useStylesLoadedWarning();
    provide(Slots$1, slots);
    onUnmounted(() => {
      dispose();
    });
    __expose(instance);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref: unref(instance).vueFlowRef,
        class: "vue-flow"
      }, [
        createVNode(_sfc_main$8$1, null, {
          default: withCtx(() => [
            createVNode(_sfc_main$4$1),
            _hoisted_1$a,
            createVNode(_sfc_main$2$1),
            renderSlot(_ctx.$slots, "zoom-pane")
          ]),
          _: 3
        }),
        renderSlot(_ctx.$slots, "default"),
        createVNode(_sfc_main$7$1)
      ], 512);
    };
  }
});
const __default__$g = {
  name: "Panel",
  compatConfig: { MODE: 3 }
};
const _sfc_main$z = /* @__PURE__ */ defineComponent({
  ...__default__$g,
  props: {
    position: {}
  },
  setup(__props) {
    const props = __props;
    const { userSelectionActive } = useVueFlow();
    const positionClasses = computed(() => `${props.position}`.split("-"));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["vue-flow__panel", positionClasses.value]),
        style: normalizeStyle({ pointerEvents: unref(userSelectionActive) ? "none" : "all" })
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});
const _sfc_main$1$3 = {
  name: "ControlButton",
  compatConfig: { MODE: 3 }
};
const _export_sfc = (sfc, props) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target2[key] = val;
  }
  return target2;
};
const _hoisted_1$5$1 = { class: "vue-flow__controls-button" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", _hoisted_1$5$1, [
    renderSlot(_ctx.$slots, "default")
  ]);
}
const ControlButton = /* @__PURE__ */ _export_sfc(_sfc_main$1$3, [["render", _sfc_render]]);
const _hoisted_1$4$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 32"
};
const _hoisted_2$4$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$4$1
];
function render$4(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$4$1, _hoisted_3$4);
}
const PlusIcon = { render: render$4 };
const _hoisted_1$3$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 5"
};
const _hoisted_2$3$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M0 0h32v4.2H0z" }, null, -1);
const _hoisted_3$3$1 = [
  _hoisted_2$3$1
];
function render$3(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$3$1, _hoisted_3$3$1);
}
const MinusIcon = { render: render$3 };
const _hoisted_1$2$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 30"
};
const _hoisted_2$2$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0 0 27.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94a.919.919 0 0 1-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }, null, -1);
const _hoisted_3$2$1 = [
  _hoisted_2$2$1
];
function render$2(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$2$1, _hoisted_3$2$1);
}
const FitView = { render: render$2 };
const _hoisted_1$1$2 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 25 32"
};
const _hoisted_2$1$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 0 0 0 13.714v15.238A3.056 3.056 0 0 0 3.048 32h18.285a3.056 3.056 0 0 0 3.048-3.048V13.714a3.056 3.056 0 0 0-3.048-3.047zM12.19 24.533a3.056 3.056 0 0 1-3.047-3.047 3.056 3.056 0 0 1 3.047-3.048 3.056 3.056 0 0 1 3.048 3.048 3.056 3.056 0 0 1-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }, null, -1);
const _hoisted_3$1$1 = [
  _hoisted_2$1$1
];
function render$1(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$1$2, _hoisted_3$1$1);
}
const Lock = { render: render$1 };
const _hoisted_1$8 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 25 32"
};
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 0 0 0 13.714v15.238A3.056 3.056 0 0 0 3.048 32h18.285a3.056 3.056 0 0 0 3.048-3.048V13.714a3.056 3.056 0 0 0-3.048-3.047zM12.19 24.533a3.056 3.056 0 0 1-3.047-3.047 3.056 3.056 0 0 1 3.047-3.048 3.056 3.056 0 0 1 3.048 3.048 3.056 3.056 0 0 1-3.048 3.047z" }, null, -1);
const _hoisted_3$5 = [
  _hoisted_2$5
];
function render(_ctx, _cache) {
  return openBlock(), createElementBlock("svg", _hoisted_1$8, _hoisted_3$5);
}
const Unlock = { render };
const __default__$4 = {
  name: "Controls",
  compatConfig: { MODE: 3 }
};
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  ...__default__$4,
  props: {
    showZoom: { type: Boolean, default: true },
    showFitView: { type: Boolean, default: true },
    showInteractive: { type: Boolean, default: true },
    fitViewParams: {},
    position: { default: () => PanelPosition.BottomLeft }
  },
  emits: ["zoomIn", "zoomOut", "fitView", "interactionChange"],
  setup(__props, { emit }) {
    const {
      nodesDraggable,
      nodesConnectable,
      elementsSelectable,
      setInteractive,
      zoomIn,
      zoomOut,
      fitView,
      viewport,
      minZoom,
      maxZoom
    } = useVueFlow();
    const isInteractive = toRef(() => nodesDraggable.value || nodesConnectable.value || elementsSelectable.value);
    const minZoomReached = toRef(() => viewport.value.zoom <= minZoom.value);
    const maxZoomReached = toRef(() => viewport.value.zoom >= maxZoom.value);
    function onZoomInHandler() {
      zoomIn();
      emit("zoomIn");
    }
    function onZoomOutHandler() {
      zoomOut();
      emit("zoomOut");
    }
    function onFitViewHandler() {
      fitView(__props.fitViewParams);
      emit("fitView");
    }
    function onInteractiveChangeHandler() {
      setInteractive(!isInteractive.value);
      emit("interactionChange", !isInteractive.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$z), {
        class: "vue-flow__controls",
        position: _ctx.position
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "top"),
          _ctx.showZoom ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            renderSlot(_ctx.$slots, "control-zoom-in", {}, () => [
              createVNode(ControlButton, {
                class: "vue-flow__controls-zoomin",
                disabled: maxZoomReached.value,
                onClick: onZoomInHandler
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "icon-zoom-in", {}, () => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(PlusIcon))))
                  ])
                ]),
                _: 3
              }, 8, ["disabled"])
            ]),
            renderSlot(_ctx.$slots, "control-zoom-out", {}, () => [
              createVNode(ControlButton, {
                class: "vue-flow__controls-zoomout",
                disabled: minZoomReached.value,
                onClick: onZoomOutHandler
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "icon-zoom-out", {}, () => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(MinusIcon))))
                  ])
                ]),
                _: 3
              }, 8, ["disabled"])
            ])
          ], 64)) : createCommentVNode("", true),
          _ctx.showFitView ? renderSlot(_ctx.$slots, "control-fit-view", { key: 1 }, () => [
            createVNode(ControlButton, {
              class: "vue-flow__controls-fitview",
              onClick: onFitViewHandler
            }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "icon-fit-view", {}, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(FitView))))
                ])
              ]),
              _: 3
            })
          ]) : createCommentVNode("", true),
          _ctx.showInteractive ? renderSlot(_ctx.$slots, "control-interactive", { key: 2 }, () => [
            _ctx.showInteractive ? (openBlock(), createBlock(ControlButton, {
              key: 0,
              class: "vue-flow__controls-interactive",
              onClick: onInteractiveChangeHandler
            }, {
              default: withCtx(() => [
                isInteractive.value ? renderSlot(_ctx.$slots, "icon-unlock", { key: 0 }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(Unlock))))
                ]) : createCommentVNode("", true),
                !isInteractive.value ? renderSlot(_ctx.$slots, "icon-lock", { key: 1 }, () => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(Lock))))
                ]) : createCommentVNode("", true)
              ]),
              _: 3
            })) : createCommentVNode("", true)
          ]) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 8, ["position"]);
    };
  }
});
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "CanvasControlButtons",
  props: {
    zoom: { default: 1 }
  },
  emits: ["reset-zoom", "zoom-in", "zoom-out", "zoom-to-fit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const isResetZoomVisible = computed(() => props.zoom !== 1);
    function onResetZoom() {
      emit("reset-zoom");
    }
    function onZoomIn() {
      emit("zoom-in");
    }
    function onZoomOut() {
      emit("zoom-out");
    }
    function onZoomToFit() {
      emit("zoom-to-fit");
    }
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(unref(_sfc_main$y), {
        "show-zoom": false,
        "show-fit-view": false
      }, {
        default: withCtx(() => [
          createVNode(KeyboardShortcutTooltip, {
            label: _ctx.$locale.baseText("nodeView.zoomToFit"),
            shortcut: { keys: ["1"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_N8nIconButton, {
                type: "tertiary",
                size: "large",
                icon: "expand",
                "data-test-id": "zoom-to-fit",
                onClick: onZoomToFit
              })
            ]),
            _: 1
          }, 8, ["label"]),
          createVNode(KeyboardShortcutTooltip, {
            label: _ctx.$locale.baseText("nodeView.zoomIn"),
            shortcut: { keys: ["+"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_N8nIconButton, {
                type: "tertiary",
                size: "large",
                icon: "search-plus",
                "data-test-id": "zoom-in-button",
                onClick: onZoomIn
              })
            ]),
            _: 1
          }, 8, ["label"]),
          createVNode(KeyboardShortcutTooltip, {
            label: _ctx.$locale.baseText("nodeView.zoomOut"),
            shortcut: { keys: ["-"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_N8nIconButton, {
                type: "tertiary",
                size: "large",
                icon: "search-minus",
                "data-test-id": "zoom-out-button",
                onClick: onZoomOut
              })
            ]),
            _: 1
          }, 8, ["label"]),
          isResetZoomVisible.value ? (openBlock(), createBlock(KeyboardShortcutTooltip, {
            key: 0,
            label: _ctx.$locale.baseText("nodeView.resetZoom"),
            shortcut: { keys: ["0"] }
          }, {
            default: withCtx(() => [
              createVNode(_component_N8nIconButton, {
                type: "tertiary",
                size: "large",
                icon: "undo",
                "data-test-id": "reset-zoom-button",
                onClick: onResetZoom
              })
            ]),
            _: 1
          }, 8, ["label"])) : createCommentVNode("", true)
        ]),
        _: 1
      });
    };
  }
});
const EDGE_PADDING_TOP = 80;
const EDGE_PADDING_BOTTOM = 140;
const EDGE_PADDING_X = 40;
const EDGE_BORDER_RADIUS = 16;
const HANDLE_SIZE = 20;
const isRightOfSourceHandle = (sourceX, targetX) => sourceX - HANDLE_SIZE > targetX;
const pathIntersectsNodes = (targetY, sourceY) => Math.abs(targetY - sourceY) < EDGE_PADDING_BOTTOM;
function getCustomPath(props, {
  connectionType: connectionType2 = NodeConnectionType.Main
} = {}) {
  const { targetX, targetY, sourceX, sourceY, sourcePosition, targetPosition } = props;
  const yDiff = targetY - sourceY;
  if (!isRightOfSourceHandle(sourceX, targetX) || connectionType2 !== NodeConnectionType.Main) {
    return getBezierPath(props);
  }
  if (pathIntersectsNodes(targetY, sourceY)) {
    const direction = yDiff < -EDGE_PADDING_BOTTOM || yDiff > 0 ? "up" : "down";
    const firstSegmentTargetX = sourceX;
    const firstSegmentTargetY = sourceY + (direction === "up" ? -EDGE_PADDING_TOP : EDGE_PADDING_BOTTOM);
    const [firstSegmentPath] = getSmoothStepPath({
      sourceX,
      sourceY,
      targetX: firstSegmentTargetX,
      targetY: firstSegmentTargetY,
      sourcePosition,
      targetPosition: Position.Right,
      borderRadius: EDGE_BORDER_RADIUS,
      offset: EDGE_PADDING_X
    });
    const path = getSmoothStepPath({
      sourceX: firstSegmentTargetX,
      sourceY: firstSegmentTargetY,
      targetX,
      targetY,
      sourcePosition: Position.Left,
      targetPosition,
      borderRadius: EDGE_BORDER_RADIUS,
      offset: EDGE_PADDING_X
    });
    path[0] = firstSegmentPath + path[0];
    return path;
  }
  return getSmoothStepPath({
    ...props,
    borderRadius: EDGE_BORDER_RADIUS
  });
}
function useCanvas() {
  const canvas2 = inject(CanvasKey);
  const connectingHandle = computed(() => canvas2 == null ? void 0 : canvas2.connectingHandle.value);
  const isExecuting = computed(() => canvas2 == null ? void 0 : canvas2.isExecuting.value);
  return {
    isExecuting,
    connectingHandle
  };
}
const _sfc_main$w = /* @__PURE__ */ defineComponent({
  __name: "CanvasConnectionLine",
  props: {
    sourceX: {},
    sourceY: {},
    sourcePosition: {},
    targetX: {},
    targetY: {},
    targetPosition: {},
    sourceNode: {},
    sourceHandle: {},
    targetNode: {},
    targetHandle: {},
    markerStart: {},
    markerEnd: {},
    connectionStatus: {}
  },
  setup(__props) {
    const props = __props;
    const $style = useCssModule();
    const { connectingHandle } = useCanvas();
    const connectionType2 = computed(
      () => {
        var _a;
        return parseCanvasConnectionHandleString((_a = connectingHandle.value) == null ? void 0 : _a.handleId).type;
      }
    );
    const edgeColor = computed(() => {
      if (connectionType2.value !== NodeConnectionType.Main) {
        return "var(--node-type-supplemental-color)";
      } else {
        return "var(--color-foreground-xdark)";
      }
    });
    const edgeStyle = computed(() => ({
      ...connectionType2.value === NodeConnectionType.Main ? {} : { strokeDasharray: "8,8" },
      strokeWidth: 2,
      stroke: edgeColor.value
    }));
    const path = computed(() => getCustomPath(props, { connectionType: connectionType2.value }));
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$d$1), {
        class: normalizeClass(unref($style).edge),
        style: normalizeStyle(edgeStyle.value),
        path: path.value[0],
        "marker-end": _ctx.markerEnd
      }, null, 8, ["class", "style", "path", "marker-end"]);
    };
  }
});
const edge$1 = "_edge_ujtc6_1";
const style0$m = {
  edge: edge$1
};
const cssModules$m = {
  "$style": style0$m
};
const __unplugin_components_0$4 = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__cssModules", cssModules$m]]);
var BackgroundVariant = /* @__PURE__ */ ((BackgroundVariant2) => {
  BackgroundVariant2["Lines"] = "lines";
  BackgroundVariant2["Dots"] = "dots";
  return BackgroundVariant2;
})(BackgroundVariant || {});
const LinePattern = function({ dimensions, size, color: color2 }) {
  return h("path", {
    "stroke": color2,
    "stroke-width": size,
    "d": `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`
  });
};
const DotPattern = function({ radius, color: color2 }) {
  return h("circle", { cx: radius, cy: radius, r: radius, fill: color2 });
};
({
  [BackgroundVariant.Lines]: LinePattern,
  [BackgroundVariant.Dots]: DotPattern
});
const DefaultBgColors = {
  [BackgroundVariant.Dots]: "#81818a",
  [BackgroundVariant.Lines]: "#eee"
};
const _hoisted_1$7 = ["id", "x", "y", "width", "height", "patternTransform"];
const _hoisted_2$4 = {
  key: 2,
  height: "100",
  width: "100"
};
const _hoisted_3$3 = ["fill"];
const _hoisted_4 = ["x", "y", "fill"];
const __default__$3 = {
  name: "Background",
  compatConfig: { MODE: 3 }
};
const _sfc_main$v = /* @__PURE__ */ defineComponent({
  ...__default__$3,
  props: {
    id: {},
    variant: { default: () => BackgroundVariant.Dots },
    gap: { default: 20 },
    size: { default: 1 },
    lineWidth: { default: 1 },
    patternColor: {},
    color: {},
    bgColor: {},
    height: { default: 100 },
    width: { default: 100 },
    x: { default: 0 },
    y: { default: 0 },
    offset: { default: 2 }
  },
  setup(__props) {
    const { id: vueFlowId, viewport } = useVueFlow();
    const background = computed(() => {
      const [gapX, gapY] = Array.isArray(__props.gap) ? __props.gap : [__props.gap, __props.gap];
      const scaledGap = [gapX * viewport.value.zoom || 1, gapY * viewport.value.zoom || 1];
      const scaledSize = __props.size * viewport.value.zoom;
      const patternOffset = __props.variant === BackgroundVariant.Dots ? [scaledSize / __props.offset, scaledSize / __props.offset] : [scaledGap[0] / __props.offset, scaledGap[1] / __props.offset];
      return {
        scaledGap,
        offset: patternOffset,
        size: scaledSize
      };
    });
    const patternId = toRef(() => `pattern-${vueFlowId}${__props.id ? `-${__props.id}` : ""}`);
    const patternColor = toRef(() => __props.color || __props.patternColor || DefaultBgColors[__props.variant || BackgroundVariant.Dots]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", {
        class: "vue-flow__background vue-flow__container",
        style: normalizeStyle({
          height: `${_ctx.height > 100 ? 100 : _ctx.height}%`,
          width: `${_ctx.width > 100 ? 100 : _ctx.width}%`
        })
      }, [
        renderSlot(_ctx.$slots, "pattern-container", { id: patternId.value }, () => [
          createBaseVNode("pattern", {
            id: patternId.value,
            x: unref(viewport).x % background.value.scaledGap[0],
            y: unref(viewport).y % background.value.scaledGap[1],
            width: background.value.scaledGap[0],
            height: background.value.scaledGap[1],
            patternTransform: `translate(-${background.value.offset[0]},-${background.value.offset[1]})`,
            patternUnits: "userSpaceOnUse"
          }, [
            renderSlot(_ctx.$slots, "pattern", {}, () => [
              _ctx.variant === unref(BackgroundVariant).Lines ? (openBlock(), createBlock(unref(LinePattern), {
                key: 0,
                size: _ctx.lineWidth,
                color: patternColor.value,
                dimensions: background.value.scaledGap
              }, null, 8, ["size", "color", "dimensions"])) : _ctx.variant === unref(BackgroundVariant).Dots ? (openBlock(), createBlock(unref(DotPattern), {
                key: 1,
                color: patternColor.value,
                radius: background.value.size / _ctx.offset
              }, null, 8, ["color", "radius"])) : createCommentVNode("", true),
              _ctx.bgColor ? (openBlock(), createElementBlock("svg", _hoisted_2$4, [
                createBaseVNode("rect", {
                  width: "100%",
                  height: "100%",
                  fill: _ctx.bgColor
                }, null, 8, _hoisted_3$3)
              ])) : createCommentVNode("", true)
            ])
          ], 8, _hoisted_1$7)
        ]),
        createBaseVNode("rect", {
          x: _ctx.x,
          y: _ctx.y,
          width: "100%",
          height: "100%",
          fill: `url(#${patternId.value})`
        }, null, 8, _hoisted_4),
        renderSlot(_ctx.$slots, "default", { id: patternId.value })
      ], 4);
    };
  }
});
var noop$1 = { value: () => {
} };
function dispatch$1() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch$1(_);
}
function Dispatch$1(_) {
  this._ = _;
}
function parseTypenames$1$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch$1.prototype = dispatch$1.prototype = {
  constructor: Dispatch$1,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames$1$1(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set$1(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch$1(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
var xhtml$1 = "http://www.w3.org/1999/xhtml";
const namespaces$1 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml$1,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace$1(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces$1.hasOwnProperty(prefix) ? { space: namespaces$1[prefix], local: name } : name;
}
function creatorInherit$1(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml$1 && document2.documentElement.namespaceURI === xhtml$1 ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed$1(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator$1(name) {
  var fullname = namespace$1(name);
  return (fullname.local ? creatorFixed$1 : creatorInherit$1)(fullname);
}
function none$1() {
}
function selector$1(selector2) {
  return selector2 == null ? none$1 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select$1(select2) {
  if (typeof select2 !== "function")
    select2 = selector$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array$1(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty$1() {
  return [];
}
function selectorAll$1(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll$1(select2) {
  return function() {
    return array$1(select2.apply(this, arguments));
  };
}
function selection_selectAll$1(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll$1(select2);
  else
    select2 = selectorAll$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher$1(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher$1(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find$1 = Array.prototype.find;
function childFind$1(match) {
  return function() {
    return find$1.call(this.children, match);
  };
}
function childFirst$1() {
  return this.firstElementChild;
}
function selection_selectChild$1(match) {
  return this.select(match == null ? childFirst$1 : childFind$1(typeof match === "function" ? match : childMatcher$1(match)));
}
var filter$1 = Array.prototype.filter;
function children$1() {
  return Array.from(this.children);
}
function childrenFilter$1(match) {
  return function() {
    return filter$1.call(this.children, match);
  };
}
function selection_selectChildren$1(match) {
  return this.selectAll(match == null ? children$1 : childrenFilter$1(typeof match === "function" ? match : childMatcher$1(match)));
}
function selection_filter$1(match) {
  if (typeof match !== "function")
    match = matcher$1(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse$1(update) {
  return new Array(update.length);
}
function selection_enter$1() {
  return new Selection$1(this._enter || this._groups.map(sparse$1), this._parents);
}
function EnterNode$1(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode$1.prototype = {
  constructor: EnterNode$1,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$2(x) {
  return function() {
    return x;
  };
}
function bindIndex$1(parent, group, enter, update, exit, data) {
  var i = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode$1(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey$1(parent, group, enter, update, exit, data, key) {
  var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update[i] = node2;
      node2.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode$1(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
      exit[i] = node2;
    }
  }
}
function datum$1(node2) {
  return node2.__data__;
}
function selection_data$1(value, key) {
  if (!arguments.length)
    return Array.from(this, datum$1);
  var bind = key ? bindKey$1 : bindIndex$1, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$2(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike$1(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike$1(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit$1() {
  return new Selection$1(this._exit || this._groups.map(sparse$1), this._parents);
}
function selection_join$1(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge$1(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order$1() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next && node2.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node2, next);
        next = node2;
      }
    }
  }
  return this;
}
function selection_sort$1(compare) {
  if (!compare)
    compare = ascending$1;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending$1(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call$1() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes$1() {
  return Array.from(this);
}
function selection_node$1() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size$1() {
  let size = 0;
  for (const node2 of this)
    ++size;
  return size;
}
function selection_empty$1() {
  return !this.node();
}
function selection_each$1(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr$1(name, value) {
  var fullname = namespace$1(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView$1(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style$1(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue$1(this.node(), name);
}
function styleValue$1(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView$1(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove$1(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant$1(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property$1(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove$1 : typeof value === "function" ? propertyFunction$1 : propertyConstant$1)(name, value)) : this.node()[name];
}
function classArray$1(string) {
  return string.trim().split(/^|\s+/);
}
function classList$1(node2) {
  return node2.classList || new ClassList$1(node2);
}
function ClassList$1(node2) {
  this._node = node2;
  this._names = classArray$1(node2.getAttribute("class") || "");
}
ClassList$1.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd$1(node2, names) {
  var list = classList$1(node2), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove$1(node2, names) {
  var list = classList$1(node2), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue$1(names) {
  return function() {
    classedAdd$1(this, names);
  };
}
function classedFalse$1(names) {
  return function() {
    classedRemove$1(this, names);
  };
}
function classedFunction$1(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names);
  };
}
function selection_classed$1(name, value) {
  var names = classArray$1(name + "");
  if (arguments.length < 2) {
    var list = classList$1(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction$1 : value ? classedTrue$1 : classedFalse$1)(names, value));
}
function textRemove$1() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text$1(value) {
  return arguments.length ? this.each(value == null ? textRemove$1 : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove$1() {
  this.innerHTML = "";
}
function htmlConstant$1(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html$1(value) {
  return arguments.length ? this.each(value == null ? htmlRemove$1 : (typeof value === "function" ? htmlFunction$1 : htmlConstant$1)(value)) : this.node().innerHTML;
}
function raise$1() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise$1() {
  return this.each(raise$1);
}
function lower$1() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower$1() {
  return this.each(lower$1);
}
function selection_append$1(name) {
  var create2 = typeof name === "function" ? name : creator$1(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull$1() {
  return null;
}
function selection_insert$1(name, before) {
  var create2 = typeof name === "function" ? name : creator$1(name), select2 = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove$1() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove$1() {
  return this.each(remove$1);
}
function selection_cloneShallow$1() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep$1() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone$1(deep) {
  return this.select(deep ? selection_cloneDeep$1 : selection_cloneShallow$1);
}
function selection_datum$1(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener$1(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$2(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove$1(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd$1(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener$1(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on$1(typename, value, options) {
  var typenames = parseTypenames$2(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd$1 : onRemove$1;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent$1(node2, type, params) {
  var window2 = defaultView$1(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant$1(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params);
  };
}
function dispatchFunction$1(type, params) {
  return function() {
    return dispatchEvent$1(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch$1(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction$1 : dispatchConstant$1)(type, params));
}
function* selection_iterator$1() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        yield node2;
    }
  }
}
var root$1 = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}
function selection_selection$1() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select$1,
  selectAll: selection_selectAll$1,
  selectChild: selection_selectChild$1,
  selectChildren: selection_selectChildren$1,
  filter: selection_filter$1,
  data: selection_data$1,
  enter: selection_enter$1,
  exit: selection_exit$1,
  join: selection_join$1,
  merge: selection_merge$1,
  selection: selection_selection$1,
  order: selection_order$1,
  sort: selection_sort$1,
  call: selection_call$1,
  nodes: selection_nodes$1,
  node: selection_node$1,
  size: selection_size$1,
  empty: selection_empty$1,
  each: selection_each$1,
  attr: selection_attr$1,
  style: selection_style$1,
  property: selection_property$1,
  classed: selection_classed$1,
  text: selection_text$1,
  html: selection_html$1,
  raise: selection_raise$1,
  lower: selection_lower$1,
  append: selection_append$1,
  insert: selection_insert$1,
  remove: selection_remove$1,
  clone: selection_clone$1,
  datum: selection_datum$1,
  on: selection_on$1,
  dispatch: selection_dispatch$1,
  [Symbol.iterator]: selection_iterator$1
};
function select$1(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$1);
}
function sourceEvent$1(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer$1(event, node2) {
  event = sourceEvent$1(event);
  if (node2 === void 0)
    node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node2.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassivecapture$1 = { capture: true, passive: false };
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", noevent$1, nonpassivecapture$1);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture$1);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag$1(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select$1(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture$1);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color$1, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color$1(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s, l, a) {
  if (a <= 0)
    h2 = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h2 = s = NaN;
  else if (s <= 0)
    h2 = NaN;
  return new Hsl(h2, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color$1(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h2 = NaN, s = max - min, l = (max + min) / 2;
  if (s) {
    if (r === max)
      h2 = (g - b) / s + (g < b) * 6;
    else if (g === max)
      h2 = (b - r) / s + 2;
    else
      h2 = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h2 *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h2;
  }
  return new Hsl(h2, s, l, o.opacity);
}
function hsl(h2, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h2, s, l, opacity) {
  this.h = +h2;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant$1$1 = (x) => () => x;
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$1$1(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$1$1(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma2(y) {
  var color2 = gamma(y);
  function rgb$12(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$12.gamma = rgbGamma2;
  return rgb$12;
}(1);
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX,
    scaleY
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity$1;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
const interpolateZoom = function zoomRho2(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho2(_1, _2, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(void 0, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval)
      interval = clearInterval(interval);
  } else {
    if (!interval)
      clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart((elapsed) => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
var emptyOn = dispatch$1("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node2, name, id2, index, group, timing) {
  var schedules = node2.__transition;
  if (!schedules)
    node2.__transition = {};
  else if (id2 in schedules)
    return;
  create(node2, id2, {
    name,
    index,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init(node2, id2) {
  var schedule2 = get$2(node2, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$2(node2, id2) {
  var schedule2 = get$2(node2, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get$2(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule2, 0, self.time);
  function schedule2(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed)
      start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self.state !== SCHEDULED)
      return stop2();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node2, node2.__data__, self.index, self.group);
    if (self.state !== STARTING)
      return;
    self.state = STARTED;
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node2, node2.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop2), self.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t);
    }
    if (self.state === ENDING) {
      self.on.call("end", node2, node2.__data__, self.index, self.group);
      stop2();
    }
  }
  function stop2() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node2.__transition;
  }
}
function interrupt(node2, name) {
  var schedules = node2.__transition, schedule2, active, empty2 = true, i;
  if (!schedules)
    return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node2.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$2(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$2(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get$2(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition2, name, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule2 = set$2(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node2) {
    return get$2(node2, id2).value[name];
  };
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color$1 ? interpolateRgb : (c = color$1(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove$2(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$2(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$2(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS$2(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction$2(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS$2(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace$1(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS$2 : attrFunction$2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS$2 : attrRemove$2)(fullname) : (fullname.local ? attrConstantNS$2 : attrConstant$2)(fullname, i, value));
}
function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace$1(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get$2(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$2(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$2(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get$2(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$2(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get$2(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function")
      throw new Error();
    set$2(this, id2).ease = v;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function")
    throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher$1(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init : set$2;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get$2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id2, i, subgroup, get$2(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll$1(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children2 = select2.call(node2, node2.__data__, i, group), child, inherit2 = get$2(node2, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection$2 = selection.prototype.constructor;
function transition_selection() {
  return new Selection$2(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue$1(this, name), string1 = (this.style.removeProperty(name), styleValue$1(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove$2(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$2(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue$1(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction$2(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue$1(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name), styleValue$1(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set$2(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove$2(name)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove$2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction$2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant$2(name, i, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}
function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant$2(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$2(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction$2(tweenValue(this, "text", value)) : textConstant$2(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get$2(node2, id0);
        schedule(node2, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule2 = set$2(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0)
      resolve();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule(node2, name, id2, i, group, timing || inherit(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const constant$3 = (x) => () => x;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target: target2,
  transform,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    transform: { value: transform, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
Transform.prototype;
function nopropagation$1(event) {
  event.stopImmediatePropagation();
}
function noevent$2(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter$1(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter$1, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable$1, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch$1("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    }, p, event);
  };
  zoom2.translateBy = function(selection2, x, y, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x, y, p, event) {
    zoom2.transform(selection2, function() {
      var e = extent.apply(this, arguments), t = this.__zoom, p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    }, p, event);
  };
  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }
  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition2, transform, point, event) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e = extent.apply(that, args), p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate2(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k = w / l[2];
          t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event)
        this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select$1(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var g = gesture(this, args).event(event), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer$1(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }
    noevent$2(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments))
      return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v = select$1(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer$1(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation$1(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();
    function mousemoved(event2) {
      noevent$2(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer$1(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag$1(event2.view, g.moved);
      noevent$2(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var t0 = this.__zoom, p0 = pointer$1(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent$2(event);
    if (duration > 0)
      select$1(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else
      select$1(this).call(zoom2.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments))
      return;
    var touches = event.touches, n = touches.length, g = gesture(this, args, event.changedTouches.length === n).event(event), started, i, t, p;
    nopropagation$1(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer$1(t, this);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchfirst = p[0], touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t, p, l;
    noevent$2(event);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = pointer$1(t, this);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming)
      return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n = touches.length, i, t;
    nopropagation$1(event);
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t = pointer$1(t, this);
        if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
          var p = select$1(this).on("dblclick.zoom");
          if (p)
            p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$3(+_), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant$3(!!_), zoom2) : filter2;
  };
  zoom2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$3(!!_), zoom2) : touchable;
  };
  zoom2.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant$3([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom2) : constrain;
  };
  zoom2.duration = function(_) {
    return arguments.length ? (duration = +_, zoom2) : duration;
  };
  zoom2.interpolate = function(_) {
    return arguments.length ? (interpolate2 = _, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_) {
    return arguments.length ? (tapDistance = +_, zoom2) : tapDistance;
  };
  return zoom2;
}
const Slots = Symbol("MiniMapSlots");
const _hoisted_1$1$1 = ["id", "x", "y", "rx", "ry", "width", "height", "fill", "stroke", "stroke-width", "shape-rendering"];
const __default__$1$1 = {
  name: "MiniMapNode",
  compatConfig: { MODE: 3 }
};
const _sfc_main$1$2 = /* @__PURE__ */ defineComponent({
  ...__default__$1$1,
  props: {
    id: {},
    type: {},
    selected: { type: Boolean },
    dragging: { type: Boolean },
    position: {},
    dimensions: {},
    borderRadius: {},
    color: {},
    shapeRendering: {},
    strokeColor: {},
    strokeWidth: {}
  },
  emits: ["click", "dblclick", "mouseenter", "mousemove", "mouseleave"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const miniMapSlots = inject(Slots);
    const attrs = useAttrs();
    const style22 = toRef(() => attrs.style ?? {});
    function onClick(event) {
      emits("click", event);
    }
    function onDblclick(event) {
      emits("dblclick", event);
    }
    function onMouseEnter(event) {
      emits("mouseenter", event);
    }
    function onMouseMove(event) {
      emits("mousemove", event);
    }
    function onMouseLeave(event) {
      emits("mouseleave", event);
    }
    return (_ctx, _cache) => {
      return unref(miniMapSlots)[`node-${props.type}`] ? (openBlock(), createBlock(resolveDynamicComponent(unref(miniMapSlots)[`node-${props.type}`]), normalizeProps(mergeProps({ key: 0 }, props)), null, 16)) : (openBlock(), createElementBlock("rect", {
        key: 1,
        id: _ctx.id,
        class: normalizeClass(["vue-flow__minimap-node", { selected: _ctx.selected, dragging: _ctx.dragging }]),
        x: _ctx.position.x,
        y: _ctx.position.y,
        rx: _ctx.borderRadius,
        ry: _ctx.borderRadius,
        width: _ctx.dimensions.width,
        height: _ctx.dimensions.height,
        fill: _ctx.color || style22.value.background || style22.value.backgroundColor,
        stroke: _ctx.strokeColor,
        "stroke-width": _ctx.strokeWidth,
        "shape-rendering": _ctx.shapeRendering,
        onClick,
        onDblclick,
        onMouseenter: onMouseEnter,
        onMousemove: onMouseMove,
        onMouseleave: onMouseLeave
      }, null, 42, _hoisted_1$1$1));
    };
  }
});
const _hoisted_1$6 = ["width", "height", "viewBox", "aria-labelledby"];
const _hoisted_2$3 = ["id"];
const _hoisted_3$2 = ["d", "fill", "stroke", "stroke-width"];
const __default__$2 = {
  name: "MiniMap",
  compatConfig: { MODE: 3 }
};
const _sfc_main$u = /* @__PURE__ */ defineComponent({
  ...__default__$2,
  props: {
    nodeColor: { type: [String, Function], default: "#e2e2e2" },
    nodeStrokeColor: { type: [String, Function], default: "transparent" },
    nodeClassName: { type: [String, Function] },
    nodeBorderRadius: { default: 5 },
    nodeStrokeWidth: { default: 2 },
    maskColor: { default: "rgb(240, 240, 240, 0.6)" },
    maskStrokeColor: { default: "none" },
    maskStrokeWidth: { default: 1 },
    position: { default: "bottom-right" },
    pannable: { type: Boolean, default: false },
    zoomable: { type: Boolean, default: false },
    width: {},
    height: {},
    ariaLabel: { default: "Vue Flow mini map" },
    inversePan: { type: Boolean, default: false },
    zoomStep: { default: 10 },
    offsetScale: { default: 5 },
    maskBorderRadius: { default: 0 }
  },
  emits: ["click", "nodeClick", "nodeDblclick", "nodeMouseenter", "nodeMousemove", "nodeMouseleave"],
  setup(__props, { emit }) {
    const slots = useSlots();
    const attrs = useAttrs();
    const defaultWidth = 200;
    const defaultHeight = 150;
    const { id: id2, edges, viewport, translateExtent, dimensions, emits, d3Selection, d3Zoom, getNodesInitialized } = useVueFlow();
    const el = ref();
    provide(Slots, slots);
    const elementWidth = toRef(() => {
      var _a;
      return __props.width ?? ((_a = attrs.style) == null ? void 0 : _a.width) ?? defaultWidth;
    });
    const elementHeight = toRef(() => {
      var _a;
      return __props.height ?? ((_a = attrs.style) == null ? void 0 : _a.height) ?? defaultHeight;
    });
    const shapeRendering = typeof window === "undefined" || !!window.chrome ? "crispEdges" : "geometricPrecision";
    const nodeColorFunc = computed(() => typeof __props.nodeColor === "string" ? () => __props.nodeColor : __props.nodeColor);
    const nodeStrokeColorFunc = computed(
      () => typeof __props.nodeStrokeColor === "string" ? () => __props.nodeStrokeColor : __props.nodeStrokeColor
    );
    const nodeClassNameFunc = computed(
      () => typeof __props.nodeClassName === "string" ? () => __props.nodeClassName : typeof __props.nodeClassName === "function" ? __props.nodeClassName : () => ""
    );
    const bb = computed(() => getRectOfNodes(getNodesInitialized.value));
    const viewBB = computed(() => ({
      x: -viewport.value.x / viewport.value.zoom,
      y: -viewport.value.y / viewport.value.zoom,
      width: dimensions.value.width / viewport.value.zoom,
      height: dimensions.value.height / viewport.value.zoom
    }));
    const boundingRect = computed(
      () => getNodesInitialized.value && getNodesInitialized.value.length ? getBoundsofRects(bb.value, viewBB.value) : viewBB.value
    );
    const viewScale = computed(() => {
      const scaledWidth = boundingRect.value.width / elementWidth.value;
      const scaledHeight = boundingRect.value.height / elementHeight.value;
      return Math.max(scaledWidth, scaledHeight);
    });
    const viewBox = computed(() => {
      const viewWidth = viewScale.value * elementWidth.value;
      const viewHeight = viewScale.value * elementHeight.value;
      const offset = __props.offsetScale * viewScale.value;
      return {
        offset,
        x: boundingRect.value.x - (viewWidth - boundingRect.value.width) / 2 - offset,
        y: boundingRect.value.y - (viewHeight - boundingRect.value.height) / 2 - offset,
        width: viewWidth + offset * 2,
        height: viewHeight + offset * 2
      };
    });
    const d = computed(() => {
      if (!viewBox.value.x || !viewBox.value.y) {
        return "";
      }
      return `
    M${viewBox.value.x - viewBox.value.offset},${viewBox.value.y - viewBox.value.offset}
    h${viewBox.value.width + viewBox.value.offset * 2}
    v${viewBox.value.height + viewBox.value.offset * 2}
    h${-viewBox.value.width - viewBox.value.offset * 2}z
    M${viewBB.value.x + __props.maskBorderRadius},${viewBB.value.y}
    h${viewBB.value.width - 2 * __props.maskBorderRadius}
    a${__props.maskBorderRadius},${__props.maskBorderRadius} 0 0 1 ${__props.maskBorderRadius},${__props.maskBorderRadius}
    v${viewBB.value.height - 2 * __props.maskBorderRadius}
    a${__props.maskBorderRadius},${__props.maskBorderRadius} 0 0 1 -${__props.maskBorderRadius},${__props.maskBorderRadius}
    h${-(viewBB.value.width - 2 * __props.maskBorderRadius)}
    a${__props.maskBorderRadius},${__props.maskBorderRadius} 0 0 1 -${__props.maskBorderRadius},-${__props.maskBorderRadius}
    v${-(viewBB.value.height - 2 * __props.maskBorderRadius)}
    a${__props.maskBorderRadius},${__props.maskBorderRadius} 0 0 1 ${__props.maskBorderRadius},-${__props.maskBorderRadius}z`;
    });
    watchEffect(
      (onCleanup) => {
        if (el.value) {
          const selection2 = select$1(el.value);
          const zoomHandler = (event) => {
            if (event.sourceEvent.type !== "wheel" || !d3Selection.value || !d3Zoom.value) {
              return;
            }
            const pinchDelta = -event.sourceEvent.deltaY * (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 2e-3) * __props.zoomStep;
            const zoom2 = viewport.value.zoom * 2 ** pinchDelta;
            d3Zoom.value.scaleTo(d3Selection.value, zoom2);
          };
          const panHandler = (event) => {
            if (event.sourceEvent.type !== "mousemove" || !d3Selection.value || !d3Zoom.value) {
              return;
            }
            const moveScale = viewScale.value * Math.max(1, viewport.value.zoom) * (__props.inversePan ? -1 : 1);
            const position2 = {
              x: viewport.value.x - event.sourceEvent.movementX * moveScale,
              y: viewport.value.y - event.sourceEvent.movementY * moveScale
            };
            const extent = [
              [0, 0],
              [dimensions.value.width, dimensions.value.height]
            ];
            const nextTransform = identity.translate(position2.x, position2.y).scale(viewport.value.zoom);
            const constrainedTransform = d3Zoom.value.constrain()(nextTransform, extent, translateExtent.value);
            d3Zoom.value.transform(d3Selection.value, constrainedTransform);
          };
          const zoomAndPanHandler = zoom().on("zoom", __props.pannable ? panHandler : () => {
          }).on("zoom.wheel", __props.zoomable ? zoomHandler : () => {
          });
          selection2.call(zoomAndPanHandler);
          onCleanup(() => {
            selection2.on("zoom", null);
          });
        }
      },
      { flush: "post" }
    );
    function onSvgClick(event) {
      const [x, y] = pointer$1(event);
      emit("click", { event, position: { x, y } });
    }
    function onNodeClick(event, node2) {
      const param = { event, node: node2, connectedEdges: getConnectedEdges([node2], edges.value) };
      emits.miniMapNodeClick(param);
      emit("nodeClick", param);
    }
    function onNodeDblClick(event, node2) {
      const param = { event, node: node2, connectedEdges: getConnectedEdges([node2], edges.value) };
      emits.miniMapNodeDoubleClick(param);
      emit("nodeDblclick", param);
    }
    function onNodeMouseEnter(event, node2) {
      const param = { event, node: node2, connectedEdges: getConnectedEdges([node2], edges.value) };
      emits.miniMapNodeMouseEnter(param);
      emit("nodeMouseenter", param);
    }
    function onNodeMouseMove(event, node2) {
      const param = { event, node: node2, connectedEdges: getConnectedEdges([node2], edges.value) };
      emits.miniMapNodeMouseMove(param);
      emit("nodeMousemove", param);
    }
    function onNodeMouseLeave(event, node2) {
      const param = { event, node: node2, connectedEdges: getConnectedEdges([node2], edges.value) };
      emits.miniMapNodeMouseLeave(param);
      emit("nodeMouseleave", param);
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$z), {
        position: _ctx.position,
        class: normalizeClass(["vue-flow__minimap", { pannable: _ctx.pannable, zoomable: _ctx.zoomable }])
      }, {
        default: withCtx(() => [
          (openBlock(), createElementBlock("svg", {
            ref_key: "el",
            ref: el,
            width: elementWidth.value,
            height: elementHeight.value,
            viewBox: [viewBox.value.x, viewBox.value.y, viewBox.value.width, viewBox.value.height].join(" "),
            role: "img",
            "aria-labelledby": `vue-flow__minimap-${unref(id2)}`,
            onClick: onSvgClick
          }, [
            _ctx.ariaLabel ? (openBlock(), createElementBlock("title", {
              key: 0,
              id: `vue-flow__minimap-${unref(id2)}`
            }, toDisplayString(_ctx.ariaLabel), 9, _hoisted_2$3)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(getNodesInitialized), (node2) => {
              return openBlock(), createBlock(_sfc_main$1$2, {
                id: node2.id,
                key: node2.id,
                position: node2.computedPosition,
                dimensions: node2.dimensions,
                selected: node2.selected,
                dragging: node2.dragging,
                style: normalizeStyle(node2.style),
                class: normalizeClass(nodeClassNameFunc.value(node2)),
                color: nodeColorFunc.value(node2),
                "border-radius": _ctx.nodeBorderRadius,
                "stroke-color": nodeStrokeColorFunc.value(node2),
                "stroke-width": _ctx.nodeStrokeWidth,
                "shape-rendering": unref(shapeRendering),
                type: node2.type,
                onClick: ($event) => onNodeClick($event, node2),
                onDblclick: ($event) => onNodeDblClick($event, node2),
                onMouseenter: ($event) => onNodeMouseEnter($event, node2),
                onMousemove: ($event) => onNodeMouseMove($event, node2),
                onMouseleave: ($event) => onNodeMouseLeave($event, node2)
              }, null, 8, ["id", "position", "dimensions", "selected", "dragging", "style", "class", "color", "border-radius", "stroke-color", "stroke-width", "shape-rendering", "type", "onClick", "onDblclick", "onMouseenter", "onMousemove", "onMouseleave"]);
            }), 128)),
            createBaseVNode("path", {
              class: "vue-flow__minimap-mask",
              d: d.value,
              fill: _ctx.maskColor,
              stroke: _ctx.maskStrokeColor,
              "stroke-width": _ctx.maskStrokeWidth,
              "fill-rule": "evenodd"
            }, null, 8, _hoisted_3$2)
          ], 8, _hoisted_1$6))
        ]),
        _: 1
      }, 8, ["position", "class"]);
    };
  }
});
function useCanvasNode() {
  const node2 = inject(CanvasNodeKey);
  const data = computed(
    () => (node2 == null ? void 0 : node2.data.value) ?? {
      id: "",
      name: "",
      subtitle: "",
      type: "",
      typeVersion: 1,
      disabled: false,
      inputs: [],
      outputs: [],
      connections: { [CanvasConnectionMode.Input]: {}, [CanvasConnectionMode.Output]: {} },
      issues: { items: [], visible: false },
      pinnedData: { count: 0, visible: false },
      execution: {
        running: false
      },
      runData: { iterations: 0, outputMap: {}, visible: false },
      render: {
        type: CanvasNodeRenderType.Default,
        options: {}
      }
    }
  );
  const id2 = computed(() => (node2 == null ? void 0 : node2.id.value) ?? "");
  const label2 = computed(() => (node2 == null ? void 0 : node2.label.value) ?? "");
  const subtitle2 = computed(() => data.value.subtitle);
  const name = computed(() => data.value.name);
  const inputs2 = computed(() => data.value.inputs);
  const outputs2 = computed(() => data.value.outputs);
  const connections2 = computed(() => data.value.connections);
  const isDisabled = computed(() => data.value.disabled);
  const isReadOnly = computed(() => node2 == null ? void 0 : node2.readOnly.value);
  const isSelected = computed(() => node2 == null ? void 0 : node2.selected.value);
  const pinnedDataCount = computed(() => data.value.pinnedData.count);
  const hasPinnedData = computed(() => data.value.pinnedData.count > 0);
  const issues2 = computed(() => data.value.issues.items ?? []);
  const hasIssues2 = computed(() => data.value.issues.visible);
  const executionStatus = computed(() => data.value.execution.status);
  const executionWaiting = computed(() => data.value.execution.waiting);
  const executionRunning = computed(() => data.value.execution.running);
  const runDataOutputMap = computed(() => data.value.runData.outputMap);
  const runDataIterations = computed(() => data.value.runData.iterations);
  const hasRunData = computed(() => data.value.runData.visible);
  const render2 = computed(() => data.value.render);
  const eventBus = computed(() => node2 == null ? void 0 : node2.eventBus.value);
  return {
    node: node2,
    id: id2,
    name,
    label: label2,
    subtitle: subtitle2,
    inputs: inputs2,
    outputs: outputs2,
    connections: connections2,
    isDisabled,
    isReadOnly,
    isSelected,
    pinnedDataCount,
    hasPinnedData,
    runDataIterations,
    runDataOutputMap,
    hasRunData,
    issues: issues2,
    hasIssues: hasIssues2,
    executionStatus,
    executionWaiting,
    executionRunning,
    render: render2,
    eventBus
  };
}
const _hoisted_1$5 = ["title"];
const _hoisted_2$2 = ["onClick"];
const _sfc_main$t = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeStickyColorSelector",
  emits: ["update"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const i18n2 = useI18n();
    const { render: render2, eventBus } = useCanvasNode();
    const renderOptions = computed(() => render2.value.options);
    const autoHideTimeout = ref(null);
    const isPopoverVisible = ref(false);
    const colors = computed(() => Array.from({ length: 7 }).map((_, index) => index + 1));
    function togglePopover() {
      isPopoverVisible.value = !isPopoverVisible.value;
    }
    function hidePopover() {
      isPopoverVisible.value = false;
    }
    function showPopover() {
      isPopoverVisible.value = true;
    }
    function changeColor(index) {
      emit("update", index);
      hidePopover();
    }
    function onMouseEnter() {
      if (autoHideTimeout.value) {
        clearTimeout(autoHideTimeout.value);
        autoHideTimeout.value = null;
      }
    }
    function onMouseLeave() {
      autoHideTimeout.value = setTimeout(() => {
        hidePopover();
      }, 1e3);
    }
    onMounted(() => {
      var _a;
      (_a = eventBus.value) == null ? void 0 : _a.on("update:sticky:color", showPopover);
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = eventBus.value) == null ? void 0 : _a.off("update:sticky:color", showPopover);
    });
    return (_ctx, _cache) => {
      const _component_FontAwesomeIcon = resolveComponent("FontAwesomeIcon");
      const _component_N8nPopover = resolveComponent("N8nPopover");
      return openBlock(), createBlock(_component_N8nPopover, {
        effect: "dark",
        trigger: "click",
        placement: "top",
        "popper-class": _ctx.$style.popover,
        "popper-style": { width: "208px" },
        visible: isPopoverVisible.value,
        teleported: false,
        onMouseenter: onMouseEnter,
        onMouseleave: onMouseLeave
      }, {
        reference: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.option),
            "data-test-id": "change-sticky-color",
            title: unref(i18n2).baseText("node.changeColor"),
            onClick: withModifiers(togglePopover, ["stop"])
          }, [
            createVNode(_component_FontAwesomeIcon, { icon: "palette" })
          ], 10, _hoisted_1$5)
        ]),
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.$style.content)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(colors.value, (color2) => {
              return openBlock(), createElementBlock("div", {
                key: color2,
                "data-test-id": "color",
                class: normalizeClass([
                  _ctx.$style.color,
                  _ctx.$style[`sticky-color-${color2}`],
                  renderOptions.value.color === color2 ? _ctx.$style.selected : ""
                ]),
                onClick: ($event) => changeColor(color2)
              }, null, 10, _hoisted_2$2);
            }), 128))
          ], 2)
        ]),
        _: 1
      }, 8, ["popper-class", "visible"]);
    };
  }
});
const popover = "_popover_11z2c_1";
const content = "_content_11z2c_7";
const color = "_color_11z2c_14";
const selected$2 = "_selected_11z2c_26";
const option = "_option_11z2c_51";
const style0$l = {
  popover,
  content,
  color,
  selected: selected$2,
  "sticky-color-1": "_sticky-color-1_11z2c_29",
  "sticky-color-2": "_sticky-color-2_11z2c_32",
  "sticky-color-3": "_sticky-color-3_11z2c_35",
  "sticky-color-4": "_sticky-color-4_11z2c_38",
  "sticky-color-5": "_sticky-color-5_11z2c_41",
  "sticky-color-6": "_sticky-color-6_11z2c_44",
  "sticky-color-7": "_sticky-color-7_11z2c_47",
  option
};
const cssModules$l = {
  "$style": style0$l
};
const __unplugin_components_0$3 = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__cssModules", cssModules$l]]);
const _sfc_main$s = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeToolbar",
  props: {
    readOnly: { type: Boolean }
  },
  emits: ["delete", "toggle", "run", "update", "open:contextmenu"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const $style = useCssModule();
    const i18n2 = useI18n();
    const { isExecuting } = useCanvas();
    const { isDisabled, render: render2 } = useCanvasNode();
    const nodeDisabledTitle = computed(() => {
      return isDisabled.value ? i18n2.baseText("node.disable") : i18n2.baseText("node.enable");
    });
    const classes = computed(() => ({
      [$style.canvasNodeToolbar]: true,
      [$style.readOnly]: props.readOnly
    }));
    const isExecuteNodeVisible = computed(() => {
      return !props.readOnly && render2.value.type === CanvasNodeRenderType.Default && "configuration" in render2.value.options && !render2.value.options.configuration;
    });
    const isDisableNodeVisible = computed(() => {
      return !props.readOnly && render2.value.type === CanvasNodeRenderType.Default;
    });
    const isDeleteNodeVisible = computed(() => !props.readOnly);
    const isStickyNoteChangeColorVisible = computed(
      () => !props.readOnly && render2.value.type === CanvasNodeRenderType.StickyNote
    );
    function executeNode() {
      emit("run");
    }
    function onToggleNode() {
      emit("toggle");
    }
    function onDeleteNode() {
      emit("delete");
    }
    function onChangeStickyColor(color2) {
      emit("update", {
        color: color2
      });
    }
    function onOpenContextMenu(event) {
      emit("open:contextmenu", event);
    }
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      const _component_CanvasNodeStickyColorSelector = __unplugin_components_0$3;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref($style).canvasNodeToolbarItems)
        }, [
          isExecuteNodeVisible.value ? (openBlock(), createBlock(_component_N8nIconButton, {
            key: 0,
            "data-test-id": "execute-node-button",
            type: "tertiary",
            text: "",
            size: "small",
            icon: "play",
            disabled: unref(isExecuting),
            title: unref(i18n2).baseText("node.testStep"),
            onClick: executeNode
          }, null, 8, ["disabled", "title"])) : createCommentVNode("", true),
          isDisableNodeVisible.value ? (openBlock(), createBlock(_component_N8nIconButton, {
            key: 1,
            "data-test-id": "disable-node-button",
            type: "tertiary",
            text: "",
            size: "small",
            icon: "power-off",
            title: nodeDisabledTitle.value,
            onClick: onToggleNode
          }, null, 8, ["title"])) : createCommentVNode("", true),
          isDeleteNodeVisible.value ? (openBlock(), createBlock(_component_N8nIconButton, {
            key: 2,
            "data-test-id": "delete-node-button",
            type: "tertiary",
            size: "small",
            text: "",
            icon: "trash",
            title: unref(i18n2).baseText("node.delete"),
            onClick: onDeleteNode
          }, null, 8, ["title"])) : createCommentVNode("", true),
          isStickyNoteChangeColorVisible.value ? (openBlock(), createBlock(_component_CanvasNodeStickyColorSelector, {
            key: 3,
            onUpdate: onChangeStickyColor
          })) : createCommentVNode("", true),
          createVNode(_component_N8nIconButton, {
            "data-test-id": "overflow-node-button",
            type: "tertiary",
            size: "small",
            text: "",
            icon: "ellipsis-h",
            onClick: onOpenContextMenu
          })
        ], 2)
      ], 2);
    };
  }
});
const canvasNodeToolbar$1 = "_canvasNodeToolbar_1rzl3_1";
const canvasNodeToolbarItems = "_canvasNodeToolbarItems_1rzl3_8";
const style0$k = {
  canvasNodeToolbar: canvasNodeToolbar$1,
  canvasNodeToolbarItems
};
const cssModules$k = {
  "$style": style0$k
};
const CanvasNodeToolbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["__cssModules", cssModules$k]]);
function useNodeConnections({
  inputs: inputs2,
  outputs: outputs2,
  connections: connections2
}) {
  const mainInputs = computed(
    () => unref(inputs2).filter((input) => input.type === NodeConnectionType.Main)
  );
  const nonMainInputs = computed(
    () => unref(inputs2).filter((input) => input.type !== NodeConnectionType.Main)
  );
  const requiredNonMainInputs = computed(
    () => nonMainInputs.value.filter((input) => input.required)
  );
  const mainInputConnections = computed(
    () => unref(connections2)[CanvasConnectionMode.Input][NodeConnectionType.Main] ?? []
  );
  const mainOutputs = computed(
    () => unref(outputs2).filter((output) => output.type === NodeConnectionType.Main)
  );
  const nonMainOutputs = computed(
    () => unref(outputs2).filter((output) => output.type !== NodeConnectionType.Main)
  );
  const mainOutputConnections = computed(
    () => unref(connections2)[CanvasConnectionMode.Output][NodeConnectionType.Main] ?? []
  );
  function isValidConnection(connection) {
    const { type: sourceType, mode: sourceMode } = parseCanvasConnectionHandleString(
      connection.sourceHandle
    );
    const { type: targetType, mode: targetMode } = parseCanvasConnectionHandleString(
      connection.targetHandle
    );
    const isSameMode = sourceMode === targetMode;
    const isSameType = sourceType === targetType;
    return !isSameMode && isSameType;
  }
  return {
    mainInputs,
    nonMainInputs,
    requiredNonMainInputs,
    mainInputConnections,
    mainOutputs,
    nonMainOutputs,
    mainOutputConnections,
    isValidConnection
  };
}
const _sfc_main$r = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeDisabledStrikeThrough",
  setup(__props) {
    const $style = useCssModule();
    const { hasRunData } = useCanvasNode();
    const classes = computed(() => {
      return {
        [$style.disabledStrikeThrough]: true,
        [$style.success]: hasRunData.value
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, null, 2);
    };
  }
});
const disabledStrikeThrough = "_disabledStrikeThrough_8cj0z_1";
const success$2 = "_success_8cj0z_10";
const style0$j = {
  disabledStrikeThrough,
  success: success$2
};
const cssModules$j = {
  "$style": style0$j
};
const CanvasNodeDisabledStrikeThrough = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__cssModules", cssModules$j]]);
const _hoisted_1$4 = { key: 1 };
const _hoisted_2$1 = ["textContent"];
const _hoisted_3$1 = { key: 3 };
const _sfc_main$q = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeStatusIcons",
  setup(__props) {
    const nodeHelpers = useNodeHelpers();
    const {
      hasPinnedData,
      issues: issues2,
      hasIssues: hasIssues2,
      executionStatus,
      executionWaiting,
      executionRunning,
      hasRunData,
      runDataIterations,
      isDisabled
    } = useCanvasNode();
    const hideNodeIssues = computed(() => false);
    return (_ctx, _cache) => {
      const _component_FontAwesomeIcon = resolveComponent("FontAwesomeIcon");
      const _component_N8nTooltip = resolveComponent("N8nTooltip");
      return unref(hasIssues2) && !hideNodeIssues.value ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.$style.status, _ctx.$style.issues]),
        "data-test-id": "node-issues"
      }, [
        createVNode(_component_N8nTooltip, {
          "show-after": 500,
          placement: "bottom"
        }, {
          content: withCtx(() => [
            createVNode(TitledList, {
              title: `${_ctx.$locale.baseText("node.issues")}:`,
              items: unref(issues2)
            }, null, 8, ["title", "items"])
          ]),
          default: withCtx(() => [
            createVNode(_component_FontAwesomeIcon, { icon: "exclamation-triangle" })
          ]),
          _: 1
        })
      ], 2)) : unref(executionWaiting) || unref(executionStatus) === "waiting" ? (openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.status, _ctx.$style.waiting])
        }, [
          createVNode(_component_N8nTooltip, { placement: "bottom" }, {
            content: withCtx(() => [
              createBaseVNode("div", {
                textContent: toDisplayString(unref(executionWaiting))
              }, null, 8, _hoisted_2$1)
            ]),
            default: withCtx(() => [
              createVNode(_component_FontAwesomeIcon, { icon: "clock" })
            ]),
            _: 1
          })
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.$style.status, _ctx.$style["node-waiting-spinner"]])
        }, [
          createVNode(_component_FontAwesomeIcon, {
            icon: "sync-alt",
            spin: ""
          })
        ], 2)
      ])) : unref(hasPinnedData) && !unref(nodeHelpers).isProductionExecutionPreview.value && !unref(isDisabled) ? (openBlock(), createElementBlock("div", {
        key: 2,
        "data-test-id": "canvas-node-status-pinned",
        class: normalizeClass([_ctx.$style.status, _ctx.$style.pinnedData])
      }, [
        createVNode(_component_FontAwesomeIcon, { icon: "thumbtack" })
      ], 2)) : unref(executionStatus) === "unknown" ? (openBlock(), createElementBlock("div", _hoisted_3$1)) : unref(executionRunning) || unref(executionStatus) === "running" ? (openBlock(), createElementBlock("div", {
        key: 4,
        "data-test-id": "canvas-node-status-running",
        class: normalizeClass([_ctx.$style.status, _ctx.$style.running])
      }, [
        createVNode(_component_FontAwesomeIcon, {
          icon: "sync-alt",
          spin: ""
        })
      ], 2)) : unref(hasRunData) ? (openBlock(), createElementBlock("div", {
        key: 5,
        "data-test-id": "canvas-node-status-success",
        class: normalizeClass([_ctx.$style.status, _ctx.$style.runData])
      }, [
        createVNode(_component_FontAwesomeIcon, { icon: "check" }),
        unref(runDataIterations) > 1 ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(_ctx.$style.count)
        }, toDisplayString(unref(runDataIterations)), 3)) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true);
    };
  }
});
const status = "_status_l067o_1";
const runData = "_runData_l067o_7";
const waiting$1 = "_waiting_l067o_12";
const pinnedData = "_pinnedData_l067o_16";
const running$1 = "_running_l067o_20";
const issues = "_issues_l067o_43";
const count = "_count_l067o_48";
const style0$i = {
  status,
  runData,
  waiting: waiting$1,
  pinnedData,
  running: running$1,
  "node-waiting-spinner": "_node-waiting-spinner_l067o_30",
  issues,
  count
};
const cssModules$i = {
  "$style": style0$i
};
const CanvasNodeStatusIcons = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["__cssModules", cssModules$i]]);
const _hoisted_1$3 = ["data-test-id"];
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeDefault",
  emits: ["open:contextmenu"],
  setup(__props, { emit: __emit }) {
    const $style = useCssModule();
    const i18n2 = useI18n();
    const emit = __emit;
    const {
      label: label2,
      subtitle: subtitle2,
      inputs: inputs2,
      outputs: outputs2,
      connections: connections2,
      isDisabled,
      isSelected,
      hasPinnedData,
      executionStatus,
      executionWaiting,
      executionRunning,
      hasRunData,
      hasIssues: hasIssues2,
      render: render2
    } = useCanvasNode();
    const {
      mainOutputs,
      mainOutputConnections,
      mainInputs,
      mainInputConnections,
      nonMainInputs,
      requiredNonMainInputs
    } = useNodeConnections({
      inputs: inputs2,
      outputs: outputs2,
      connections: connections2
    });
    const renderOptions = computed(() => render2.value.options);
    const classes = computed(() => {
      return {
        [$style.node]: true,
        [$style.selected]: isSelected.value,
        [$style.disabled]: isDisabled.value,
        [$style.success]: hasRunData.value,
        [$style.error]: hasIssues2.value,
        [$style.pinned]: hasPinnedData.value,
        [$style.waiting]: executionWaiting.value ?? executionStatus.value === "waiting",
        [$style.running]: executionRunning.value,
        [$style.configurable]: renderOptions.value.configurable,
        [$style.configuration]: renderOptions.value.configuration,
        [$style.trigger]: renderOptions.value.trigger
      };
    });
    const styles = computed(() => {
      const stylesObject = {};
      if (renderOptions.value.configurable) {
        let spacerCount = 0;
        stylesObject["--configurable-node--input-count"] = nonMainInputs.value.length + spacerCount;
      }
      stylesObject["--canvas-node--main-input-count"] = mainInputs.value.length;
      stylesObject["--canvas-node--main-output-count"] = mainOutputs.value.length;
      return stylesObject;
    });
    const dataTestId = computed(() => {
      let type = "default";
      if (renderOptions.value.configurable) {
        type = "configurable";
      } else if (renderOptions.value.configuration) {
        type = "configuration";
      } else if (renderOptions.value.trigger) {
        type = "trigger";
      }
      return `canvas-${type}-node`;
    });
    const isStrikethroughVisible = computed(() => {
      const isSingleMainInputNode = mainInputs.value.length === 1 && mainInputConnections.value.length <= 1;
      const isSingleMainOutputNode = mainOutputs.value.length === 1 && mainOutputConnections.value.length <= 1;
      return isDisabled.value && isSingleMainInputNode && isSingleMainOutputNode;
    });
    function openContextMenu(event) {
      emit("open:contextmenu", event);
    }
    return (_ctx, _cache) => {
      const _component_FontAwesomeIcon = resolveComponent("FontAwesomeIcon");
      const _directive_n8n_html = resolveDirective("n8n-html");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(styles.value),
        "data-test-id": dataTestId.value,
        onContextmenu: openContextMenu
      }, [
        renderSlot(_ctx.$slots, "default"),
        renderOptions.value.trigger ? (openBlock(), createBlock(unref(N8nTooltip), {
          key: 0,
          placement: "bottom"
        }, {
          content: withCtx(() => [
            withDirectives(createBaseVNode("span", null, null, 512), [
              [_directive_n8n_html, _ctx.$locale.baseText("node.thisIsATriggerNode")]
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", {
              class: normalizeClass(unref($style).triggerIcon)
            }, [
              createVNode(_component_FontAwesomeIcon, {
                icon: "bolt",
                size: "lg"
              })
            ], 2)
          ]),
          _: 1
        })) : createCommentVNode("", true),
        !unref(isDisabled) ? (openBlock(), createBlock(CanvasNodeStatusIcons, {
          key: 1,
          class: normalizeClass(unref($style).statusIcons)
        }, null, 8, ["class"])) : createCommentVNode("", true),
        isStrikethroughVisible.value ? (openBlock(), createBlock(CanvasNodeDisabledStrikeThrough, { key: 2 })) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(unref($style).description)
        }, [
          unref(label2) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref($style).label)
          }, toDisplayString(unref(label2)), 3)) : createCommentVNode("", true),
          unref(isDisabled) ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref($style).disabledLabel)
          }, " (" + toDisplayString(unref(i18n2).baseText("node.disabled")) + ") ", 3)) : createCommentVNode("", true),
          unref(subtitle2) ? (openBlock(), createElementBlock("div", {
            key: 2,
            class: normalizeClass(unref($style).subtitle)
          }, toDisplayString(unref(subtitle2)), 3)) : createCommentVNode("", true)
        ], 2)
      ], 46, _hoisted_1$3);
    };
  }
});
const node = "_node_ow105_1";
const trigger = "_trigger_ow105_32";
const configuration = "_configuration_ow105_35";
const statusIcons = "_statusIcons_ow105_42";
const configurable = "_configurable_ow105_45";
const description = "_description_ow105_52";
const label$5 = "_label_ow105_61";
const selected$1 = "_selected_ow105_71";
const success$1 = "_success_ow105_74";
const error = "_error_ow105_77";
const pinned = "_pinned_ow105_80";
const disabled = "_disabled_ow105_83";
const running = "_running_ow105_86";
const waiting = "_waiting_ow105_90";
const disabledLabel = "_disabledLabel_ow105_107";
const subtitle = "_subtitle_ow105_120";
const triggerIcon = "_triggerIcon_ow105_138";
const style0$h = {
  node,
  trigger,
  configuration,
  statusIcons,
  configurable,
  description,
  label: label$5,
  selected: selected$1,
  success: success$1,
  error,
  pinned,
  disabled,
  running,
  waiting,
  disabledLabel,
  subtitle,
  triggerIcon
};
const cssModules$h = {
  "$style": style0$h
};
const CanvasNodeDefault = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["__cssModules", cssModules$h]]);
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
    name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function array(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function")
    select2 = arrayAll(select2);
  else
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents.push(node2);
      }
    }
  }
  return new Selection(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node2) {
    return node2.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$1(x) {
  return function() {
    return x;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node2, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = key.call(node2, node2.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node2;
      } else {
        nodeByKeyValue.set(keyValue, node2);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node2 = nodeByKeyValue.get(keyValue)) {
      update[i] = node2;
      node2.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue.get(keyValues[i]) === node2) {
      exit[i] = node2;
    }
  }
}
function datum(node2) {
  return node2.__data__;
}
function selection_data(value, key) {
  if (!arguments.length)
    return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$1(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter)
      enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update)
      update = update.selection();
  }
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next && node2.compareDocumentPosition(next) ^ 4)
          next.parentNode.insertBefore(node2, next);
        next = node2;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node2 of this)
    ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name);
    else
      this.setAttribute(name, v);
  };
}
function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name);
    else
      this.style.setProperty(name, v, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node2, name) {
  return node2.style.getPropertyValue(name) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name];
    else
      this[name] = v;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node2, names) {
  var list = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list.add(names[i]);
}
function classedRemove(node2, names) {
  var list = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames$1(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
          this.addEventListener(o.type, o.listener = listener, o.options = options);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, options);
    o = { type: typename.type, name: typename.name, value, listener, options };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames$1(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent(node2, type, params) {
  var window2 = defaultView(node2), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params)
      event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else
      event.initEvent(type, false, false);
  }
  node2.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        yield node2;
    }
  }
}
var root = [null];
function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection_selection() {
  return this;
}
Selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection([[document.querySelector(selector2)]], [document.documentElement]) : new Selection([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent)
    event = sourceEvent2;
  return event;
}
function pointer(event, node2) {
  event = sourceEvent(event);
  if (node2 === void 0)
    node2 = event.currentTarget;
  if (node2) {
    var svg = node2.ownerSVGElement || node2;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node2.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node2.getBoundingClientRect) {
      var rect = node2.getBoundingClientRect();
      return [event.clientX - rect.left - node2.clientLeft, event.clientY - rect.top - node2.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}
function Dispatch(_) {
  this._ = _;
}
function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0)
      name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._, T = parseTypenames(typename + "", _), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _[t] = set(_[t], typename.name, callback);
      else if (callback == null)
        for (t in _)
          _[t] = set(_[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _)
      copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type))
      throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type.push({ name, value: callback });
  return type;
}
const nonpassive = { passive: false };
const nonpassivecapture = { capture: true, passive: false };
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function nodrag(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
const constant = (x) => () => x;
function DragEvent(type, {
  sourceEvent: sourceEvent2,
  subject,
  target: target2,
  identifier,
  active,
  x,
  y,
  dx,
  dy,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    subject: { value: subject, enumerable: true, configurable: true },
    target: { value: target2, enumerable: true, configurable: true },
    identifier: { value: identifier, enumerable: true, configurable: true },
    active: { value: active, enumerable: true, configurable: true },
    x: { value: x, enumerable: true, configurable: true },
    y: { value: y, enumerable: true, configurable: true },
    dx: { value: dx, enumerable: true, configurable: true },
    dy: { value: dy, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter(event) {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(event, d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var filter2 = defaultFilter, container2 = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved, nonpassive).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned(event, d) {
    if (touchending || !filter2.call(this, event, d))
      return;
    var gesture = beforestart(this, container2.call(this, event, d), event, d, "mouse");
    if (!gesture)
      return;
    select(event.view).on("mousemove.drag", mousemoved, nonpassivecapture).on("mouseup.drag", mouseupped, nonpassivecapture);
    nodrag(event.view);
    nopropagation(event);
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start", event);
  }
  function mousemoved(event) {
    noevent(event);
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag", event);
  }
  function mouseupped(event) {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent(event);
    gestures.mouse("end", event);
  }
  function touchstarted(event, d) {
    if (!filter2.call(this, event, d))
      return;
    var touches = event.changedTouches, c = container2.call(this, event, d), n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
        nopropagation(event);
        gesture("start", event, touches[i]);
      }
    }
  }
  function touchmoved(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent(event);
        gesture("drag", event, touches[i]);
      }
    }
  }
  function touchended(event) {
    var touches = event.changedTouches, n = touches.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation(event);
        gesture("end", event, touches[i]);
      }
    }
  }
  function beforestart(that, container22, event, d, identifier, touch) {
    var dispatch2 = listeners.copy(), p = pointer(touch || event, container22), dx, dy, s;
    if ((s = subject.call(that, new DragEvent("beforestart", {
      sourceEvent: event,
      target: drag2,
      identifier,
      active,
      x: p[0],
      y: p[1],
      dx: 0,
      dy: 0,
      dispatch: dispatch2
    }), d)) == null)
      return;
    dx = s.x - p[0] || 0;
    dy = s.y - p[1] || 0;
    return function gesture(type, event2, touch2) {
      var p0 = p, n;
      switch (type) {
        case "start":
          gestures[identifier] = gesture, n = active++;
          break;
        case "end":
          delete gestures[identifier], --active;
        case "drag":
          p = pointer(touch2 || event2, container22), n = active;
          break;
      }
      dispatch2.call(
        type,
        that,
        new DragEvent(type, {
          sourceEvent: event2,
          subject: s,
          target: drag2,
          identifier,
          active: n,
          x: p[0] + dx,
          y: p[1] + dy,
          dx: p[0] - p0[0],
          dy: p[1] - p0[1],
          dispatch: dispatch2
        }),
        d
      );
    };
  }
  drag2.filter = function(_) {
    return arguments.length ? (filter2 = typeof _ === "function" ? _ : constant(!!_), drag2) : filter2;
  };
  drag2.container = function(_) {
    return arguments.length ? (container2 = typeof _ === "function" ? _ : constant(_), drag2) : container2;
  };
  drag2.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag2) : subject;
  };
  drag2.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}
var ResizeControlVariant = /* @__PURE__ */ ((ResizeControlVariant2) => {
  ResizeControlVariant2["Line"] = "line";
  ResizeControlVariant2["Handle"] = "handle";
  return ResizeControlVariant2;
})(ResizeControlVariant || {});
function getDirection({ width, prevWidth, height, prevHeight, invertX, invertY }) {
  const deltaWidth = width - prevWidth;
  const deltaHeight = height - prevHeight;
  const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];
  if (deltaWidth && invertX) {
    direction[0] = direction[0] * -1;
  }
  if (deltaHeight && invertY) {
    direction[1] = direction[1] * -1;
  }
  return direction;
}
const DefaultPositions = {
  [ResizeControlVariant.Line]: "right",
  [ResizeControlVariant.Handle]: "bottom-right"
};
const StylingProperty = {
  [ResizeControlVariant.Line]: "borderColor",
  [ResizeControlVariant.Handle]: "backgroundColor"
};
const __default__$1 = {
  name: "ResizeControl",
  compatConfig: { MODE: 3 }
};
const _sfc_main$1$1 = /* @__PURE__ */ defineComponent({
  ...__default__$1,
  props: {
    nodeId: {},
    color: {},
    minWidth: { default: 10 },
    minHeight: { default: 10 },
    maxWidth: { default: Number.MAX_VALUE },
    maxHeight: { default: Number.MAX_VALUE },
    position: {},
    variant: { default: "handle" },
    shouldResize: {},
    keepAspectRatio: { type: [Boolean, Number], default: false }
  },
  emits: ["resizeStart", "resize", "resizeEnd"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const initPrevValues = { width: 0, height: 0, x: 0, y: 0 };
    const initStartValues = {
      ...initPrevValues,
      pointerX: 0,
      pointerY: 0,
      aspectRatio: 1
    };
    const { findNode, emits: triggerEmits } = useVueFlow();
    const getPointerPosition = useGetPointerPosition();
    const resizeControlRef = ref();
    let startValues = initStartValues;
    let prevValues = initPrevValues;
    const controlPosition = toRef(() => props.position ?? DefaultPositions[props.variant]);
    const positionClassNames = toRef(() => controlPosition.value.split("-"));
    const controlStyle = toRef(() => props.color ? { [StylingProperty[props.variant]]: props.color } : {});
    watchEffect((onCleanup) => {
      if (!resizeControlRef.value || !props.nodeId) {
        return;
      }
      const selection2 = select(resizeControlRef.value);
      const enableX = controlPosition.value.includes("right") || controlPosition.value.includes("left");
      const enableY = controlPosition.value.includes("bottom") || controlPosition.value.includes("top");
      const invertX = controlPosition.value.includes("left");
      const invertY = controlPosition.value.includes("top");
      const dragHandler = drag().on("start", (event) => {
        const node2 = findNode(props.nodeId);
        const { xSnapped, ySnapped } = getPointerPosition(event);
        prevValues = {
          width: (node2 == null ? void 0 : node2.dimensions.width) ?? 0,
          height: (node2 == null ? void 0 : node2.dimensions.height) ?? 0,
          x: (node2 == null ? void 0 : node2.position.x) ?? 0,
          y: (node2 == null ? void 0 : node2.position.y) ?? 0
        };
        startValues = {
          ...prevValues,
          pointerX: xSnapped,
          pointerY: ySnapped,
          aspectRatio: prevValues.width / prevValues.height
        };
        emits("resizeStart", { event, params: prevValues });
      }).on("drag", (event) => {
        var _a;
        const { xSnapped, ySnapped } = getPointerPosition(event);
        const node2 = findNode(props.nodeId);
        if (node2) {
          const changes = [];
          const {
            pointerX: startX,
            pointerY: startY,
            width: startWidth,
            height: startHeight,
            x: startNodeX,
            y: startNodeY,
            aspectRatio: startAspectRatio
          } = startValues;
          const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;
          const distX = Math.floor(enableX ? xSnapped - startX : 0);
          const distY = Math.floor(enableY ? ySnapped - startY : 0);
          let width = clamp(startWidth + (invertX ? -distX : distX), props.minWidth, props.maxWidth);
          let height = clamp(startHeight + (invertY ? -distY : distY), props.minHeight, props.maxHeight);
          if (props.keepAspectRatio) {
            const nextAspectRatio = width / height;
            let aspectRatio = startAspectRatio;
            if (typeof props.keepAspectRatio === "number" && nextAspectRatio !== props.keepAspectRatio) {
              aspectRatio = props.keepAspectRatio;
            }
            const isDiagonal = enableX && enableY;
            const isHorizontal = enableX && !enableY;
            const isVertical = enableY && !enableX;
            width = nextAspectRatio <= aspectRatio && isDiagonal || isVertical ? height * aspectRatio : width;
            height = nextAspectRatio > aspectRatio && isDiagonal || isHorizontal ? width / aspectRatio : height;
            if (width >= props.maxWidth) {
              width = props.maxWidth;
              height = props.maxWidth / aspectRatio;
            } else if (width <= props.minWidth) {
              width = props.minWidth;
              height = props.minWidth / aspectRatio;
            }
            if (height >= props.maxHeight) {
              height = props.maxHeight;
              width = props.maxHeight * aspectRatio;
            } else if (height <= props.minHeight) {
              height = props.minHeight;
              width = props.minHeight * aspectRatio;
            }
          }
          const isWidthChange = width !== prevWidth;
          const isHeightChange = height !== prevHeight;
          if (invertX || invertY) {
            const x = invertX ? startNodeX - (width - startWidth) : startNodeX;
            const y = invertY ? startNodeY - (height - startHeight) : startNodeY;
            const isXPosChange = x !== prevX && isWidthChange;
            const isYPosChange = y !== prevY && isHeightChange;
            if (isXPosChange || isYPosChange) {
              const positionChange = {
                id: node2.id,
                type: "position",
                from: node2.position,
                position: {
                  x: isXPosChange ? x : prevX,
                  y: isYPosChange ? y : prevY
                }
              };
              changes.push(positionChange);
              prevValues.x = positionChange.position.x;
              prevValues.y = positionChange.position.y;
            }
          }
          if (props.nodeId && (isWidthChange || isHeightChange)) {
            const dimensionChange = {
              id: props.nodeId,
              type: "dimensions",
              updateStyle: true,
              resizing: true,
              dimensions: {
                width,
                height
              }
            };
            changes.push(dimensionChange);
            prevValues.width = width;
            prevValues.height = height;
          }
          if (changes.length === 0) {
            return;
          }
          const direction = getDirection({
            width: prevValues.width,
            prevWidth,
            height: prevValues.height,
            prevHeight,
            invertX,
            invertY
          });
          const nextValues = { ...prevValues, direction };
          const callResize = (_a = props.shouldResize) == null ? void 0 : _a.call(props, event, nextValues);
          if (callResize === false) {
            return;
          }
          emits("resize", { event, params: nextValues });
          triggerEmits.nodesChange(changes);
        }
      }).on("end", (event) => {
        if (props.nodeId) {
          const dimensionChange = {
            id: props.nodeId,
            type: "dimensions",
            resizing: false
          };
          emits("resizeEnd", { event, params: prevValues });
          triggerEmits.nodesChange([dimensionChange]);
        }
      });
      selection2.call(dragHandler);
      onCleanup(() => {
        selection2.on(".drag", null);
      });
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "resizeControlRef",
        ref: resizeControlRef,
        class: normalizeClass(["vue-flow__resize-control nodrag", [...positionClassNames.value, _ctx.variant]]),
        style: normalizeStyle(controlStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
});
const __default__ = {
  name: "NodeResizer",
  compatConfig: { MODE: 3 },
  inheritAttrs: false
};
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  ...__default__,
  props: {
    nodeId: {},
    color: {},
    handleClassName: {},
    handleStyle: {},
    lineClassName: {},
    lineStyle: {},
    isVisible: { type: Boolean, default: true },
    minWidth: {},
    minHeight: {},
    maxWidth: {},
    maxHeight: {},
    shouldResize: {},
    keepAspectRatio: { type: [Boolean, Number] }
  },
  emits: ["resizeStart", "resize", "resizeEnd"],
  setup(__props, { emit: emits }) {
    const props = __props;
    const { findNode, emits: triggerEmits } = useVueFlow();
    const handleControls = ["top-left", "top-right", "bottom-left", "bottom-right"];
    const lineControls = ["top", "right", "bottom", "left"];
    const contextNodeId = inject(NodeId, null);
    const nodeId = toRef(() => typeof props.nodeId === "string" ? props.nodeId : contextNodeId);
    const node2 = computed(() => findNode(nodeId.value));
    watch(
      [
        () => props.minWidth,
        () => props.minHeight,
        () => props.maxWidth,
        () => props.maxHeight,
        () => {
          var _a;
          return !!((_a = node2.value) == null ? void 0 : _a.dimensions.width) && !!node2.value.dimensions.height;
        }
      ],
      ([minWidth, minHeight, maxWidth, maxHeight, isInitialized]) => {
        const n = node2.value;
        if (n && isInitialized) {
          const dimensionChange = {
            id: n.id,
            type: "dimensions",
            updateStyle: true,
            dimensions: {
              width: n.dimensions.width,
              height: n.dimensions.height
            }
          };
          if (minWidth && n.dimensions.width < minWidth) {
            dimensionChange.dimensions.width = minWidth;
          }
          if (minHeight && n.dimensions.height < minHeight) {
            dimensionChange.dimensions.height = minHeight;
          }
          if (maxWidth && n.dimensions.width > maxWidth) {
            dimensionChange.dimensions.width = maxWidth;
          }
          if (maxHeight && n.dimensions.height > maxHeight) {
            dimensionChange.dimensions.height = maxHeight;
          }
          if (dimensionChange.dimensions.width !== n.dimensions.width || dimensionChange.dimensions.height !== n.dimensions.height) {
            triggerEmits.nodesChange([dimensionChange]);
          }
        }
      },
      { flush: "post", immediate: true }
    );
    return (_ctx, _cache) => {
      return _ctx.isVisible ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        (openBlock(), createElementBlock(Fragment, null, renderList(lineControls, (c) => {
          return createVNode(_sfc_main$1$1, {
            key: c,
            class: normalizeClass(_ctx.lineClassName),
            style: normalizeStyle(_ctx.lineStyle),
            "node-id": nodeId.value,
            position: c,
            variant: unref(ResizeControlVariant).Line,
            "keep-aspect-ratio": _ctx.keepAspectRatio,
            color: _ctx.color,
            "min-width": _ctx.minWidth,
            "min-height": _ctx.minHeight,
            "max-width": _ctx.maxWidth,
            "max-height": _ctx.maxHeight,
            "should-resize": _ctx.shouldResize,
            onResizeStart: _cache[0] || (_cache[0] = ($event) => emits("resizeStart", $event)),
            onResize: _cache[1] || (_cache[1] = ($event) => emits("resize", $event)),
            onResizeEnd: _cache[2] || (_cache[2] = ($event) => emits("resizeEnd", $event))
          }, null, 8, ["class", "style", "node-id", "position", "variant", "keep-aspect-ratio", "color", "min-width", "min-height", "max-width", "max-height", "should-resize"]);
        }), 64)),
        (openBlock(), createElementBlock(Fragment, null, renderList(handleControls, (c) => {
          return createVNode(_sfc_main$1$1, {
            key: c,
            class: normalizeClass(_ctx.handleClassName),
            style: normalizeStyle(_ctx.handleStyle),
            "node-id": nodeId.value,
            position: c,
            color: _ctx.color,
            "min-width": _ctx.minWidth,
            "min-height": _ctx.minHeight,
            "max-width": _ctx.maxWidth,
            "max-height": _ctx.maxHeight,
            "should-resize": _ctx.shouldResize,
            "keep-aspect-ratio": _ctx.keepAspectRatio,
            onResizeStart: _cache[3] || (_cache[3] = ($event) => emits("resizeStart", $event)),
            onResize: _cache[4] || (_cache[4] = ($event) => emits("resize", $event)),
            onResizeEnd: _cache[5] || (_cache[5] = ($event) => emits("resizeEnd", $event))
          }, null, 8, ["class", "style", "node-id", "position", "color", "min-width", "min-height", "max-width", "max-height", "should-resize", "keep-aspect-ratio"]);
        }), 64))
      ], 64)) : createCommentVNode("", true);
    };
  }
});
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "CanvasNodeStickyNote",
  emits: ["update", "move", "dblclick", "open:contextmenu"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const $style = useCssModule();
    const { id: id2, isSelected, isReadOnly, render: render2, eventBus } = useCanvasNode();
    const renderOptions = computed(() => render2.value.options);
    const classes = computed(() => ({
      [$style.sticky]: true,
      [$style.selected]: isSelected.value,
      ["sticky--active"]: isActive.value
      // Used to increase the z-index of the sticky note when editing
    }));
    function onResize(event) {
      emit("move", {
        x: event.params.x,
        y: event.params.y
      });
      emit("update", {
        ...event.params.width ? { width: event.params.width } : {},
        ...event.params.height ? { height: event.params.height } : {}
      });
    }
    const isActive = ref(false);
    function onInputChange(value) {
      emit("update", {
        content: value
      });
    }
    function onEdit(edit) {
      isActive.value = edit;
    }
    function onDoubleClick(event) {
      emit("dblclick", event);
    }
    function onActivate() {
      onEdit(true);
    }
    function openContextMenu(event) {
      emit("open:contextmenu", event);
    }
    onMounted(() => {
      var _a;
      (_a = eventBus.value) == null ? void 0 : _a.on("update:node:active", onActivate);
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = eventBus.value) == null ? void 0 : _a.off("update:node:active", onActivate);
    });
    return (_ctx, _cache) => {
      const _component_N8nSticky = resolveComponent("N8nSticky");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(_sfc_main$o), {
          "min-height": 80,
          "min-width": 150,
          height: renderOptions.value.height,
          width: renderOptions.value.width,
          "is-visible": !unref(isReadOnly),
          onResize
        }, null, 8, ["height", "width", "is-visible"]),
        createVNode(_component_N8nSticky, mergeProps(_ctx.$attrs, {
          id: unref(id2),
          class: classes.value,
          "data-test-id": "canvas-sticky-note-node",
          height: renderOptions.value.height,
          width: renderOptions.value.width,
          "model-value": renderOptions.value.content,
          "background-color": renderOptions.value.color,
          "edit-mode": isActive.value,
          onEdit,
          onDblclick: onDoubleClick,
          "onUpdate:modelValue": onInputChange,
          onContextmenu: openContextMenu
        }), null, 16, ["id", "class", "height", "width", "model-value", "background-color", "edit-mode"])
      ], 64);
    };
  }
});
const sticky = "_sticky_ko0n2_1";
const selected = "_selected_ko0n2_8";
const style0$g = {
  sticky,
  selected
};
const cssModules$g = {
  "$style": style0$g
};
const CanvasNodeStickyNote = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__cssModules", cssModules$g]]);
const _hoisted_1$2 = ["textContent"];
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeAddNodes",
  setup(__props) {
    const nodeCreatorStore = useNodeCreatorStore();
    const isTooltipVisible = ref(false);
    onMounted(() => {
      nodeViewEventBus.on("runWorkflowButton:mouseenter", onShowTooltip);
      nodeViewEventBus.on("runWorkflowButton:mouseleave", onHideTooltip);
    });
    onBeforeUnmount(() => {
      nodeViewEventBus.off("runWorkflowButton:mouseenter", onShowTooltip);
      nodeViewEventBus.off("runWorkflowButton:mouseleave", onHideTooltip);
    });
    function onShowTooltip() {
      isTooltipVisible.value = true;
    }
    function onHideTooltip() {
      isTooltipVisible.value = false;
    }
    function onClick() {
      nodeCreatorStore.openNodeCreatorForTriggerNodes(
        NODE_CREATOR_OPEN_SOURCES.TRIGGER_PLACEHOLDER_BUTTON
      );
    }
    return (_ctx, _cache) => {
      const _component_FontAwesomeIcon = resolveComponent("FontAwesomeIcon");
      const _component_N8nTooltip = resolveComponent("N8nTooltip");
      return openBlock(), createElementBlock("div", {
        ref: "container",
        class: normalizeClass(_ctx.$style.addNodes),
        "data-test-id": "canvas-add-button"
      }, [
        createVNode(_component_N8nTooltip, {
          placement: "top",
          visible: isTooltipVisible.value,
          disabled: unref(nodeCreatorStore).showScrim,
          "popper-class": _ctx.$style.tooltip,
          "show-after": 700
        }, {
          content: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.$locale.baseText("nodeView.canvasAddButton.addATriggerNodeBeforeExecuting")), 1)
          ]),
          default: withCtx(() => [
            createBaseVNode("button", {
              class: normalizeClass(_ctx.$style.button),
              "data-test-id": "canvas-plus-button",
              onClick
            }, [
              createVNode(_component_FontAwesomeIcon, {
                icon: "plus",
                size: "lg"
              })
            ], 2)
          ]),
          _: 1
        }, 8, ["visible", "disabled", "popper-class"]),
        createBaseVNode("p", {
          class: normalizeClass(_ctx.$style.label),
          textContent: toDisplayString(_ctx.$locale.baseText("nodeView.canvasAddButton.addFirstStep"))
        }, null, 10, _hoisted_1$2)
      ], 2);
    };
  }
});
const addNodes = "_addNodes_13pm7_1";
const button = "_button_13pm7_9";
const label$4 = "_label_13pm7_30";
const style0$f = {
  addNodes,
  button,
  label: label$4
};
const cssModules$f = {
  "$style": style0$f
};
const CanvasNodeAddNodes = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__cssModules", cssModules$f]]);
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "CanvasNodeRenderer",
  setup(__props) {
    const node2 = inject(CanvasNodeKey);
    const slots = useSlots();
    const Render = () => {
      let Component;
      switch (node2 == null ? void 0 : node2.data.value.render.type) {
        case CanvasNodeRenderType.StickyNote:
          Component = CanvasNodeStickyNote;
          break;
        case CanvasNodeRenderType.AddNodes:
          Component = CanvasNodeAddNodes;
          break;
        default:
          Component = CanvasNodeDefault;
      }
      return h(Component, slots.default);
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Render);
    };
  }
});
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleRectangle",
  props: {
    handleClasses: { default: void 0 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.rectangle, _ctx.handleClasses])
      }, null, 2);
    };
  }
});
const rectangle = "_rectangle_m7e52_1";
const style0$e = {
  rectangle
};
const cssModules$e = {
  "$style": style0$e
};
const __unplugin_components_0$2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__cssModules", cssModules$e]]);
function useCanvasNodeHandle() {
  const handle2 = inject(CanvasNodeHandleKey);
  const label2 = computed(() => (handle2 == null ? void 0 : handle2.label.value) ?? "");
  const isConnected = computed(() => (handle2 == null ? void 0 : handle2.isConnected.value) ?? false);
  const isConnecting = computed(() => (handle2 == null ? void 0 : handle2.isConnecting.value) ?? false);
  const isReadOnly = computed(() => handle2 == null ? void 0 : handle2.isReadOnly.value);
  const isRequired = computed(() => handle2 == null ? void 0 : handle2.isRequired.value);
  const type = computed(() => (handle2 == null ? void 0 : handle2.type.value) ?? NodeConnectionType.Main);
  const mode = computed(() => (handle2 == null ? void 0 : handle2.mode.value) ?? CanvasConnectionMode.Input);
  const index = computed(() => (handle2 == null ? void 0 : handle2.index.value) ?? 0);
  const runData2 = computed(() => handle2 == null ? void 0 : handle2.runData.value);
  return {
    label: label2,
    isConnected,
    isConnecting,
    isReadOnly,
    isRequired,
    type,
    mode,
    index,
    runData: runData2
  };
}
const handleClasses$3 = "target";
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleMainInput",
  setup(__props) {
    const $style = useCssModule();
    const { label: label2, isRequired } = useCanvasNodeHandle();
    const classes = computed(() => ({
      "canvas-node-handle-main-input": true,
      [$style.handle]: true,
      [$style.required]: isRequired.value
    }));
    return (_ctx, _cache) => {
      const _component_CanvasHandleRectangle = __unplugin_components_0$2;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([unref($style).label])
        }, toDisplayString(unref(label2)), 3),
        createVNode(_component_CanvasHandleRectangle, { "handle-classes": handleClasses$3 })
      ], 2);
    };
  }
});
const handle$4 = "_handle_1f1io_1";
const label$3 = "_label_1f1io_8";
const required$3 = "_required_1f1io_21";
const style0$d = {
  handle: handle$4,
  label: label$3,
  required: required$3
};
const cssModules$d = {
  "$style": style0$d
};
const CanvasHandleMainInput = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__cssModules", cssModules$d]]);
const _hoisted_1$1 = ["viewBox"];
const _hoisted_2 = ["x1", "y1", "x2", "y2"];
const _hoisted_3 = ["transform"];
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandlePlus",
  props: {
    position: { default: "right" },
    handleClasses: { default: void 0 },
    plusSize: { default: 24 },
    lineSize: { default: 46 },
    type: { default: "default" }
  },
  emits: ["click:plus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const style = useCssModule();
    const classes = computed(() => [
      style.wrapper,
      style[props.position],
      style[props.type],
      props.handleClasses
    ]);
    const viewBox = computed(() => {
      switch (props.position) {
        case "bottom":
        case "top":
          return {
            width: props.plusSize,
            height: props.lineSize + props.plusSize
          };
        default:
          return {
            width: props.lineSize + props.plusSize,
            height: props.plusSize
          };
      }
    });
    const styles = computed(() => ({
      width: `${viewBox.value.width}px`,
      height: `${viewBox.value.height}px`
    }));
    const linePosition = computed(() => {
      switch (props.position) {
        case "top":
          return [
            [viewBox.value.width / 2, viewBox.value.height - props.lineSize + 1],
            [viewBox.value.width / 2, viewBox.value.height]
          ];
        case "bottom":
          return [
            [viewBox.value.width / 2, 0],
            [viewBox.value.width / 2, props.lineSize + 1]
          ];
        case "left":
          return [
            [viewBox.value.width - props.lineSize - 1, viewBox.value.height / 2],
            [viewBox.value.width, viewBox.value.height / 2]
          ];
        default:
          return [
            [0, viewBox.value.height / 2],
            [props.lineSize + 1, viewBox.value.height / 2]
          ];
      }
    });
    const plusPosition = computed(() => {
      switch (props.position) {
        case "bottom":
          return [0, viewBox.value.height - props.plusSize];
        case "top":
          return [0, 0];
        case "left":
          return [0, 0];
        default:
          return [viewBox.value.width - props.plusSize, 0];
      }
    });
    function onClick(event) {
      emit("click:plus", event);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", {
        class: normalizeClass(classes.value),
        viewBox: `0 0 ${viewBox.value.width} ${viewBox.value.height}`,
        style: normalizeStyle(styles.value)
      }, [
        createBaseVNode("line", {
          class: normalizeClass([_ctx.handleClasses, _ctx.$style.line]),
          x1: linePosition.value[0][0],
          y1: linePosition.value[0][1],
          x2: linePosition.value[1][0],
          y2: linePosition.value[1][1],
          stroke: "var(--color-foreground-xdark)",
          "stroke-width": "2"
        }, null, 10, _hoisted_2),
        createBaseVNode("g", {
          class: normalizeClass([_ctx.$style.plus, _ctx.handleClasses, "clickable"]),
          transform: `translate(${plusPosition.value[0]}, ${plusPosition.value[1]})`,
          onClick
        }, [
          createBaseVNode("rect", {
            class: normalizeClass([_ctx.handleClasses, "clickable"]),
            x: "2",
            y: "2",
            width: "20",
            height: "20",
            stroke: "var(--color-foreground-xdark)",
            "stroke-width": "2",
            rx: "4",
            fill: "var(--color-foreground-xlight)"
          }, null, 2),
          createBaseVNode("path", {
            class: normalizeClass([_ctx.handleClasses, "clickable"]),
            fill: "var(--color-foreground-xdark)",
            d: "m16.40655,10.89837l-3.30491,0l0,-3.30491c0,-0.40555 -0.32889,-0.73443 -0.73443,-0.73443l-0.73443,0c-0.40554,0 -0.73442,0.32888 -0.73442,0.73443l0,3.30491l-3.30491,0c-0.40555,0 -0.73443,0.32888 -0.73443,0.73442l0,0.73443c0,0.40554 0.32888,0.73443 0.73443,0.73443l3.30491,0l0,3.30491c0,0.40554 0.32888,0.73442 0.73442,0.73442l0.73443,0c0.40554,0 0.73443,-0.32888 0.73443,-0.73442l0,-3.30491l3.30491,0c0.40554,0 0.73442,-0.32889 0.73442,-0.73443l0,-0.73443c0,-0.40554 -0.32888,-0.73442 -0.73442,-0.73442z"
          }, null, 2)
        ], 10, _hoisted_3)
      ], 14, _hoisted_1$1);
    };
  }
});
const wrapper$1 = "_wrapper_uls3v_1";
const secondary = "_secondary_uls3v_4";
const line = "_line_uls3v_4";
const plus$1 = "_plus_uls3v_7";
const success = "_success_uls3v_13";
const style0$c = {
  wrapper: wrapper$1,
  secondary,
  line,
  plus: plus$1,
  success
};
const cssModules$c = {
  "$style": style0$c
};
const CanvasHandlePlus = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__cssModules", cssModules$c]]);
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleDot",
  props: {
    handleClasses: { default: void 0 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.dot, _ctx.handleClasses])
      }, null, 2);
    };
  }
});
const dot = "_dot_14pp2_1";
const style0$b = {
  dot
};
const cssModules$b = {
  "$style": style0$b
};
const __unplugin_components_0$1 = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__cssModules", cssModules$b]]);
const handleClasses$2 = "source";
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleMainOutput",
  emits: ["add"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const $style = useCssModule();
    const i18n2 = useI18n();
    const { render: render2 } = useCanvasNode();
    const { label: label2, isConnected, isConnecting, isReadOnly, isRequired, runData: runData2 } = useCanvasNodeHandle();
    const classes = computed(() => ({
      "canvas-node-handle-main-output": true,
      [$style.handle]: true,
      [$style.required]: isRequired.value
    }));
    const isHovered = ref(false);
    const renderOptions = computed(() => render2.value.options);
    const runDataTotal = computed(() => {
      var _a;
      return ((_a = runData2.value) == null ? void 0 : _a.total) ?? 0;
    });
    const runDataLabel2 = computed(
      () => runData2.value ? i18n2.baseText("ndv.output.items", {
        adjustToNumber: runData2.value.total,
        interpolate: { count: String(runData2.value.total) }
      }) : ""
    );
    const isHandlePlusVisible = computed(() => !isConnecting.value || isHovered.value);
    const plusType = computed(() => runDataTotal.value > 0 ? "success" : "default");
    const plusLineSize = computed(
      () => {
        var _a;
        return {
          small: 46,
          medium: 66,
          large: 80
        }[(runDataTotal.value > 0 ? "large" : (_a = renderOptions.value.outputs) == null ? void 0 : _a.labelSize) ?? "small"];
      }
    );
    function onMouseEnter() {
      isHovered.value = true;
    }
    function onMouseLeave() {
      isHovered.value = false;
    }
    function onClickAdd() {
      emit("add");
    }
    return (_ctx, _cache) => {
      const _component_CanvasHandleDot = __unplugin_components_0$1;
      const _component_CanvasHandlePlus = CanvasHandlePlus;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, [
        unref(label2) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([unref($style).label, unref($style).outputLabel])
        }, toDisplayString(unref(label2)), 3)) : unref(runData2) ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([unref($style).label, unref($style).runDataLabel])
        }, toDisplayString(runDataLabel2.value), 3)) : createCommentVNode("", true),
        createVNode(_component_CanvasHandleDot, { "handle-classes": handleClasses$2 }),
        createVNode(Transition$2, { name: "canvas-node-handle-main-output" }, {
          default: withCtx(() => [
            !unref(isConnected) && !unref(isReadOnly) ? withDirectives((openBlock(), createBlock(_component_CanvasHandlePlus, {
              key: 0,
              "data-test-id": "canvas-handle-plus",
              "line-size": plusLineSize.value,
              "handle-classes": handleClasses$2,
              type: plusType.value,
              onMouseenter: onMouseEnter,
              onMouseleave: onMouseLeave,
              "onClick:plus": onClickAdd
            }, null, 8, ["line-size", "type"])), [
              [vShow, isHandlePlusVisible.value]
            ]) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
const handle$3 = "_handle_1h8hh_1";
const label$2 = "_label_1h8hh_8";
const required$2 = "_required_1h8hh_18";
const outputLabel = "_outputLabel_1h8hh_23";
const runDataLabel = "_runDataLabel_1h8hh_31";
const style0$a = {
  handle: handle$3,
  label: label$2,
  required: required$2,
  outputLabel,
  runDataLabel
};
const cssModules$a = {
  "$style": style0$a
};
const CanvasHandleMainOutput = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__cssModules", cssModules$a]]);
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleDiamond",
  props: {
    handleClasses: { default: void 0 }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.diamond, _ctx.handleClasses])
      }, null, 2);
    };
  }
});
const diamond = "_diamond_1pjv3_1";
const style0$9 = {
  diamond
};
const cssModules$9 = {
  "$style": style0$9
};
const __unplugin_components_0 = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__cssModules", cssModules$9]]);
const handleClasses$1 = "target";
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleNonMainInput",
  emits: ["add"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const $style = useCssModule();
    const { label: label2, isConnected, isConnecting, isRequired, type } = useCanvasNodeHandle();
    const classes = computed(() => ({
      "canvas-node-handle-non-main-input": true,
      [$style.handle]: true,
      [$style.required]: isRequired.value
    }));
    const supportsMultipleConnections = computed(() => type.value === NodeConnectionType.AiTool);
    const isHandlePlusAvailable = computed(
      () => !isConnected.value || supportsMultipleConnections.value
    );
    const isHandlePlusVisible = computed(
      () => !isConnecting.value || isHovered.value || supportsMultipleConnections.value
    );
    const isHovered = ref(false);
    function onMouseEnter() {
      isHovered.value = true;
    }
    function onMouseLeave() {
      isHovered.value = false;
    }
    function onClickAdd() {
      emit("add");
    }
    return (_ctx, _cache) => {
      const _component_CanvasHandleDiamond = __unplugin_components_0;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("div", {
          class: normalizeClass([unref($style).label])
        }, toDisplayString(unref(label2)), 3),
        createVNode(_component_CanvasHandleDiamond, { "handle-classes": handleClasses$1 }),
        createVNode(Transition$2, { name: "canvas-node-handle-non-main-input" }, {
          default: withCtx(() => [
            isHandlePlusAvailable.value ? withDirectives((openBlock(), createBlock(CanvasHandlePlus, {
              key: 0,
              "handle-classes": handleClasses$1,
              type: "secondary",
              position: "bottom",
              onMouseenter: onMouseEnter,
              onMouseleave: onMouseLeave,
              "onClick:plus": onClickAdd
            }, null, 512)), [
              [vShow, isHandlePlusVisible.value]
            ]) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
const handle$2 = "_handle_6focw_1";
const label$1 = "_label_6focw_8";
const required$1 = "_required_6focw_21";
const style0$8 = {
  handle: handle$2,
  label: label$1,
  required: required$1
};
const cssModules$8 = {
  "$style": style0$8
};
const CanvasHandleNonMainInput = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__cssModules", cssModules$8]]);
const handleClasses = "source";
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "CanvasHandleNonMainOutput",
  setup(__props) {
    const $style = useCssModule();
    const { label: label2, isRequired } = useCanvasNodeHandle();
    const classes = computed(() => ({
      "canvas-node-handle-non-main-output": true,
      [$style.handle]: true,
      [$style.required]: isRequired.value
    }));
    return (_ctx, _cache) => {
      const _component_CanvasHandleDiamond = __unplugin_components_0;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref($style).label)
        }, toDisplayString(unref(label2)), 3),
        createVNode(_component_CanvasHandleDiamond, { "handle-classes": handleClasses })
      ], 2);
    };
  }
});
const handle$1 = "_handle_1q4ej_1";
const label = "_label_1q4ej_8";
const required = "_required_1q4ej_20";
const plus = "_plus_1q4ej_25";
const style0$7 = {
  handle: handle$1,
  label,
  required,
  plus
};
const cssModules$7 = {
  "$style": style0$7
};
const CanvasHandleNonMainOutput = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__cssModules", cssModules$7]]);
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "CanvasHandleRenderer",
  props: {
    handleId: {},
    connectionsCount: {},
    isConnecting: { type: Boolean },
    position: {},
    offset: {},
    type: {},
    required: { type: Boolean },
    maxConnections: {},
    index: {},
    label: {},
    mode: {},
    isReadOnly: { type: Boolean },
    isValidConnection: { type: Function }
  },
  emits: ["add"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const style = useCssModule();
    const handleType = computed(
      () => props.mode === CanvasConnectionMode.Input ? "target" : "source"
    );
    const handleClasses2 = computed(() => [style.handle, style[props.type], style[props.mode]]);
    const connectionsLimitReached = computed(() => {
      return props.maxConnections && props.connectionsCount >= props.maxConnections;
    });
    const isConnectableStart = computed(() => {
      if (connectionsLimitReached.value) return false;
      return props.mode === CanvasConnectionMode.Output || props.type !== NodeConnectionType.Main;
    });
    const isConnectableEnd = computed(() => {
      if (connectionsLimitReached.value) return false;
      return props.mode === CanvasConnectionMode.Input || props.type !== NodeConnectionType.Main;
    });
    const isConnected = computed(() => props.connectionsCount > 0);
    const { runDataOutputMap } = useCanvasNode();
    const runData2 = computed(
      () => {
        var _a;
        return props.mode === CanvasConnectionMode.Output ? (_a = runDataOutputMap.value[props.type]) == null ? void 0 : _a[props.index] : void 0;
      }
    );
    const renderTypeClasses = computed(() => [style.renderType, style[props.position]]);
    const RenderType = () => {
      let Component;
      if (props.mode === CanvasConnectionMode.Output) {
        if (props.type === NodeConnectionType.Main) {
          Component = CanvasHandleMainOutput;
        } else {
          Component = CanvasHandleNonMainOutput;
        }
      } else {
        if (props.type === NodeConnectionType.Main) {
          Component = CanvasHandleMainInput;
        } else {
          Component = CanvasHandleNonMainInput;
        }
      }
      return Component ? h(Component) : null;
    };
    function onAdd2() {
      emit("add", props.handleId);
    }
    const label2 = toRef(props, "label");
    const isConnecting = toRef(props, "isConnecting");
    const isReadOnly = toRef(props, "isReadOnly");
    const mode = toRef(props, "mode");
    const type = toRef(props, "type");
    const index = toRef(props, "index");
    const isRequired = toRef(props, "required");
    provide(CanvasNodeHandleKey, {
      label: label2,
      mode,
      type,
      index,
      runData: runData2,
      isRequired,
      isConnected,
      isConnecting,
      isReadOnly
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$f$1), mergeProps(_ctx.$attrs, {
        id: _ctx.handleId,
        class: handleClasses2.value,
        type: handleType.value,
        position: _ctx.position,
        style: _ctx.offset,
        "connectable-start": isConnectableStart.value,
        "connectable-end": isConnectableEnd.value,
        "is-valid-connection": _ctx.isValidConnection
      }), {
        default: withCtx(() => [
          createVNode(RenderType, {
            class: normalizeClass(renderTypeClasses.value),
            "is-connected": isConnected.value,
            style: normalizeStyle(_ctx.offset),
            label: label2.value,
            onAdd: onAdd2
          }, null, 8, ["class", "is-connected", "style", "label"])
        ]),
        _: 1
      }, 16, ["id", "class", "type", "position", "style", "connectable-start", "connectable-end", "is-valid-connection"]);
    };
  }
});
const handle = "_handle_3cwat_1";
const inputs = "_inputs_3cwat_14";
const main = "_main_3cwat_14";
const renderType = "_renderType_3cwat_18";
const top = "_top_3cwat_18";
const right = "_right_3cwat_22";
const left = "_left_3cwat_26";
const bottom = "_bottom_3cwat_30";
const style0$6 = {
  handle,
  inputs,
  main,
  renderType,
  top,
  right,
  left,
  bottom
};
const cssModules$6 = {
  "$style": style0$6
};
const CanvasHandleRenderer = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__cssModules", cssModules$6]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "CanvasNode",
  props: {
    id: {},
    type: {},
    selected: { type: Boolean },
    connectable: { type: [Boolean, Number, String, Function] },
    position: {},
    dimensions: {},
    label: {},
    isValidTargetPos: { type: Function },
    isValidSourcePos: { type: Function },
    parent: {},
    parentNodeId: {},
    dragging: { type: Boolean },
    resizing: { type: Boolean },
    zIndex: {},
    targetPosition: {},
    sourcePosition: {},
    dragHandle: {},
    data: {},
    events: {},
    readOnly: { type: Boolean },
    eventBus: {}
  },
  emits: ["add", "delete", "run", "select", "toggle", "activate", "open:contextmenu", "update", "move"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const nodeTypesStore = useNodeTypesStore();
    const contextMenu2 = useContextMenu();
    const { connectingHandle } = useCanvas();
    const inputs2 = computed(() => props.data.inputs);
    const outputs2 = computed(() => props.data.outputs);
    const connections2 = computed(() => props.data.connections);
    const { mainInputs, nonMainInputs, mainOutputs, nonMainOutputs, isValidConnection } = useNodeConnections({
      inputs: inputs2,
      outputs: outputs2,
      connections: connections2
    });
    const isDisabled = computed(() => props.data.disabled);
    const nodeTypeDescription = computed(() => {
      return nodeTypesStore.getNodeType(props.data.type, props.data.typeVersion);
    });
    const canvasNodeEventBus = ref(createEventBus());
    function emitCanvasNodeEvent(event) {
      if (event.ids.includes(props.id)) {
        canvasNodeEventBus.value.emit(event.action, event.payload);
      }
    }
    const mappedInputs = computed(() => {
      return [
        ...mainInputs.value.map(
          createEndpointMappingFn({
            mode: CanvasConnectionMode.Input,
            position: Position.Left,
            offsetAxis: "top"
          })
        ),
        ...nonMainInputs.value.map(
          createEndpointMappingFn({
            mode: CanvasConnectionMode.Input,
            position: Position.Bottom,
            offsetAxis: "left"
          })
        )
      ];
    });
    const mappedOutputs = computed(() => {
      return [
        ...mainOutputs.value.map(
          createEndpointMappingFn({
            mode: CanvasConnectionMode.Output,
            position: Position.Right,
            offsetAxis: "top"
          })
        ),
        ...nonMainOutputs.value.map(
          createEndpointMappingFn({
            mode: CanvasConnectionMode.Output,
            position: Position.Top,
            offsetAxis: "left"
          })
        )
      ];
    });
    const nodeIconSize = computed(
      () => "configuration" in data.value.render.options && data.value.render.options.configuration ? 30 : 40
    );
    const createEndpointMappingFn = ({
      mode,
      position: position2,
      offsetAxis
    }) => (endpoint, index, endpoints) => {
      var _a, _b, _c, _d, _e;
      const handleId = createCanvasConnectionHandleString({
        mode,
        type: endpoint.type,
        index: endpoint.index
      });
      const handleType = mode === CanvasConnectionMode.Input ? "target" : "source";
      const connectionsCount = ((_b = (_a = connections2.value[mode][endpoint.type]) == null ? void 0 : _a[endpoint.index]) == null ? void 0 : _b.length) ?? 0;
      const isConnecting = ((_c = connectingHandle.value) == null ? void 0 : _c.nodeId) === props.id && ((_d = connectingHandle.value) == null ? void 0 : _d.handleType) === handleType && ((_e = connectingHandle.value) == null ? void 0 : _e.handleId) === handleId;
      return {
        ...endpoint,
        handleId,
        connectionsCount,
        isConnecting,
        position: position2,
        offset: {
          [offsetAxis]: `${100 / (endpoints.length + 1) * (index + 1)}%`
        }
      };
    };
    function onAdd2(handle2) {
      emit("add", props.id, handle2);
    }
    function onDelete() {
      emit("delete", props.id);
    }
    function onRun() {
      emit("run", props.id);
    }
    function onDisabledToggle() {
      emit("toggle", props.id);
    }
    function onActivate() {
      emit("activate", props.id);
    }
    function onOpenContextMenuFromToolbar(event) {
      emit("open:contextmenu", props.id, event, "node-button");
    }
    function onOpenContextMenuFromNode(event) {
      emit("open:contextmenu", props.id, event, "node-right-click");
    }
    function onUpdate(parameters) {
      emit("update", props.id, parameters);
    }
    function onMove(position2) {
      emit("move", props.id, position2);
    }
    const id2 = toRef(props, "id");
    const data = toRef(props, "data");
    const label2 = toRef(props, "label");
    const selected2 = toRef(props, "selected");
    const readOnly = toRef(props, "readOnly");
    provide(CanvasNodeKey, {
      id: id2,
      data,
      label: label2,
      selected: selected2,
      readOnly,
      eventBus: canvasNodeEventBus
    });
    const showToolbar2 = computed(() => {
      const target2 = contextMenu2.target.value;
      return contextMenu2.isOpen && (target2 == null ? void 0 : target2.source) === "node-button" && target2.nodeId === id2.value;
    });
    watch(
      () => props.selected,
      (value) => {
        emit("select", props.id, value);
      }
    );
    onMounted(() => {
      var _a;
      (_a = props.eventBus) == null ? void 0 : _a.on("nodes:action", emitCanvasNodeEvent);
    });
    onBeforeUnmount(() => {
      var _a;
      (_a = props.eventBus) == null ? void 0 : _a.off("nodes:action", emitCanvasNodeEvent);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([_ctx.$style.canvasNode, { [_ctx.$style.showToolbar]: showToolbar2.value }]),
        "data-test-id": "canvas-node"
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(mappedOutputs.value, (source) => {
          return openBlock(), createBlock(CanvasHandleRenderer, mergeProps({
            key: `${source.handleId}(${source.index + 1}/${mappedOutputs.value.length})`,
            ref_for: true
          }, source, {
            mode: unref(CanvasConnectionMode).Output,
            "is-read-only": readOnly.value,
            "is-valid-connection": unref(isValidConnection),
            "data-test-id": "canvas-node-output-handle",
            onAdd: onAdd2
          }), null, 16, ["mode", "is-read-only", "is-valid-connection"]);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(mappedInputs.value, (target2) => {
          return openBlock(), createBlock(CanvasHandleRenderer, mergeProps({
            key: `${target2.handleId}(${target2.index + 1}/${mappedInputs.value.length})`,
            ref_for: true
          }, target2, {
            mode: unref(CanvasConnectionMode).Input,
            "is-read-only": readOnly.value,
            "is-valid-connection": unref(isValidConnection),
            "data-test-id": "canvas-node-input-handle",
            onAdd: onAdd2
          }), null, 16, ["mode", "is-read-only", "is-valid-connection"]);
        }), 128)),
        nodeTypeDescription.value ? (openBlock(), createBlock(CanvasNodeToolbar, {
          key: 0,
          "data-test-id": "canvas-node-toolbar",
          "read-only": readOnly.value,
          class: normalizeClass(_ctx.$style.canvasNodeToolbar),
          onDelete,
          onToggle: onDisabledToggle,
          onRun,
          onUpdate,
          "onOpen:contextmenu": onOpenContextMenuFromToolbar
        }, null, 8, ["read-only", "class"])) : createCommentVNode("", true),
        createVNode(_sfc_main$l, {
          onDblclick: withModifiers(onActivate, ["stop"]),
          onMove,
          onUpdate,
          "onOpen:contextmenu": onOpenContextMenuFromNode
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$10, {
              "node-type": nodeTypeDescription.value,
              size: nodeIconSize.value,
              shrink: false,
              disabled: isDisabled.value
            }, null, 8, ["node-type", "size", "disabled"])
          ]),
          _: 1
        })
      ], 2);
    };
  }
});
const canvasNode = "_canvasNode_1t8sb_1";
const canvasNodeToolbar = "_canvasNodeToolbar_1t8sb_1";
const showToolbar = "_showToolbar_1t8sb_1";
const style0$5 = {
  canvasNode,
  canvasNodeToolbar,
  showToolbar
};
const cssModules$5 = {
  "$style": style0$5
};
const Node = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__cssModules", cssModules$5]]);
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  __name: "CanvasEdgeToolbar",
  props: {
    type: {}
  },
  emits: ["add", "delete"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const $style = useCssModule();
    const i18n2 = useI18n();
    const classes = computed(() => ({
      [$style.canvasEdgeToolbar]: true
    }));
    const isAddButtonVisible = computed(() => props.type === NodeConnectionType.Main);
    function onAdd2() {
      emit("add");
    }
    function onDelete() {
      emit("delete");
    }
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value),
        "data-test-id": "canvas-edge-toolbar"
      }, [
        isAddButtonVisible.value ? (openBlock(), createBlock(_component_N8nIconButton, {
          key: 0,
          class: "canvas-edge-toolbar-button",
          "data-test-id": "add-connection-button",
          type: "tertiary",
          size: "small",
          icon: "plus",
          title: unref(i18n2).baseText("node.add"),
          onClick: onAdd2
        }, null, 8, ["title"])) : createCommentVNode("", true),
        createVNode(_component_N8nIconButton, {
          "data-test-id": "delete-connection-button",
          class: "canvas-edge-toolbar-button",
          type: "tertiary",
          size: "small",
          icon: "trash",
          title: unref(i18n2).baseText("node.delete"),
          onClick: onDelete
        }, null, 8, ["title"])
      ], 2);
    };
  }
});
const canvasEdgeToolbar = "_canvasEdgeToolbar_gool4_1";
const style0$4 = {
  canvasEdgeToolbar
};
const cssModules$4 = {
  "$style": style0$4
};
const CanvasEdgeToolbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__cssModules", cssModules$4]]);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "CanvasEdge",
  props: {
    id: {},
    sourceNode: {},
    targetNode: {},
    source: {},
    target: {},
    type: {},
    label: {},
    style: {},
    selected: { type: Boolean },
    sourcePosition: {},
    targetPosition: {},
    sourceHandleId: {},
    targetHandleId: {},
    animated: { type: Boolean },
    updatable: { type: Boolean },
    markerStart: {},
    markerEnd: {},
    curvature: {},
    interactionWidth: {},
    data: {},
    events: {},
    labelStyle: {},
    labelShowBg: { type: Boolean },
    labelBgStyle: {},
    labelBgPadding: {},
    labelBgBorderRadius: {},
    sourceX: {},
    sourceY: {},
    targetX: {},
    targetY: {},
    readOnly: { type: Boolean },
    hovered: { type: Boolean }
  },
  emits: ["add", "delete"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const data = toRef(props, "data");
    const { onEdgeMouseEnter, onEdgeMouseLeave } = useVueFlow();
    const isHovered = ref(false);
    onEdgeMouseEnter(({ edge: edge2 }) => {
      if (edge2.id !== props.id) return;
      isHovered.value = true;
    });
    onEdgeMouseLeave(({ edge: edge2 }) => {
      if (edge2.id !== props.id) return;
      isHovered.value = false;
    });
    const $style = useCssModule();
    const connectionType2 = computed(
      () => isValidNodeConnectionType(props.data.source.type) ? props.data.source.type : NodeConnectionType.Main
    );
    const renderToolbar = computed(() => isHovered.value && !props.readOnly);
    const isMainConnection = computed(() => data.value.source.type === NodeConnectionType.Main);
    const status2 = computed(() => props.data.status);
    const edgeColor = computed(() => {
      if (status2.value === "success") {
        return "var(--color-success)";
      } else if (status2.value === "pinned") {
        return "var(--color-secondary)";
      } else if (status2.value === "running") {
        return "var(--color-primary)";
      } else if (!isMainConnection.value) {
        return "var(--node-type-supplemental-color)";
      } else if (props.selected) {
        return "var(--color-background-dark)";
      } else {
        return "var(--color-foreground-xdark)";
      }
    });
    const edgeStyle = computed(() => ({
      ...props.style,
      ...isMainConnection.value ? {} : { strokeDasharray: "8,8" },
      strokeWidth: 2,
      stroke: isHovered.value ? "var(--color-primary)" : edgeColor.value
    }));
    const edgeLabelStyle = computed(() => ({ color: edgeColor.value }));
    const edgeToolbarStyle = computed(() => {
      const [, labelX, labelY] = path.value;
      return {
        transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`
      };
    });
    const path = computed(
      () => getCustomPath(props, {
        connectionType: connectionType2.value
      })
    );
    const connection = computed(() => ({
      source: props.source,
      target: props.target,
      sourceHandle: props.sourceHandleId,
      targetHandle: props.targetHandleId
    }));
    function onAdd2() {
      emit("add", connection.value);
    }
    function onDelete() {
      emit("delete", connection.value);
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(unref(_sfc_main$d$1), {
          id: _ctx.id,
          class: normalizeClass(unref($style).edge),
          style: normalizeStyle(edgeStyle.value),
          path: path.value[0],
          "marker-end": _ctx.markerEnd,
          "interaction-width": 40
        }, null, 8, ["id", "class", "style", "path", "marker-end"]),
        createVNode(unref(_sfc_main$3$1), null, {
          default: withCtx(() => [
            createBaseVNode("div", {
              "data-test-id": "edge-label-wrapper",
              style: normalizeStyle(edgeToolbarStyle.value),
              class: normalizeClass(unref($style).edgeLabelWrapper),
              onMouseenter: _cache[0] || (_cache[0] = ($event) => isHovered.value = true),
              onMouseleave: _cache[1] || (_cache[1] = ($event) => isHovered.value = false)
            }, [
              renderToolbar.value ? (openBlock(), createBlock(CanvasEdgeToolbar, {
                key: 0,
                type: connectionType2.value,
                onAdd: onAdd2,
                onDelete
              }, null, 8, ["type"])) : (openBlock(), createElementBlock("div", {
                key: 1,
                style: normalizeStyle(edgeLabelStyle.value),
                class: normalizeClass(unref($style).edgeLabel)
              }, toDisplayString(_ctx.label), 7))
            ], 38)
          ]),
          _: 1
        })
      ], 64);
    };
  }
});
const edge = "_edge_1nj9v_1";
const edgeLabelWrapper = "_edgeLabelWrapper_1nj9v_5";
const edgeLabel = "_edgeLabel_1nj9v_5";
const style0$3 = {
  edge,
  edgeLabelWrapper,
  edgeLabel
};
const cssModules$3 = {
  "$style": style0$3
};
const Edge = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["__cssModules", cssModules$3]]);
const useKeybindings = (keymap, options) => {
  const activeElement = useActiveElement();
  const { isCtrlKeyPressed } = useDeviceSupport();
  const isDisabled = computed(() => unref(options == null ? void 0 : options.disabled));
  const ignoreKeyPresses = computed(() => {
    if (!activeElement.value) return false;
    const active = activeElement.value;
    const isInput = ["INPUT", "TEXTAREA"].includes(active.tagName);
    const isContentEditable = active.closest("[contenteditable]") !== null;
    const isIgnoreClass = active.closest(".ignore-key-press") !== null;
    return isInput || isContentEditable || isIgnoreClass;
  });
  const normalizedKeymap = computed(
    () => Object.fromEntries(
      Object.entries(keymap.value).map(([shortcut, handler]) => {
        const shortcuts = shortcut.split("|");
        return shortcuts.map((s) => [normalizeShortcutString(s), handler]);
      }).flat()
    )
  );
  function normalizeShortcutString(shortcut) {
    return shortcut.split(/[+_-]/).map((key) => key.toLowerCase()).sort((a, b) => a.localeCompare(b)).join("+");
  }
  function toShortcutString(event) {
    const { shiftKey, altKey } = event;
    const ctrlKey = isCtrlKeyPressed(event);
    const keys = [event.key];
    const modifiers = [];
    if (shiftKey) {
      modifiers.push("shift");
    }
    if (ctrlKey) {
      modifiers.push("ctrl");
    }
    if (altKey) {
      modifiers.push("alt");
    }
    return normalizeShortcutString([...modifiers, ...keys].join("+"));
  }
  function onKeyDown2(event) {
    if (ignoreKeyPresses.value || isDisabled.value) return;
    const shortcutString = toShortcutString(event);
    const handler = normalizedKeymap.value[shortcutString];
    if (handler) {
      event.preventDefault();
      event.stopPropagation();
      handler(event);
    }
  }
  useEventListener$2(document, "keydown", onKeyDown2);
};
const _hoisted_1 = ["id"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  __name: "CanvasArrowHeadMarker",
  props: {
    id: {}
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("svg", null, [
        createBaseVNode("defs", null, [
          createBaseVNode("marker", {
            id: _ctx.id,
            viewBox: "-10 -10 20 20",
            refX: "0",
            refY: "0",
            markerWidth: "12.5",
            markerHeight: "12.5",
            markerUnits: "strokeWidth",
            orient: "auto-start-reverse"
          }, _cache[0] || (_cache[0] = [
            createBaseVNode("polyline", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              points: "-5,-4 0,0 -5,4 -5,-4",
              "stroke-width": "2",
              stroke: "context-stroke",
              fill: "context-stroke"
            }, null, -1)
          ]), 8, _hoisted_1)
        ])
      ]);
    };
  }
});
const panningKeyCode = " ";
const defaultZoom = 1;
const minimapVisibilityDelay = 1e3;
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "Canvas",
  props: {
    id: { default: "canvas" },
    nodes: { default: () => [] },
    connections: { default: () => [] },
    controlsPosition: { default: PanelPosition.BottomLeft },
    eventBus: { default: () => createEventBus() },
    readOnly: { type: Boolean, default: false },
    executing: { type: Boolean, default: false },
    keyBindings: { type: Boolean, default: true }
  },
  emits: ["update:modelValue", "update:node:position", "update:nodes:position", "update:node:active", "update:node:enabled", "update:node:selected", "update:node:name", "update:node:parameters", "click:node:add", "run:node", "delete:node", "create:node", "create:sticky", "delete:nodes", "update:nodes:enabled", "copy:nodes", "duplicate:nodes", "update:nodes:pin", "cut:nodes", "delete:connection", "create:connection:start", "create:connection", "create:connection:end", "create:connection:cancelled", "click:connection:add", "click:pane", "run:workflow", "save:workflow", "create:workflow"],
  setup(__props, { emit: __emit }) {
    const $style = useCssModule();
    const emit = __emit;
    const props = __props;
    const {
      getSelectedNodes: selectedNodes,
      addSelectedNodes,
      removeSelectedNodes,
      viewportRef,
      fitView,
      zoomIn,
      zoomOut,
      zoomTo,
      setInteractive,
      elementsSelectable,
      project,
      nodes: graphNodes,
      onPaneReady,
      findNode
    } = useVueFlow({ id: props.id, deleteKeyCode: null });
    const isPaneReady = ref(false);
    const classes = computed(() => ({
      [$style.canvas]: true,
      [$style.ready]: isPaneReady.value,
      [$style.draggable]: isPanningEnabled.value
    }));
    const disableKeyBindings = computed(() => !props.keyBindings);
    const isPanningEnabled = ref(false);
    onKeyDown(panningKeyCode, () => {
      isPanningEnabled.value = true;
    });
    onKeyUp(panningKeyCode, () => {
      isPanningEnabled.value = false;
    });
    const keyMap = computed(() => ({
      ctrl_c: emitWithSelectedNodes((ids) => emit("copy:nodes", ids)),
      enter: emitWithLastSelectedNode((id2) => onSetNodeActive(id2)),
      ctrl_a: () => addSelectedNodes(graphNodes.value),
      "+|=": async () => await onZoomIn(),
      "-|_": async () => await onZoomOut(),
      0: async () => await onResetZoom(),
      1: async () => await onFitView(),
      // @TODO implement arrow key shortcuts to modify selection
      ...props.readOnly ? {} : {
        ctrl_x: emitWithSelectedNodes((ids) => emit("cut:nodes", ids)),
        "delete|backspace": emitWithSelectedNodes((ids) => emit("delete:nodes", ids)),
        ctrl_d: emitWithSelectedNodes((ids) => emit("duplicate:nodes", ids)),
        d: emitWithSelectedNodes((ids) => emit("update:nodes:enabled", ids)),
        p: emitWithSelectedNodes((ids) => emit("update:nodes:pin", ids, "keyboard-shortcut")),
        f2: emitWithLastSelectedNode((id2) => emit("update:node:name", id2)),
        tab: () => emit("create:node", "tab"),
        shift_s: () => emit("create:sticky"),
        ctrl_alt_n: () => emit("create:workflow"),
        ctrl_enter: () => emit("run:workflow"),
        ctrl_s: () => emit("save:workflow")
      }
    }));
    useKeybindings(keyMap, { disabled: disableKeyBindings });
    const selectionKeyCode = computed(() => isPanningEnabled.value ? null : true);
    const lastSelectedNode = computed(() => selectedNodes.value[selectedNodes.value.length - 1]);
    const hasSelection = computed(() => selectedNodes.value.length > 0);
    const selectedNodeIds = computed(() => selectedNodes.value.map((node2) => node2.id));
    function onClickNodeAdd(id2, handle2) {
      emit("click:node:add", id2, handle2);
    }
    const onUpdateNodesPosition = useDebounceFn((events) => {
      emit("update:nodes:position", events);
    }, 200);
    function onUpdateNodePosition(id2, position2) {
      emit("update:node:position", id2, position2);
    }
    const isPositionChangeEvent = (event) => event.type === "position" && "position" in event;
    function onNodesChange(events) {
      const positionChangeEndEvents = events.filter(isPositionChangeEvent);
      if (positionChangeEndEvents.length > 0) {
        void onUpdateNodesPosition(positionChangeEndEvents);
      }
    }
    function onSetNodeActive(id2) {
      props.eventBus.emit("nodes:action", { ids: [id2], action: "update:node:active" });
      emit("update:node:active", id2);
    }
    function clearSelectedNodes() {
      removeSelectedNodes(selectedNodes.value);
    }
    function onSelectNode() {
      if (!lastSelectedNode.value) return;
      emit("update:node:selected", lastSelectedNode.value.id);
    }
    function onSelectNodes({ ids }) {
      clearSelectedNodes();
      addSelectedNodes(ids.map(findNode).filter(isPresent));
    }
    function onToggleNodeEnabled(id2) {
      emit("update:node:enabled", id2);
    }
    function onDeleteNode(id2) {
      emit("delete:node", id2);
    }
    function onUpdateNodeParameters(id2, parameters) {
      emit("update:node:parameters", id2, parameters);
    }
    const connectionCreated = ref(false);
    const connectingHandle = ref();
    const connectedHandle = ref();
    function onConnectStart(handle2) {
      emit("create:connection:start", handle2);
      connectingHandle.value = handle2;
      connectionCreated.value = false;
    }
    function onConnect(connection) {
      emit("create:connection", connection);
      connectedHandle.value = connection;
      connectionCreated.value = true;
    }
    function onConnectEnd(event) {
      if (connectedHandle.value) {
        emit("create:connection:end", connectedHandle.value, event);
      } else if (connectingHandle.value) {
        emit("create:connection:cancelled", connectingHandle.value, getProjectedPosition(event), event);
      }
      connectedHandle.value = void 0;
      connectingHandle.value = void 0;
    }
    function onDeleteConnection(connection) {
      emit("delete:connection", connection);
    }
    function onClickConnectionAdd(connection) {
      emit("click:connection:add", connection);
    }
    const arrowHeadMarkerId = ref("custom-arrow-head");
    function onRunNode(id2) {
      emit("run:node", id2);
    }
    function emitWithSelectedNodes(emitFn) {
      return () => {
        if (hasSelection.value) {
          emitFn(selectedNodeIds.value);
        }
      };
    }
    function emitWithLastSelectedNode(emitFn) {
      return () => {
        if (lastSelectedNode.value) {
          emitFn(lastSelectedNode.value.id);
        }
      };
    }
    const zoom2 = ref(defaultZoom);
    const isPaneMoving = ref(false);
    function getProjectedPosition(event) {
      var _a;
      const bounds = ((_a = viewportRef.value) == null ? void 0 : _a.getBoundingClientRect()) ?? { left: 0, top: 0 };
      const offsetX = (event == null ? void 0 : event.clientX) ?? 0;
      const offsetY = (event == null ? void 0 : event.clientY) ?? 0;
      return project({
        x: offsetX - bounds.left,
        y: offsetY - bounds.top
      });
    }
    function onClickPane(event) {
      emit("click:pane", getProjectedPosition(event));
    }
    async function onFitView() {
      await fitView({ maxZoom: defaultZoom, padding: 0.2 });
    }
    async function onZoomTo(zoomLevel) {
      await zoomTo(zoomLevel);
    }
    async function onZoomIn() {
      await zoomIn();
    }
    async function onZoomOut() {
      await zoomOut();
    }
    async function onResetZoom() {
      await onZoomTo(defaultZoom);
    }
    function onViewportChange(viewport) {
      zoom2.value = viewport.zoom;
    }
    function setReadonly(value) {
      setInteractive(!value);
      elementsSelectable.value = true;
    }
    function onPaneMoveStart() {
      isPaneMoving.value = true;
    }
    function onPaneMoveEnd() {
      isPaneMoving.value = false;
    }
    const contextMenu2 = useContextMenu();
    function onOpenContextMenu(event) {
      contextMenu2.open(event, {
        source: "canvas",
        nodeIds: selectedNodeIds.value
      });
    }
    function onOpenNodeContextMenu(id2, event, source) {
      if (selectedNodeIds.value.includes(id2)) {
        onOpenContextMenu(event);
      }
      contextMenu2.open(event, { source, nodeId: id2 });
    }
    function onContextMenuAction(action2, nodeIds) {
      switch (action2) {
        case "add_node":
          return emit("create:node", "context_menu");
        case "add_sticky":
          return emit("create:sticky");
        case "copy":
          return emit("copy:nodes", nodeIds);
        case "delete":
          return emit("delete:nodes", nodeIds);
        case "select_all":
          return addSelectedNodes(graphNodes.value);
        case "deselect_all":
          return clearSelectedNodes();
        case "duplicate":
          return emit("duplicate:nodes", nodeIds);
        case "toggle_pin":
          return emit("update:nodes:pin", nodeIds, "context-menu");
        case "execute":
          return emit("run:node", nodeIds[0]);
        case "toggle_activation":
          return emit("update:nodes:enabled", nodeIds);
        case "open":
          return onSetNodeActive(nodeIds[0]);
        case "rename":
          return emit("update:node:name", nodeIds[0]);
        case "change_color":
          return props.eventBus.emit("nodes:action", { ids: nodeIds, action: "update:sticky:color" });
      }
    }
    const minimapHideTimeout = ref(null);
    const isMinimapVisible = ref(false);
    function minimapNodeClassnameFn(node2) {
      var _a;
      return `minimap-node-${((_a = node2.data) == null ? void 0 : _a.render.type.replace(/\./g, "-")) ?? "default"}`;
    }
    watch(isPaneMoving, (value) => {
      if (value) {
        showMinimap();
      } else {
        hideMinimap();
      }
    });
    function showMinimap() {
      if (minimapHideTimeout.value) {
        clearTimeout(minimapHideTimeout.value);
        minimapHideTimeout.value = null;
      }
      isMinimapVisible.value = true;
    }
    function hideMinimap() {
      minimapHideTimeout.value = setTimeout(() => {
        isMinimapVisible.value = false;
      }, minimapVisibilityDelay);
    }
    function onMinimapMouseEnter() {
      showMinimap();
    }
    function onMinimapMouseLeave() {
      hideMinimap();
    }
    onMounted(() => {
      props.eventBus.on("fitView", onFitView);
      props.eventBus.on("nodes:select", onSelectNodes);
    });
    onUnmounted(() => {
      props.eventBus.off("fitView", onFitView);
      props.eventBus.off("nodes:select", onSelectNodes);
    });
    onPaneReady(async () => {
      await onFitView();
      isPaneReady.value = true;
    });
    watch(() => props.readOnly, setReadonly, {
      immediate: true
    });
    const isExecuting = toRef(props, "executing");
    provide(CanvasKey, {
      connectingHandle,
      isExecuting
    });
    return (_ctx, _cache) => {
      const _component_CanvasConnectionLine = __unplugin_components_0$4;
      const _component_CanvasControlButtons = _sfc_main$x;
      return openBlock(), createBlock(unref(_sfc_main$1$4), {
        id: _ctx.id,
        nodes: _ctx.nodes,
        edges: _ctx.connections,
        "apply-changes": false,
        "connection-line-options": { markerEnd: unref(MarkerType).ArrowClosed },
        "connection-radius": 60,
        "pan-on-scroll": "",
        "snap-to-grid": "",
        "snap-grid": [unref(GRID_SIZE), unref(GRID_SIZE)],
        "min-zoom": 0,
        "max-zoom": 4,
        class: normalizeClass(classes.value),
        "selection-key-code": selectionKeyCode.value,
        "pan-activation-key-code": panningKeyCode,
        "data-test-id": "canvas",
        onConnectStart,
        onConnect,
        onConnectEnd,
        onPaneClick: onClickPane,
        onContextmenu: onOpenContextMenu,
        onViewportChange,
        onNodesChange,
        onMoveStart: onPaneMoveStart,
        onMoveEnd: onPaneMoveEnd
      }, {
        "node-canvas-node": withCtx((canvasNodeProps) => [
          createVNode(Node, mergeProps(canvasNodeProps, {
            "read-only": _ctx.readOnly,
            "event-bus": _ctx.eventBus,
            onDelete: onDeleteNode,
            onRun: onRunNode,
            onSelect: onSelectNode,
            onToggle: onToggleNodeEnabled,
            onActivate: onSetNodeActive,
            "onOpen:contextmenu": onOpenNodeContextMenu,
            onUpdate: onUpdateNodeParameters,
            onMove: onUpdateNodePosition,
            onAdd: onClickNodeAdd
          }), null, 16, ["read-only", "event-bus"])
        ]),
        "edge-canvas-edge": withCtx((canvasEdgeProps) => [
          createVNode(Edge, mergeProps(canvasEdgeProps, {
            "marker-end": `url(#${arrowHeadMarkerId.value})`,
            "read-only": _ctx.readOnly,
            onAdd: onClickConnectionAdd,
            onDelete: onDeleteConnection
          }), null, 16, ["marker-end", "read-only"])
        ]),
        "connection-line": withCtx((connectionLineProps) => [
          createVNode(_component_CanvasConnectionLine, normalizeProps(guardReactiveProps(connectionLineProps)), null, 16)
        ]),
        default: withCtx(() => [
          createVNode(_sfc_main$8, { id: arrowHeadMarkerId.value }, null, 8, ["id"]),
          createVNode(unref(_sfc_main$v), {
            "data-test-id": "canvas-background",
            "pattern-color": "#aaa",
            gap: unref(GRID_SIZE)
          }, null, 8, ["gap"]),
          createVNode(Transition$2, { name: "minimap" }, {
            default: withCtx(() => [
              withDirectives(createVNode(unref(_sfc_main$u), {
                "data-test-id": "canvas-minimap",
                "aria-label": "n8n Minimap",
                height: 120,
                width: 200,
                position: unref(PanelPosition).BottomLeft,
                pannable: "",
                zoomable: "",
                "node-class-name": minimapNodeClassnameFn,
                "node-border-radius": 16,
                onMouseenter: onMinimapMouseEnter,
                onMouseleave: onMinimapMouseLeave
              }, null, 8, ["position"]), [
                [vShow, isMinimapVisible.value]
              ])
            ]),
            _: 1
          }),
          createVNode(_component_CanvasControlButtons, {
            "data-test-id": "canvas-controls",
            class: normalizeClass(unref($style).canvasControls),
            position: _ctx.controlsPosition,
            "show-interactive": false,
            zoom: zoom2.value,
            onZoomToFit: onFitView,
            onZoomIn,
            onZoomOut,
            onResetZoom
          }, null, 8, ["class", "position", "zoom"]),
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              createVNode(ContextMenu, { onAction: onContextMenuAction })
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["id", "nodes", "edges", "connection-line-options", "snap-grid", "class", "selection-key-code"]);
    };
  }
});
const canvas$1 = "_canvas_xh7z8_1";
const ready = "_ready_xh7z8_4";
const draggable = "_draggable_xh7z8_7";
const style0$2 = {
  canvas: canvas$1,
  ready,
  draggable
};
const cssModules$2 = {
  "$style": style0$2
};
const Canvas = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["__cssModules", cssModules$2], ["__scopeId", "data-v-b4834d98"]]);
function useCanvasMapping({
  nodes,
  connections: connections2,
  workflowObject
}) {
  const i18n2 = useI18n();
  const workflowsStore = useWorkflowsStore();
  const nodeTypesStore = useNodeTypesStore();
  const nodeHelpers = useNodeHelpers();
  function createStickyNoteRenderType(node2) {
    return {
      type: CanvasNodeRenderType.StickyNote,
      options: {
        width: node2.parameters.width,
        height: node2.parameters.height,
        color: node2.parameters.color,
        content: node2.parameters.content
      }
    };
  }
  function createAddNodesRenderType() {
    return {
      type: CanvasNodeRenderType.AddNodes,
      options: {}
    };
  }
  function createDefaultNodeRenderType(node2) {
    return {
      type: CanvasNodeRenderType.Default,
      options: {
        trigger: nodeTypesStore.isTriggerNode(node2.type),
        configuration: nodeTypesStore.isConfigNode(workflowObject.value, node2, node2.type),
        configurable: nodeTypesStore.isConfigurableNode(workflowObject.value, node2, node2.type),
        inputs: {
          labelSize: nodeInputLabelSizeById.value[node2.id]
        },
        outputs: {
          labelSize: nodeOutputLabelSizeById.value[node2.id]
        }
      }
    };
  }
  const renderTypeByNodeId = computed(
    () => nodes.value.reduce((acc, node2) => {
      switch (node2.type) {
        case `${CanvasNodeRenderType.StickyNote}`:
          acc[node2.id] = createStickyNoteRenderType(node2);
          break;
        case `${CanvasNodeRenderType.AddNodes}`:
          acc[node2.id] = createAddNodesRenderType();
          break;
        default:
          acc[node2.id] = createDefaultNodeRenderType(node2);
      }
      return acc;
    }, {}) ?? {}
  );
  const nodeSubtitleById = computed(() => {
    return nodes.value.reduce((acc, node2) => {
      try {
        const nodeTypeDescription = nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
        if (!nodeTypeDescription) {
          return acc;
        }
        const nodeSubtitle = nodeHelpers.getNodeSubtitle(node2, nodeTypeDescription, workflowObject.value) ?? "";
        if (nodeSubtitle.includes(CUSTOM_API_CALL_KEY)) {
          return acc;
        }
        acc[node2.id] = nodeSubtitle;
      } catch (e) {
      }
      return acc;
    }, {});
  });
  const nodeInputsById = computed(
    () => nodes.value.reduce((acc, node2) => {
      const nodeTypeDescription = nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
      const workflowObjectNode = workflowObject.value.getNode(node2.name);
      acc[node2.id] = workflowObjectNode && nodeTypeDescription ? mapLegacyEndpointsToCanvasConnectionPort(
        getNodeInputs(
          workflowObject.value,
          workflowObjectNode,
          nodeTypeDescription
        ),
        nodeTypeDescription.inputNames ?? []
      ) : [];
      return acc;
    }, {})
  );
  function getLabelSize(label2 = "") {
    if (label2.length <= 2) {
      return 0;
    } else if (label2.length <= 6) {
      return 1;
    } else {
      return 2;
    }
  }
  function getMaxNodePortsLabelSize(ports) {
    const labelSizes = ["small", "medium", "large"];
    const labelSizeIndexes = ports.reduce(
      (sizeAcc, input) => {
        if (input.type === NodeConnectionType.Main) {
          sizeAcc.push(getLabelSize(input.label ?? ""));
        }
        return sizeAcc;
      },
      [0]
    );
    return labelSizes[Math.max(...labelSizeIndexes)];
  }
  const nodeInputLabelSizeById = computed(
    () => nodes.value.reduce((acc, node2) => {
      acc[node2.id] = getMaxNodePortsLabelSize(nodeInputsById.value[node2.id]);
      return acc;
    }, {})
  );
  const nodeOutputLabelSizeById = computed(
    () => nodes.value.reduce((acc, node2) => {
      acc[node2.id] = getMaxNodePortsLabelSize(nodeOutputsById.value[node2.id]);
      return acc;
    }, {})
  );
  const nodeOutputsById = computed(
    () => nodes.value.reduce((acc, node2) => {
      const nodeTypeDescription = nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
      const workflowObjectNode = workflowObject.value.getNode(node2.name);
      acc[node2.id] = workflowObjectNode && nodeTypeDescription ? mapLegacyEndpointsToCanvasConnectionPort(
        getNodeOutputs(
          workflowObject.value,
          workflowObjectNode,
          nodeTypeDescription
        ),
        nodeTypeDescription.outputNames ?? []
      ) : [];
      return acc;
    }, {})
  );
  const nodePinnedDataById = computed(
    () => nodes.value.reduce((acc, node2) => {
      acc[node2.id] = workflowsStore.pinDataByNodeName(node2.name);
      return acc;
    }, {})
  );
  const nodeExecutionRunningById = computed(
    () => nodes.value.reduce((acc, node2) => {
      acc[node2.id] = workflowsStore.isNodeExecuting(node2.name);
      return acc;
    }, {})
  );
  const nodeExecutionStatusById = computed(
    () => nodes.value.reduce((acc, node2) => {
      var _a, _b, _c;
      acc[node2.id] = ((_c = (_b = (_a = workflowsStore.getWorkflowRunData) == null ? void 0 : _a[node2.name]) == null ? void 0 : _b.filter(Boolean)[0]) == null ? void 0 : _c.executionStatus) ?? "new";
      return acc;
    }, {})
  );
  const nodeExecutionRunDataById = computed(
    () => nodes.value.reduce((acc, node2) => {
      acc[node2.id] = workflowsStore.getWorkflowResultDataByNodeName(node2.name);
      return acc;
    }, {})
  );
  const nodeExecutionRunDataOutputMapById = computed(
    () => Object.keys(nodeExecutionRunDataById.value).reduce(
      (acc, nodeId) => {
        acc[nodeId] = {};
        const outputData = { iterations: 0, total: 0 };
        for (const runIteration of nodeExecutionRunDataById.value[nodeId] ?? []) {
          const data = runIteration.data ?? {};
          for (const connectionType2 of Object.keys(data)) {
            const connectionTypeData = data[connectionType2] ?? {};
            acc[nodeId][connectionType2] = acc[nodeId][connectionType2] ?? {};
            for (const outputIndex of Object.keys(connectionTypeData)) {
              const parsedOutputIndex = parseInt(outputIndex, 10);
              const connectionTypeOutputIndexData = connectionTypeData[parsedOutputIndex] ?? [];
              acc[nodeId][connectionType2][outputIndex] = acc[nodeId][connectionType2][outputIndex] ?? { ...outputData };
              acc[nodeId][connectionType2][outputIndex].iterations += 1;
              acc[nodeId][connectionType2][outputIndex].total += connectionTypeOutputIndexData.length;
            }
          }
        }
        return acc;
      },
      {}
    )
  );
  const nodeIssuesById = computed(
    () => nodes.value.reduce((acc, node2) => {
      var _a;
      const issues2 = [];
      const nodeExecutionRunData = (_a = workflowsStore.getWorkflowRunData) == null ? void 0 : _a[node2.name];
      if (nodeExecutionRunData) {
        nodeExecutionRunData.forEach((executionRunData) => {
          if (executionRunData == null ? void 0 : executionRunData.error) {
            const { message, description: description2 } = executionRunData.error;
            const issue = `${message}${description2 ? ` (${description2})` : ""}`;
            issues2.push(sanitizeHtml$1(issue));
          }
        });
      }
      if ((node2 == null ? void 0 : node2.issues) !== void 0) {
        issues2.push(...nodeIssuesToString(node2.issues, node2));
      }
      acc[node2.id] = issues2;
      return acc;
    }, {})
  );
  const nodeHasIssuesById = computed(
    () => nodes.value.reduce((acc, node2) => {
      if (["crashed", "error"].includes(nodeExecutionStatusById.value[node2.id])) {
        acc[node2.id] = true;
      } else if (nodePinnedDataById.value[node2.id]) {
        acc[node2.id] = false;
      } else {
        acc[node2.id] = Object.keys((node2 == null ? void 0 : node2.issues) ?? {}).length > 0;
      }
      return acc;
    }, {})
  );
  const nodeExecutionWaitingById = computed(
    () => nodes.value.reduce((acc, node2) => {
      var _a, _b, _c, _d;
      const isExecutionSummary = (execution) => "waitTill" in execution;
      const workflowExecution = workflowsStore.getWorkflowExecution;
      const lastNodeExecuted = (_b = (_a = workflowExecution == null ? void 0 : workflowExecution.data) == null ? void 0 : _a.resultData) == null ? void 0 : _b.lastNodeExecuted;
      if (workflowExecution && lastNodeExecuted && isExecutionSummary(workflowExecution)) {
        if (node2.name === ((_d = (_c = workflowExecution.data) == null ? void 0 : _c.resultData) == null ? void 0 : _d.lastNodeExecuted) && (workflowExecution == null ? void 0 : workflowExecution.waitTill) && !(workflowExecution == null ? void 0 : workflowExecution.finished)) {
          if (node2 && node2.type === WAIT_NODE_TYPE && ["webhook", "form"].includes(node2.parameters.resume)) {
            acc[node2.id] = node2.parameters.resume === "webhook" ? i18n2.baseText("node.theNodeIsWaitingWebhookCall") : i18n2.baseText("node.theNodeIsWaitingFormCall");
            return acc;
          }
          if ((node2 == null ? void 0 : node2.parameters.operation) === SEND_AND_WAIT_OPERATION) {
            acc[node2.id] = i18n2.baseText("node.theNodeIsWaitingUserInput");
            return acc;
          }
          const waitDate = new Date(workflowExecution.waitTill);
          if (waitDate.toISOString() === WAIT_TIME_UNLIMITED) {
            acc[node2.id] = i18n2.baseText(
              "node.theNodeIsWaitingIndefinitelyForAnIncomingWebhookCall"
            );
          }
          acc[node2.id] = i18n2.baseText("node.nodeIsWaitingTill", {
            interpolate: {
              date: waitDate.toLocaleDateString(),
              time: waitDate.toLocaleTimeString()
            }
          });
        }
      }
      return acc;
    }, {})
  );
  const additionalNodePropertiesById = computed(() => {
    const stickyNodeBaseZIndex = -100;
    const stickyNodeBoundingBoxes = nodes.value.reduce((acc, node2) => {
      if (node2.type === STICKY_NODE_TYPE) {
        const x = node2.position[0];
        const y = node2.position[1];
        const width = node2.parameters.width;
        const height = node2.parameters.height;
        acc.push({
          id: node2.id,
          x,
          y,
          width,
          height,
          area: width * height,
          zIndex: stickyNodeBaseZIndex
        });
      }
      return acc;
    }, []);
    const sortedStickyNodeBoundingBoxes = stickyNodeBoundingBoxes.sort((a, b) => b.area - a.area);
    sortedStickyNodeBoundingBoxes.forEach((node2, index) => {
      node2.zIndex = stickyNodeBaseZIndex + index;
    });
    for (let i = 0; i < sortedStickyNodeBoundingBoxes.length; i++) {
      const node1 = sortedStickyNodeBoundingBoxes[i];
      for (let j = i + 1; j < sortedStickyNodeBoundingBoxes.length; j++) {
        const node2 = sortedStickyNodeBoundingBoxes[j];
        if (checkOverlap(node1, node2)) {
          if (node1.area < node2.area && node1.zIndex <= node2.zIndex) {
            node1.zIndex = node2.zIndex + 1;
          } else if (node2.area < node1.area && node2.zIndex <= node1.zIndex) {
            node2.zIndex = node1.zIndex + 1;
          }
        }
      }
    }
    return sortedStickyNodeBoundingBoxes.reduce(
      (acc, node2) => {
        acc[node2.id] = {
          style: {
            zIndex: node2.zIndex
          }
        };
        return acc;
      },
      {}
    );
  });
  const mappedNodes = computed(() => [
    ...nodes.value.map((node2) => {
      var _a, _b;
      const inputConnections = workflowObject.value.connectionsByDestinationNode[node2.name] ?? {};
      const outputConnections = workflowObject.value.connectionsBySourceNode[node2.name] ?? {};
      const data = {
        id: node2.id,
        name: node2.name,
        subtitle: nodeSubtitleById.value[node2.id] ?? "",
        type: node2.type,
        typeVersion: node2.typeVersion,
        disabled: node2.disabled,
        inputs: nodeInputsById.value[node2.id] ?? [],
        outputs: nodeOutputsById.value[node2.id] ?? [],
        connections: {
          [CanvasConnectionMode.Input]: inputConnections,
          [CanvasConnectionMode.Output]: outputConnections
        },
        issues: {
          items: nodeIssuesById.value[node2.id],
          visible: nodeHasIssuesById.value[node2.id]
        },
        pinnedData: {
          count: ((_a = nodePinnedDataById.value[node2.id]) == null ? void 0 : _a.length) ?? 0,
          visible: !!nodePinnedDataById.value[node2.id]
        },
        execution: {
          status: nodeExecutionStatusById.value[node2.id],
          waiting: nodeExecutionWaitingById.value[node2.id],
          running: nodeExecutionRunningById.value[node2.id]
        },
        runData: {
          outputMap: nodeExecutionRunDataOutputMapById.value[node2.id],
          iterations: ((_b = nodeExecutionRunDataById.value[node2.id]) == null ? void 0 : _b.length) ?? 0,
          visible: !!nodeExecutionRunDataById.value[node2.id]
        },
        render: renderTypeByNodeId.value[node2.id] ?? { type: "default", options: {} }
      };
      return {
        id: node2.id,
        label: node2.name,
        type: "canvas-node",
        position: { x: node2.position[0], y: node2.position[1] },
        data,
        ...additionalNodePropertiesById.value[node2.id]
      };
    })
  ]);
  const mappedConnections = computed(() => {
    return mapLegacyConnectionsToCanvasConnections(connections2.value ?? [], nodes.value ?? []).map(
      (connection) => {
        const type = getConnectionType();
        const label2 = getConnectionLabel(connection);
        const data = getConnectionData(connection);
        return {
          ...connection,
          data,
          type,
          label: label2,
          animated: data.status === "running",
          markerEnd: MarkerType.ArrowClosed
        };
      }
    );
  });
  function getConnectionData(connection) {
    var _a, _b, _c;
    const fromNode = nodes.value.find((node2) => {
      var _a2;
      return node2.name === ((_a2 = connection.data) == null ? void 0 : _a2.fromNodeName);
    });
    let status2;
    if (fromNode) {
      const { type, index } = parseCanvasConnectionHandleString(connection.sourceHandle);
      const runDataTotal = ((_c = (_b = (_a = nodeExecutionRunDataOutputMapById.value[fromNode.id]) == null ? void 0 : _a[type]) == null ? void 0 : _b[index]) == null ? void 0 : _c.total) ?? 0;
      if (nodeExecutionRunningById.value[fromNode.id]) {
        status2 = "running";
      } else if (nodePinnedDataById.value[fromNode.id] && nodeExecutionRunDataById.value[fromNode.id]) {
        status2 = "pinned";
      } else if (nodeHasIssuesById.value[fromNode.id]) {
        status2 = "error";
      } else if (runDataTotal > 0) {
        status2 = "success";
      }
    }
    return {
      ...connection.data,
      status: status2
    };
  }
  function getConnectionType(_) {
    return "canvas-edge";
  }
  function getConnectionLabel(connection) {
    var _a, _b, _c, _d;
    const fromNode = nodes.value.find((node2) => {
      var _a2;
      return node2.name === ((_a2 = connection.data) == null ? void 0 : _a2.fromNodeName);
    });
    if (!fromNode) {
      return "";
    }
    if (nodePinnedDataById.value[fromNode.id]) {
      const pinnedDataCount = ((_a = nodePinnedDataById.value[fromNode.id]) == null ? void 0 : _a.length) ?? 0;
      return i18n2.baseText("ndv.output.items", {
        adjustToNumber: pinnedDataCount,
        interpolate: { count: String(pinnedDataCount) }
      });
    } else if (nodeExecutionRunDataById.value[fromNode.id]) {
      const { type, index } = parseCanvasConnectionHandleString(connection.sourceHandle);
      const runDataTotal = ((_d = (_c = (_b = nodeExecutionRunDataOutputMapById.value[fromNode.id]) == null ? void 0 : _b[type]) == null ? void 0 : _c[index]) == null ? void 0 : _d.total) ?? 0;
      return i18n2.baseText("ndv.output.items", {
        adjustToNumber: runDataTotal,
        interpolate: { count: String(runDataTotal) }
      });
    }
    return "";
  }
  return {
    additionalNodePropertiesById,
    nodeExecutionRunDataOutputMapById,
    connections: mappedConnections,
    nodes: mappedNodes
  };
}
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  ...{
    inheritAttrs: false
  },
  __name: "WorkflowCanvas",
  props: {
    id: { default: "canvas" },
    workflow: {},
    workflowObject: {},
    fallbackNodes: { default: () => [] },
    eventBus: { default: () => createEventBus() },
    readOnly: { type: Boolean },
    executing: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const $style = useCssModule();
    const workflow = toRef(props, "workflow");
    const workflowObject = toRef(props, "workflowObject");
    const nodes = computed(() => {
      const stickyNoteNodes = props.workflow.nodes.filter((node2) => node2.type === STICKY_NODE_TYPE);
      return props.workflow.nodes.length > stickyNoteNodes.length ? props.workflow.nodes : [...props.fallbackNodes, ...stickyNoteNodes];
    });
    const connections2 = computed(() => props.workflow.connections);
    const { nodes: mappedNodes, connections: mappedConnections } = useCanvasMapping({
      nodes,
      connections: connections2,
      workflowObject
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref($style).wrapper)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref($style).canvas)
        }, [
          workflow.value ? (openBlock(), createBlock(Canvas, mergeProps({
            key: 0,
            nodes: unref(mappedNodes),
            connections: unref(mappedConnections),
            "event-bus": _ctx.eventBus,
            "read-only": _ctx.readOnly
          }, _ctx.$attrs), null, 16, ["nodes", "connections", "event-bus", "read-only"])) : createCommentVNode("", true)
        ], 2),
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
});
const wrapper = "_wrapper_t1ugk_1";
const canvas = "_canvas_t1ugk_9";
const style0$1 = {
  wrapper,
  canvas
};
const cssModules$1 = {
  "$style": style0$1
};
const WorkflowCanvas = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["__cssModules", cssModules$1]]);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "CanvasRunWorkflowButton",
  props: {
    waitingForWebhook: { type: Boolean },
    executing: { type: Boolean },
    disabled: { type: Boolean }
  },
  emits: ["mouseenter", "mouseleave", "click"],
  setup(__props) {
    const props = __props;
    const i18n2 = useI18n();
    const label2 = computed(() => {
      if (!props.executing) {
        return i18n2.baseText("nodeView.runButtonText.executeWorkflow");
      }
      if (props.waitingForWebhook) {
        return i18n2.baseText("nodeView.runButtonText.waitingForTriggerEvent");
      }
      return i18n2.baseText("nodeView.runButtonText.executingWorkflow");
    });
    return (_ctx, _cache) => {
      const _component_N8nButton = resolveComponent("N8nButton");
      return openBlock(), createBlock(KeyboardShortcutTooltip, {
        label: label2.value,
        shortcut: { metaKey: true, keys: ["↵"] }
      }, {
        default: withCtx(() => [
          createVNode(_component_N8nButton, {
            loading: _ctx.executing,
            label: label2.value,
            disabled: _ctx.disabled,
            size: "large",
            icon: "flask",
            type: "primary",
            "data-test-id": "execute-workflow-button",
            onMouseenter: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("mouseenter", $event)),
            onMouseleave: _cache[1] || (_cache[1] = ($event) => _ctx.$emit("mouseleave", $event)),
            onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.$emit("click", $event), ["stop"]))
          }, null, 8, ["loading", "label", "disabled"])
        ]),
        _: 1
      }, 8, ["label"]);
    };
  }
});
function useCanvasOperations({ router }) {
  const rootStore = useRootStore();
  const workflowsStore = useWorkflowsStore();
  const credentialsStore = useCredentialsStore();
  const historyStore = useHistoryStore();
  const uiStore = useUIStore();
  const ndvStore = useNDVStore();
  const nodeTypesStore = useNodeTypesStore();
  const canvasStore = useCanvasStore();
  const settingsStore = useSettingsStore();
  const tagsStore = useTagsStore();
  const nodeCreatorStore = useNodeCreatorStore();
  const executionsStore = useExecutionsStore();
  const i18n2 = useI18n();
  const toast = useToast();
  const workflowHelpers = useWorkflowHelpers({ router });
  const nodeHelpers = useNodeHelpers();
  const telemetry = useTelemetry();
  const externalHooks = useExternalHooks();
  const clipboard = useClipboard();
  const { uniqueNodeName } = useUniqueNodeName();
  const lastClickPosition = ref([0, 0]);
  const preventOpeningNDV = !!localStorage.getItem("NodeView.preventOpeningNDV");
  const editableWorkflow = computed(() => workflowsStore.workflow);
  const editableWorkflowObject = computed(() => workflowsStore.getCurrentWorkflow());
  const triggerNodes = computed(() => {
    return workflowsStore.workflowTriggerNodes;
  });
  function updateNodesPosition(events, { trackHistory = false, trackBulk = true } = {}) {
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    events.forEach(({ id: id2, position: position2 }) => {
      updateNodePosition(id2, position2, { trackHistory });
    });
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  function updateNodePosition(id2, position2, { trackHistory = false } = {}) {
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    const oldPosition = [...node2.position];
    const newPosition = [position2.x, position2.y];
    workflowsStore.setNodePositionById(id2, newPosition);
    if (trackHistory) {
      historyStore.pushCommandToUndo(new MoveNodeCommand(node2.name, oldPosition, newPosition));
    }
  }
  function revertUpdateNodePosition(nodeName, position2) {
    const node2 = workflowsStore.getNodeByName(nodeName);
    if (!node2) {
      return;
    }
    updateNodePosition(node2.id, position2);
  }
  async function renameNode(currentName, newName, { trackHistory = false, trackBulk = true } = {}) {
    if (currentName === newName) {
      return;
    }
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    newName = uniqueNodeName(newName);
    const workflow = workflowsStore.getCurrentWorkflow(true);
    workflow.renameNode(currentName, newName);
    if (trackHistory) {
      historyStore.pushCommandToUndo(new RenameNodeCommand(currentName, newName));
    }
    workflowsStore.renameNodeSelectedAndExecution({ old: currentName, new: newName });
    workflowsStore.setNodes(Object.values(workflow.nodes));
    workflowsStore.setConnections(workflow.connectionsBySourceNode);
    const isRenamingActiveNode = ndvStore.activeNodeName === currentName;
    if (isRenamingActiveNode) {
      ndvStore.activeNodeName = newName;
    }
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  async function revertRenameNode(currentName, previousName) {
    await renameNode(currentName, previousName);
  }
  function connectAdjacentNodes(id2, { trackHistory = false } = {}) {
    var _a, _b, _c;
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    const outputConnectionsByType = workflowsStore.outgoingConnectionsByNodeName(node2.name);
    const incomingConnectionsByType = workflowsStore.incomingConnectionsByNodeName(node2.name);
    for (const [type, incomingConnectionsByInputIndex] of Object.entries(
      incomingConnectionsByType
    )) {
      for (const incomingConnection of incomingConnectionsByInputIndex.at(0) ?? []) {
        const incomingNodeId = (_a = workflowsStore.getNodeByName(incomingConnection.node)) == null ? void 0 : _a.id;
        if (!incomingNodeId) continue;
        for (const outgoingConnection of ((_b = outputConnectionsByType[type]) == null ? void 0 : _b.at(0)) ?? []) {
          const outgoingNodeId = (_c = workflowsStore.getNodeByName(outgoingConnection.node)) == null ? void 0 : _c.id;
          if (!outgoingNodeId) continue;
          if (trackHistory) {
            historyStore.pushCommandToUndo(
              new AddConnectionCommand([
                {
                  node: incomingConnection.node,
                  type,
                  index: 0
                },
                {
                  node: outgoingConnection.node,
                  type,
                  index: 0
                }
              ])
            );
          }
          createConnection({
            source: incomingNodeId,
            sourceHandle: createCanvasConnectionHandleString({
              mode: CanvasConnectionMode.Output,
              type
            }),
            target: outgoingNodeId,
            targetHandle: createCanvasConnectionHandleString({
              mode: CanvasConnectionMode.Input,
              type
            })
          });
        }
      }
    }
  }
  function deleteNode(id2, { trackHistory = false, trackBulk = true } = {}) {
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    if (uiStore.lastInteractedWithNodeId === id2) {
      uiStore.lastInteractedWithNodeId = void 0;
    }
    connectAdjacentNodes(id2, { trackHistory });
    deleteConnectionsByNodeId(id2, { trackHistory, trackBulk: false });
    workflowsStore.removeNodeExecutionDataById(id2);
    workflowsStore.removeNodeById(id2);
    if (trackHistory) {
      historyStore.pushCommandToUndo(new RemoveNodeCommand(node2));
      if (trackBulk) {
        historyStore.stopRecordingUndo();
      }
    }
    trackDeleteNode(id2);
  }
  function deleteNodes(ids, { trackHistory = true, trackBulk = true } = {}) {
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    ids.forEach((id2) => deleteNode(id2, { trackHistory, trackBulk: false }));
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  function revertDeleteNode(node2) {
    workflowsStore.addNode(node2);
  }
  function trackDeleteNode(id2) {
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    if (node2.type === STICKY_NODE_TYPE) {
      telemetry.track("User deleted workflow note", {
        workflow_id: workflowsStore.workflowId,
        is_welcome_note: node2.name === QUICKSTART_NOTE_NAME
      });
    } else {
      void externalHooks.run("node.deleteNode", { node: node2 });
      telemetry.track("User deleted node", {
        node_type: node2.type,
        workflow_id: workflowsStore.workflowId
      });
    }
  }
  function setNodeActive(id2) {
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    setNodeActiveByName(node2.name);
  }
  function setNodeActiveByName(name) {
    ndvStore.activeNodeName = name;
  }
  function setNodeParameters(id2, parameters) {
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    workflowsStore.setNodeParameters(
      {
        name: node2.name,
        value: parameters
      },
      true
    );
  }
  function setNodeSelected(id2) {
    if (!id2) {
      uiStore.lastInteractedWithNodeId = void 0;
      uiStore.lastSelectedNode = "";
      return;
    }
    const node2 = workflowsStore.getNodeById(id2);
    if (!node2) {
      return;
    }
    uiStore.lastInteractedWithNodeId = id2;
    uiStore.lastSelectedNode = node2.name;
  }
  function toggleNodesDisabled(ids, { trackHistory = true, trackBulk = true } = {}) {
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    const nodes = workflowsStore.getNodesByIds(ids);
    nodeHelpers.disableNodes(nodes, { trackHistory, trackBulk: false });
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  function revertToggleNodeDisabled(nodeName) {
    const node2 = workflowsStore.getNodeByName(nodeName);
    if (node2) {
      nodeHelpers.disableNodes([node2]);
    }
  }
  function toggleNodesPinned(ids, source, { trackHistory = true, trackBulk = true } = {}) {
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    const nodes = workflowsStore.getNodesByIds(ids);
    const nextStatePinned = nodes.some((node2) => !workflowsStore.pinDataByNodeName(node2.name));
    for (const node2 of nodes) {
      const pinnedDataForNode = usePinnedData(node2);
      if (nextStatePinned) {
        const dataToPin = useDataSchema().getInputDataWithPinned(node2);
        if (dataToPin.length !== 0) {
          pinnedDataForNode.setData(dataToPin, source);
        }
      } else {
        pinnedDataForNode.unsetData(source);
      }
    }
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  function requireNodeTypeDescription(type, version2) {
    return nodeTypesStore.getNodeType(type, version2) ?? {
      properties: [],
      displayName: type,
      name: type,
      group: [],
      description: "",
      version: version2 ?? 1,
      defaults: {},
      inputs: [],
      outputs: []
    };
  }
  async function addNodes2(nodes, options = {}) {
    let insertPosition = options.position;
    let lastAddedNode;
    const nodesWithTypeVersion = nodes.map((node2) => {
      const typeVersion = node2.typeVersion ?? resolveNodeVersion(requireNodeTypeDescription(node2.type));
      return {
        ...node2,
        typeVersion
      };
    });
    await loadNodeTypesProperties(nodesWithTypeVersion);
    if (options.trackHistory && options.trackBulk) {
      historyStore.startRecordingUndo();
    }
    for (const nodeAddData of nodesWithTypeVersion) {
      const { isAutoAdd, openDetail: openNDV, ...node2 } = nodeAddData;
      const position2 = node2.position ?? insertPosition;
      const nodeTypeDescription = requireNodeTypeDescription(node2.type, node2.typeVersion);
      try {
        lastAddedNode = addNode(
          {
            ...node2,
            position: position2
          },
          nodeTypeDescription,
          {
            ...options,
            openNDV,
            isAutoAdd
          }
        );
      } catch (error2) {
        toast.showError(error2, i18n2.baseText("error"));
        console.error(error2);
        continue;
      }
      insertPosition = [
        lastAddedNode.position[0] + NODE_SIZE * 2 + GRID_SIZE,
        lastAddedNode.position[1]
      ];
    }
    if (lastAddedNode) {
      updatePositionForNodeWithMultipleInputs(lastAddedNode);
    }
    if (options.trackHistory && options.trackBulk) {
      historyStore.stopRecordingUndo();
    }
    if (!options.keepPristine) {
      uiStore.stateIsDirty = true;
    }
  }
  function updatePositionForNodeWithMultipleInputs(node2) {
    const inputNodes = editableWorkflowObject.value.getParentNodesByDepth(node2.name, 1);
    if (inputNodes.length > 1) {
      inputNodes.slice(1).forEach((inputNode, index) => {
        const nodeUi = workflowsStore.getNodeByName(inputNode.name);
        if (!nodeUi) return;
        updateNodePosition(nodeUi.id, {
          x: nodeUi.position[0],
          y: nodeUi.position[1] + 100 * (index + 1)
        });
      });
    }
  }
  function checkMaxNodesOfTypeReached(nodeTypeDescription) {
    if (nodeTypeDescription.maxNodes !== void 0 && workflowHelpers.getNodeTypeCount(nodeTypeDescription.name) >= nodeTypeDescription.maxNodes) {
      throw new Error(
        i18n2.baseText("nodeView.showMessage.showMaxNodeTypeError.message", {
          adjustToNumber: nodeTypeDescription.maxNodes,
          interpolate: { nodeTypeDataDisplayName: nodeTypeDescription.displayName }
        })
      );
    }
  }
  function addNode(node2, nodeTypeDescription, options = {}) {
    checkMaxNodesOfTypeReached(nodeTypeDescription);
    const nodeData = resolveNodeData(node2, nodeTypeDescription);
    if (!nodeData) {
      throw new Error(i18n2.baseText("nodeViewV2.showError.failedToCreateNode"));
    }
    workflowsStore.addNode(nodeData);
    if (options.trackHistory) {
      historyStore.pushCommandToUndo(new AddNodeCommand(nodeData));
    }
    void nextTick(() => {
      workflowsStore.setNodePristine(nodeData.name, true);
      nodeHelpers.matchCredentials(nodeData);
      nodeHelpers.updateNodeParameterIssues(nodeData);
      nodeHelpers.updateNodeCredentialIssues(nodeData);
      nodeHelpers.updateNodeInputIssues(nodeData);
      if (!options.isAutoAdd) {
        createConnectionToLastInteractedWithNode(nodeData, options);
      }
      if (options.telemetry) {
        trackAddNode(nodeData, options);
      }
      if (nodeData.type !== STICKY_NODE_TYPE) {
        void externalHooks.run("nodeView.addNodeButton", { nodeTypeName: nodeData.type });
        if (options.openNDV && !preventOpeningNDV) {
          ndvStore.setActiveNodeName(nodeData.name);
        }
      }
    });
    return nodeData;
  }
  async function revertAddNode(nodeName) {
    const node2 = workflowsStore.getNodeByName(nodeName);
    if (!node2) {
      return;
    }
    deleteNode(node2.id);
  }
  function createConnectionToLastInteractedWithNode(node2, options = {}) {
    const lastInteractedWithNode = uiStore.lastInteractedWithNode;
    if (!lastInteractedWithNode) {
      return;
    }
    const lastInteractedWithNodeId = lastInteractedWithNode.id;
    const lastInteractedWithNodeConnection = uiStore.lastInteractedWithNodeConnection;
    const lastInteractedWithNodeHandle = uiStore.lastInteractedWithNodeHandle;
    if (lastInteractedWithNodeHandle) {
      const { type: connectionType2, mode } = parseCanvasConnectionHandleString(
        lastInteractedWithNodeHandle
      );
      const nodeId = node2.id;
      const nodeHandle = createCanvasConnectionHandleString({
        mode: CanvasConnectionMode.Input,
        type: connectionType2,
        index: 0
      });
      if (mode === CanvasConnectionMode.Input) {
        createConnection({
          source: nodeId,
          sourceHandle: nodeHandle,
          target: lastInteractedWithNodeId,
          targetHandle: lastInteractedWithNodeHandle
        });
      } else {
        createConnection({
          source: lastInteractedWithNodeId,
          sourceHandle: lastInteractedWithNodeHandle,
          target: nodeId,
          targetHandle: nodeHandle
        });
      }
    } else {
      createConnection({
        source: lastInteractedWithNodeId,
        sourceHandle: createCanvasConnectionHandleString({
          mode: CanvasConnectionMode.Output,
          type: NodeConnectionType.Main,
          index: 0
        }),
        target: node2.id,
        targetHandle: createCanvasConnectionHandleString({
          mode: CanvasConnectionMode.Input,
          type: NodeConnectionType.Main,
          index: 0
        })
      });
    }
    if (lastInteractedWithNodeConnection) {
      deleteConnection(lastInteractedWithNodeConnection, { trackHistory: options.trackHistory });
      const targetNode = workflowsStore.getNodeById(lastInteractedWithNodeConnection.target);
      if (targetNode) {
        createConnection({
          source: node2.id,
          sourceHandle: createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Input,
            type: NodeConnectionType.Main,
            index: 0
          }),
          target: lastInteractedWithNodeConnection.target,
          targetHandle: lastInteractedWithNodeConnection.targetHandle
        });
      }
    }
  }
  function trackAddNode(nodeData, options) {
    switch (nodeData.type) {
      case STICKY_NODE_TYPE:
        trackAddStickyNoteNode();
        break;
      default:
        trackAddDefaultNode(nodeData, options);
    }
  }
  function trackAddStickyNoteNode() {
    telemetry.trackNodesPanel("nodeView.addSticky", {
      workflow_id: workflowsStore.workflowId
    });
  }
  function trackAddDefaultNode(nodeData, options) {
    const trackProperties = {
      node_type: nodeData.type,
      node_version: nodeData.typeVersion,
      is_auto_add: options.isAutoAdd,
      workflow_id: workflowsStore.workflowId,
      drag_and_drop: options.dragAndDrop
    };
    if (uiStore.lastInteractedWithNode) {
      trackProperties.input_node_type = uiStore.lastInteractedWithNode.type;
    }
    telemetry.trackNodesPanel("nodeView.addNodeButton", trackProperties);
  }
  function resolveNodeData(node2, nodeTypeDescription) {
    const id2 = node2.id ?? v4();
    const name = node2.name ?? nodeTypeDescription.defaults.name;
    const type = nodeTypeDescription.name;
    const typeVersion = node2.typeVersion;
    const position2 = resolveNodePosition(node2, nodeTypeDescription);
    const disabled2 = node2.disabled ?? false;
    const parameters = node2.parameters ?? {};
    const nodeData = {
      ...node2,
      id: id2,
      name,
      type,
      typeVersion,
      position: position2,
      disabled: disabled2,
      parameters
    };
    resolveNodeParameters(nodeData);
    resolveNodeCredentials(nodeData, nodeTypeDescription);
    resolveNodeName(nodeData);
    resolveNodeWebhook(nodeData, nodeTypeDescription);
    return nodeData;
  }
  async function loadNodeTypesProperties(nodes) {
    const allNodeTypeDescriptions = nodeTypesStore.allNodeTypes;
    const nodesToBeFetched = [];
    allNodeTypeDescriptions.forEach((nodeTypeDescription) => {
      const nodeVersions = Array.isArray(nodeTypeDescription.version) ? nodeTypeDescription.version : [nodeTypeDescription.version];
      if (!!nodes.find(
        (n) => n.type === nodeTypeDescription.name && nodeVersions.includes(n.typeVersion)
      ) && !nodeTypeDescription.hasOwnProperty("properties")) {
        nodesToBeFetched.push({
          name: nodeTypeDescription.name,
          version: Array.isArray(nodeTypeDescription.version) ? nodeTypeDescription.version.slice(-1)[0] : nodeTypeDescription.version
        });
      }
    });
    if (nodesToBeFetched.length > 0) {
      await nodeTypesStore.getNodesInformation(nodesToBeFetched);
    }
  }
  function resolveNodeVersion(nodeTypeDescription) {
    let nodeVersion = nodeTypeDescription.defaultVersion;
    if (typeof nodeVersion === "undefined") {
      nodeVersion = Array.isArray(nodeTypeDescription.version) ? nodeTypeDescription.version.slice(-1)[0] : nodeTypeDescription.version;
    }
    return nodeVersion;
  }
  function resolveNodeParameters(node2) {
    const nodeType = nodeTypesStore.getNodeType(node2.type, node2.typeVersion);
    const nodeParameters = getNodeParameters(
      (nodeType == null ? void 0 : nodeType.properties) ?? [],
      node2.parameters,
      true,
      false,
      node2
    );
    node2.parameters = nodeParameters ?? {};
  }
  function resolveNodeCredentials(node2, nodeTypeDescription) {
    var _a, _b, _c, _d;
    const credentialPerType = (_a = nodeTypeDescription.credentials) == null ? void 0 : _a.map((type) => credentialsStore.getUsableCredentialByType(type.name)).flat();
    if ((credentialPerType == null ? void 0 : credentialPerType.length) === 1) {
      const defaultCredential = credentialPerType[0];
      const selectedCredentials = credentialsStore.getCredentialById(defaultCredential.id);
      const selected2 = { id: selectedCredentials.id, name: selectedCredentials.name };
      const credentials = {
        [defaultCredential.type]: selected2
      };
      if (nodeTypeDescription.credentials) {
        const authentication = nodeTypeDescription.credentials.find(
          (type) => type.name === defaultCredential.type
        );
        const authDisplayOptionsHide = (_b = authentication == null ? void 0 : authentication.displayOptions) == null ? void 0 : _b.hide;
        const authDisplayOptionsShow = (_c = authentication == null ? void 0 : authentication.displayOptions) == null ? void 0 : _c.show;
        if (!authDisplayOptionsHide) {
          if (!authDisplayOptionsShow) {
            node2.credentials = credentials;
          } else if (Object.keys(authDisplayOptionsShow).length === 1 && authDisplayOptionsShow.authentication) {
            node2.credentials = credentials;
            let parameters = {};
            for (const displayOption of Object.keys(authDisplayOptionsShow)) {
              if (node2.parameters && !node2.parameters[displayOption]) {
                parameters = {};
                node2.credentials = void 0;
                break;
              }
              const optionValue = (_d = authDisplayOptionsShow[displayOption]) == null ? void 0 : _d[0];
              if (optionValue && typeof optionValue === "string") {
                parameters[displayOption] = optionValue;
              }
              node2.parameters = {
                ...node2.parameters,
                ...parameters
              };
            }
          }
        }
      }
    }
  }
  function resolveNodePosition(node2, nodeTypeDescription) {
    let position2 = node2.position;
    let pushOffsets = [40, 40];
    if (position2) {
      return getNewNodePosition(workflowsStore.allNodes, position2, pushOffsets);
    }
    const lastInteractedWithNode = uiStore.lastInteractedWithNode;
    const lastInteractedWithNodeConnection = uiStore.lastInteractedWithNodeConnection;
    const lastInteractedWithNodeHandle = uiStore.lastInteractedWithNodeHandle;
    const { type: connectionType2, index: connectionIndex } = parseCanvasConnectionHandleString(
      lastInteractedWithNodeHandle ?? (lastInteractedWithNodeConnection == null ? void 0 : lastInteractedWithNodeConnection.sourceHandle) ?? ""
    );
    const nodeSize = connectionType2 === NodeConnectionType.Main ? DEFAULT_NODE_SIZE : CONFIGURATION_NODE_SIZE;
    if (lastInteractedWithNode) {
      const lastInteractedWithNodeTypeDescription = nodeTypesStore.getNodeType(
        lastInteractedWithNode.type,
        lastInteractedWithNode.typeVersion
      );
      const lastInteractedWithNodeObject = editableWorkflowObject.value.getNode(
        lastInteractedWithNode.name
      );
      const newNodeInsertPosition = uiStore.lastCancelledConnectionPosition;
      if (newNodeInsertPosition) {
        const xOffset = connectionType2 === NodeConnectionType.Main ? 0 : -nodeSize[0] / 2;
        const yOffset = connectionType2 === NodeConnectionType.Main ? -nodeSize[1] / 2 : 0;
        position2 = [newNodeInsertPosition[0] + xOffset, newNodeInsertPosition[1] + yOffset];
        uiStore.lastCancelledConnectionPosition = void 0;
      } else if (lastInteractedWithNodeTypeDescription && lastInteractedWithNodeObject) {
        const lastInteractedWithNodeInputs = getNodeInputs(
          editableWorkflowObject.value,
          lastInteractedWithNodeObject,
          lastInteractedWithNodeTypeDescription
        );
        const lastInteractedWithNodeInputTypes = getConnectionTypes(
          lastInteractedWithNodeInputs
        );
        const lastInteractedWithNodeScopedInputTypes = (lastInteractedWithNodeInputTypes || []).filter((input) => input !== NodeConnectionType.Main);
        const lastInteractedWithNodeOutputs = getNodeOutputs(
          editableWorkflowObject.value,
          lastInteractedWithNodeObject,
          lastInteractedWithNodeTypeDescription
        );
        const lastInteractedWithNodeOutputTypes = getConnectionTypes(
          lastInteractedWithNodeOutputs
        );
        const lastInteractedWithNodeMainOutputs = lastInteractedWithNodeOutputTypes.filter(
          (output) => output === NodeConnectionType.Main
        );
        let yOffset = 0;
        if (lastInteractedWithNodeConnection) {
          shiftDownstreamNodesPosition(lastInteractedWithNode.name, PUSH_NODES_OFFSET, {
            trackHistory: true
          });
        }
        if (lastInteractedWithNodeMainOutputs.length > 1) {
          const yOffsetValues = generateOffsets(
            lastInteractedWithNodeMainOutputs.length,
            NODE_SIZE,
            GRID_SIZE
          );
          yOffset = yOffsetValues[connectionIndex];
        }
        let outputs2 = [];
        try {
          outputs2 = getNodeOutputs(
            editableWorkflowObject.value,
            node2,
            nodeTypeDescription
          );
        } catch (e) {
        }
        const outputTypes = getConnectionTypes(outputs2);
        pushOffsets = [100, 0];
        if (outputTypes.length > 0 && outputTypes.every((outputName) => outputName !== NodeConnectionType.Main)) {
          const scopedConnectionIndex = lastInteractedWithNodeScopedInputTypes.findIndex(
            (inputType) => outputs2[0] === inputType
          );
          const lastInteractedWithNodeWidthDivisions = Math.max(
            lastInteractedWithNodeScopedInputTypes.length + 1,
            1
          );
          position2 = [
            lastInteractedWithNode.position[0] + CONFIGURABLE_NODE_SIZE[0] / lastInteractedWithNodeWidthDivisions * (scopedConnectionIndex + 1) - nodeSize[0] / 2,
            lastInteractedWithNode.position[1] + PUSH_NODES_OFFSET
          ];
        } else {
          let pushOffset = PUSH_NODES_OFFSET;
          if (!!lastInteractedWithNodeInputTypes.find((input) => input !== NodeConnectionType.Main)) {
            pushOffset += 140;
          }
          position2 = [
            lastInteractedWithNode.position[0] + pushOffset,
            lastInteractedWithNode.position[1] + yOffset
          ];
        }
      }
    }
    if (!position2) {
      if (nodeTypesStore.isTriggerNode(node2.type) && triggerNodes.value.length === 0) {
        position2 = [0, 0];
      } else {
        position2 = lastClickPosition.value;
      }
    }
    return getNewNodePosition(workflowsStore.allNodes, position2, pushOffsets);
  }
  function resolveNodeName(node2) {
    const localizedName = i18n2.localizeNodeName(node2.name, node2.type);
    node2.name = uniqueNodeName(localizedName);
  }
  function resolveNodeWebhook(node2, nodeTypeDescription) {
    var _a;
    if ((_a = nodeTypeDescription.webhooks) == null ? void 0 : _a.length) {
      node2.webhookId = v4();
    }
    if ([WEBHOOK_NODE_TYPE, FORM_TRIGGER_NODE_TYPE].includes(node2.type) && node2.parameters.path === "") {
      node2.parameters.path = node2.webhookId;
    }
  }
  function shiftDownstreamNodesPosition(sourceNodeName, margin, { trackHistory = false }) {
    const sourceNode = workflowsStore.nodesByName[sourceNodeName];
    const checkNodes = workflowHelpers.getConnectedNodes(
      "downstream",
      editableWorkflowObject.value,
      sourceNodeName
    );
    for (const nodeName of checkNodes) {
      const node2 = workflowsStore.nodesByName[nodeName];
      if (node2.position[0] < sourceNode.position[0]) {
        continue;
      }
      updateNodePosition(
        node2.id,
        {
          x: node2.position[0] + margin,
          y: node2.position[1]
        },
        { trackHistory }
      );
    }
  }
  function createConnection(connection, { trackHistory = false } = {}) {
    const sourceNode = workflowsStore.getNodeById(connection.source);
    const targetNode = workflowsStore.getNodeById(connection.target);
    if (!sourceNode || !targetNode) {
      return;
    }
    if (trackHistory) {
      historyStore.pushCommandToUndo(
        new AddConnectionCommand(
          mapCanvasConnectionToLegacyConnection(sourceNode, targetNode, connection)
        )
      );
    }
    const mappedConnection = mapCanvasConnectionToLegacyConnection(
      sourceNode,
      targetNode,
      connection
    );
    if (!isConnectionAllowed(
      sourceNode,
      targetNode,
      mappedConnection[0].type,
      mappedConnection[1].type
    )) {
      return;
    }
    workflowsStore.addConnection({
      connection: mappedConnection
    });
    void nextTick(() => {
      nodeHelpers.updateNodeInputIssues(sourceNode);
      nodeHelpers.updateNodeInputIssues(targetNode);
    });
    uiStore.stateIsDirty = true;
  }
  function revertCreateConnection(connection) {
    const sourceNodeName = connection[0].node;
    const sourceNode = workflowsStore.getNodeByName(sourceNodeName);
    const targetNodeName = connection[1].node;
    const targetNode = workflowsStore.getNodeByName(targetNodeName);
    if (!sourceNode || !targetNode) {
      return;
    }
    deleteConnection(mapLegacyConnectionToCanvasConnection(sourceNode, targetNode, connection));
  }
  function deleteConnectionsByNodeId(targetNodeId, { trackHistory = false, trackBulk = true } = {}) {
    const targetNode = workflowsStore.getNodeById(targetNodeId);
    if (!targetNode) {
      return;
    }
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    const connections2 = workflowsStore.workflow.connections;
    for (const nodeName of Object.keys(connections2)) {
      const node2 = workflowsStore.getNodeByName(nodeName);
      if (!node2) {
        continue;
      }
      for (const type of Object.keys(connections2[nodeName])) {
        for (const index of Object.keys(connections2[nodeName][type])) {
          for (const connectionIndex of Object.keys(
            connections2[nodeName][type][parseInt(index, 10)]
          )) {
            const connectionData = connections2[nodeName][type][parseInt(index, 10)][parseInt(connectionIndex, 10)];
            if (!connectionData) {
              continue;
            }
            const connectionDataNode = workflowsStore.getNodeByName(connectionData.node);
            if (connectionDataNode && (connectionDataNode.id === targetNode.id || node2.name === targetNode.name)) {
              deleteConnection(
                {
                  source: node2.id,
                  sourceHandle: createCanvasConnectionHandleString({
                    mode: CanvasConnectionMode.Output,
                    type,
                    index: parseInt(index, 10)
                  }),
                  target: connectionDataNode.id,
                  targetHandle: createCanvasConnectionHandleString({
                    mode: CanvasConnectionMode.Input,
                    type: connectionData.type,
                    index: connectionData.index
                  })
                },
                { trackHistory, trackBulk: false }
              );
            }
          }
        }
      }
    }
    delete workflowsStore.workflow.connections[targetNode.name];
    if (trackHistory && trackBulk) {
      historyStore.stopRecordingUndo();
    }
  }
  function deleteConnection(connection, { trackHistory = false, trackBulk = true } = {}) {
    const sourceNode = workflowsStore.getNodeById(connection.source);
    const targetNode = workflowsStore.getNodeById(connection.target);
    if (!sourceNode || !targetNode) {
      return;
    }
    const mappedConnection = mapCanvasConnectionToLegacyConnection(
      sourceNode,
      targetNode,
      connection
    );
    if (trackHistory && trackBulk) {
      historyStore.startRecordingUndo();
    }
    workflowsStore.removeConnection({
      connection: mappedConnection
    });
    if (trackHistory) {
      historyStore.pushCommandToUndo(new RemoveConnectionCommand(mappedConnection));
      if (trackBulk) {
        historyStore.stopRecordingUndo();
      }
    }
  }
  function revertDeleteConnection(connection) {
    workflowsStore.addConnection({
      connection
    });
  }
  function isConnectionAllowed(sourceNode, targetNode, sourceConnectionType, targetConnectionType) {
    const blocklist = [STICKY_NODE_TYPE];
    if (sourceConnectionType !== targetConnectionType) {
      return false;
    }
    if (blocklist.includes(sourceNode.type) || blocklist.includes(targetNode.type)) {
      return false;
    }
    const sourceNodeType = nodeTypesStore.getNodeType(sourceNode.type, sourceNode.typeVersion);
    const sourceWorkflowNode = editableWorkflowObject.value.getNode(sourceNode.name);
    if (!sourceWorkflowNode) {
      return false;
    }
    let sourceNodeOutputs = [];
    if (sourceNodeType) {
      sourceNodeOutputs = getNodeOutputs(
        editableWorkflowObject.value,
        sourceWorkflowNode,
        sourceNodeType
      ) || [];
    }
    const sourceNodeHasOutputConnectionOfType = !!sourceNodeOutputs.find((output) => {
      const outputType = typeof output === "string" ? output : output.type;
      return outputType === sourceConnectionType;
    });
    if (!sourceNodeHasOutputConnectionOfType) {
      return false;
    }
    const targetNodeType = nodeTypesStore.getNodeType(targetNode.type, targetNode.typeVersion);
    const targetWorkflowNode = editableWorkflowObject.value.getNode(targetNode.name);
    if (!targetWorkflowNode) {
      return false;
    }
    let targetNodeInputs = [];
    if (targetNodeType) {
      targetNodeInputs = getNodeInputs(
        editableWorkflowObject.value,
        targetWorkflowNode,
        targetNodeType
      ) || [];
    }
    const targetNodeHasInputConnectionOfType = !!targetNodeInputs.find((input) => {
      const inputType = typeof input === "string" ? input : input.type;
      if (inputType !== targetConnectionType) return false;
      const filter2 = typeof input === "object" && "filter" in input ? input.filter : void 0;
      if ((filter2 == null ? void 0 : filter2.nodes.length) && !filter2.nodes.includes(sourceNode.type)) {
        toast.showToast({
          title: i18n2.baseText("nodeView.showError.nodeNodeCompatible.title"),
          message: i18n2.baseText("nodeView.showError.nodeNodeCompatible.message", {
            interpolate: { sourceNodeName: sourceNode.name, targetNodeName: targetNode.name }
          }),
          type: "error",
          duration: 5e3
        });
        return false;
      }
      return true;
    });
    return targetNodeHasInputConnectionOfType;
  }
  function addConnections(connections2, { trackBulk = true, trackHistory = false } = {}) {
    if (trackBulk && trackHistory) {
      historyStore.startRecordingUndo();
    }
    for (const { source, target: target2, data } of connections2) {
      createConnection(
        {
          source,
          sourceHandle: createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Output,
            type: isValidNodeConnectionType(data == null ? void 0 : data.source.type) ? data == null ? void 0 : data.source.type : NodeConnectionType.Main,
            index: (data == null ? void 0 : data.source.index) ?? 0
          }),
          target: target2,
          targetHandle: createCanvasConnectionHandleString({
            mode: CanvasConnectionMode.Input,
            type: isValidNodeConnectionType(data == null ? void 0 : data.target.type) ? data == null ? void 0 : data.target.type : NodeConnectionType.Main,
            index: (data == null ? void 0 : data.target.index) ?? 0
          })
        },
        { trackHistory }
      );
    }
    if (trackBulk && trackHistory) {
      historyStore.stopRecordingUndo();
    }
  }
  function resetWorkspace() {
    nodeCreatorStore.setNodeCreatorState({ createNodeActive: false });
    nodeCreatorStore.setShowScrim(false);
    if (workflowsStore.executionWaitingForWebhook) {
      try {
        void workflowsStore.removeTestWebhook(workflowsStore.workflowId);
      } catch (error2) {
      }
    }
    workflowsStore.resetWorkflow();
    workflowsStore.resetState();
    workflowsStore.currentWorkflowExecutions = [];
    uiStore.resetLastInteractedWith();
    uiStore.removeActiveAction("workflowRunning");
    uiStore.stateIsDirty = false;
    executionsStore.activeExecution = null;
    nodeHelpers.credentialsUpdated.value = false;
  }
  async function initializeWorkspace(data) {
    workflowHelpers.initState(data);
    await addNodes2(data.nodes, { keepPristine: true });
    workflowsStore.setConnections(data.connections);
  }
  function removeUnknownCredentials(workflow) {
    if (!(workflow == null ? void 0 : workflow.nodes)) return;
    for (const node2 of workflow.nodes) {
      if (!node2.credentials) continue;
      for (const [name, credential] of Object.entries(node2.credentials)) {
        if (typeof credential === "string" || credential.id === null) continue;
        if (!credentialsStore.getCredentialById(credential.id)) {
          delete node2.credentials[name];
        }
      }
    }
  }
  async function addImportedNodesToWorkflow(data, { trackBulk = true, trackHistory = false } = {}) {
    const nodeNameTable = {};
    const newNodeNames = /* @__PURE__ */ new Set();
    if (!data.nodes) {
      throw new Error(i18n2.baseText("nodeView.noNodesGivenToAdd"));
    }
    const nodeTypesCount = workflowHelpers.getNodeTypesMaxCount();
    let oldName;
    let newName;
    const createNodes = [];
    await nodeHelpers.loadNodesProperties(
      data.nodes.map((node2) => ({ name: node2.type, version: node2.typeVersion }))
    );
    data.nodes.forEach((node2) => {
      if (nodeTypesCount[node2.type] !== void 0) {
        if (nodeTypesCount[node2.type].exist >= nodeTypesCount[node2.type].max) {
          nodeNameTable[node2.name] = nodeTypesCount[node2.type].nodeNames[0];
          return;
        } else {
          nodeTypesCount[node2.type].exist += 1;
        }
      }
      oldName = node2.name;
      const localized = i18n2.localizeNodeName(node2.name, node2.type);
      newName = uniqueNodeName(localized, Array.from(newNodeNames));
      newNodeNames.add(newName);
      nodeNameTable[oldName] = newName;
      createNodes.push(node2);
    });
    const newConnections = {};
    const currentConnections = data.connections ?? {};
    const createNodeNames = createNodes.map((node2) => node2.name);
    let sourceNode, type, sourceIndex, connectionIndex, connectionData;
    for (sourceNode of Object.keys(currentConnections)) {
      if (!createNodeNames.includes(sourceNode)) {
        continue;
      }
      const connection = {};
      for (type of Object.keys(currentConnections[sourceNode])) {
        connection[type] = [];
        for (sourceIndex = 0; sourceIndex < currentConnections[sourceNode][type].length; sourceIndex++) {
          const nodeSourceConnections = [];
          if (currentConnections[sourceNode][type][sourceIndex]) {
            for (connectionIndex = 0; connectionIndex < currentConnections[sourceNode][type][sourceIndex].length; connectionIndex++) {
              connectionData = currentConnections[sourceNode][type][sourceIndex][connectionIndex];
              if (!createNodeNames.includes(connectionData.node)) {
                continue;
              }
              nodeSourceConnections.push(connectionData);
            }
          }
          connection[type].push(nodeSourceConnections);
        }
      }
      newConnections[sourceNode] = connection;
    }
    const tempWorkflow = workflowsStore.getWorkflow(createNodes, newConnections);
    for (oldName in nodeNameTable) {
      if (oldName === nodeNameTable[oldName]) {
        continue;
      }
      tempWorkflow.renameNode(oldName, nodeNameTable[oldName]);
    }
    if (data.pinData) {
      let pinDataSuccess = true;
      for (const nodeName of Object.keys(data.pinData)) {
        if (!pinDataSuccess) {
          toast.showError(
            new Error(i18n2.baseText("ndv.pinData.error.tooLarge.description")),
            i18n2.baseText("ndv.pinData.error.tooLarge.title")
          );
          continue;
        }
        const node2 = tempWorkflow.nodes[nodeNameTable[nodeName]];
        try {
          const pinnedDataForNode = usePinnedData(node2);
          pinnedDataForNode.setData(data.pinData[nodeName], "add-nodes");
          pinDataSuccess = true;
        } catch (error2) {
          pinDataSuccess = false;
          console.error(error2);
        }
      }
    }
    if (trackBulk && trackHistory) {
      historyStore.startRecordingUndo();
    }
    await addNodes2(Object.values(tempWorkflow.nodes), { trackBulk: false, trackHistory });
    addConnections(
      mapLegacyConnectionsToCanvasConnections(
        tempWorkflow.connectionsBySourceNode,
        Object.values(tempWorkflow.nodes)
      ),
      { trackBulk: false, trackHistory }
    );
    if (trackBulk && trackHistory) {
      historyStore.stopRecordingUndo();
    }
    uiStore.stateIsDirty = true;
    return {
      nodes: Object.values(tempWorkflow.nodes),
      connections: tempWorkflow.connectionsBySourceNode
    };
  }
  async function importWorkflowData(workflowData, source, importTags = true, { trackBulk = true, trackHistory = true } = {}) {
    uiStore.resetLastInteractedWith();
    if (!workflowData.hasOwnProperty("nodes") || !workflowData.hasOwnProperty("connections")) {
      return {};
    }
    try {
      const nodeIdMap = {};
      if (workflowData.nodes) {
        const nodeNames = new Set(workflowData.nodes.map((node2) => node2.name));
        workflowData.nodes.forEach((node2) => {
          if (!node2.name) {
            const nodeType = nodeTypesStore.getNodeType(node2.type);
            const newName = uniqueNodeName(
              (nodeType == null ? void 0 : nodeType.displayName) ?? node2.type,
              Array.from(nodeNames)
            );
            node2.name = newName;
            nodeNames.add(newName);
          }
          if (node2.webhookId && UPDATE_WEBHOOK_ID_NODE_TYPES.includes(node2.type)) {
            const isDuplicate = Object.values(workflowHelpers.getCurrentWorkflow().nodes).some(
              (n) => n.webhookId === node2.webhookId
            );
            if (isDuplicate) {
              node2.webhookId = v4();
            }
          }
          if (node2.id) {
            const newId2 = v4();
            nodeIdMap[newId2] = node2.id;
            node2.id = newId2;
          } else {
            node2.id = v4();
          }
        });
      }
      removeUnknownCredentials(workflowData);
      const nodeGraph = JSON.stringify(
        generateNodesGraph(
          workflowData,
          workflowHelpers.getNodeTypes(),
          {
            nodeIdMap,
            sourceInstanceId: workflowData.meta && workflowData.meta.instanceId !== rootStore.instanceId ? workflowData.meta.instanceId : "",
            isCloudDeployment: settingsStore.isCloudDeployment
          }
        ).nodeGraph
      );
      if (source === "paste") {
        telemetry.track("User pasted nodes", {
          workflow_id: workflowsStore.workflowId,
          node_graph_string: nodeGraph
        });
      } else if (source === "duplicate") {
        telemetry.track("User duplicated nodes", {
          workflow_id: workflowsStore.workflowId,
          node_graph_string: nodeGraph
        });
      } else {
        telemetry.track("User imported workflow", {
          source,
          workflow_id: workflowsStore.workflowId,
          node_graph_string: nodeGraph
        });
      }
      workflowHelpers.updateNodePositions(
        workflowData,
        getNewNodePosition(editableWorkflow.value.nodes, lastClickPosition.value)
      );
      await addImportedNodesToWorkflow(workflowData, { trackBulk, trackHistory });
      if (importTags && settingsStore.areTagsEnabled && Array.isArray(workflowData.tags)) {
        await importWorkflowTags(workflowData);
      }
      return workflowData;
    } catch (error2) {
      toast.showError(error2, i18n2.baseText("nodeView.showError.importWorkflowData.title"));
      return {};
    }
  }
  async function importWorkflowTags(workflowData) {
    const allTags = await tagsStore.fetchAll();
    const tagNames = new Set(allTags.map((tag) => tag.name));
    const workflowTags = workflowData.tags;
    const notFound = workflowTags.filter((tag) => !tagNames.has(tag.name));
    const creatingTagPromises = [];
    for (const tag of notFound) {
      const creationPromise = tagsStore.create(tag.name).then((newTag) => {
        allTags.push(newTag);
        return newTag;
      });
      creatingTagPromises.push(creationPromise);
    }
    await Promise.all(creatingTagPromises);
    const tagIds = workflowTags.reduce((accu, imported) => {
      const tag = allTags.find((t) => t.name === imported.name);
      if (tag) {
        accu.push(tag.id);
      }
      return accu;
    }, []);
    workflowsStore.addWorkflowTagIds(tagIds);
    setTimeout(() => {
      nodeHelpers.addPinDataConnections(workflowsStore.pinnedWorkflowData);
    });
  }
  async function fetchWorkflowDataFromUrl(url) {
    let workflowData;
    canvasStore.startLoading();
    try {
      workflowData = await workflowsStore.getWorkflowFromUrl(url);
    } catch (error2) {
      toast.showError(error2, i18n2.baseText("nodeView.showError.getWorkflowDataFromUrl.title"));
      return;
    } finally {
      canvasStore.stopLoading();
    }
    return workflowData;
  }
  function getNodesToSave(nodes) {
    const data = {
      nodes: [],
      connections: {},
      pinData: {}
    };
    const exportedNodeNames = /* @__PURE__ */ new Set();
    for (const node2 of nodes) {
      const nodeSaveData = workflowHelpers.getNodeDataToSave(node2);
      const pinDataForNode = workflowsStore.pinDataByNodeName(node2.name);
      if (pinDataForNode) {
        data.pinData[node2.name] = pinDataForNode;
      }
      if (nodeSaveData.credentials && settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Sharing]) {
        nodeSaveData.credentials = filterAllowedCredentials(
          nodeSaveData.credentials,
          workflowsStore.usedCredentials
        );
      }
      data.nodes.push(nodeSaveData);
      exportedNodeNames.add(node2.name);
    }
    data.connections = getConnectionsForNodes(data.nodes, exportedNodeNames);
    workflowHelpers.removeForeignCredentialsFromWorkflow(data, credentialsStore.allCredentials);
    return data;
  }
  function filterAllowedCredentials(credentials, usedCredentials) {
    return Object.fromEntries(
      Object.entries(credentials).filter(([, credential]) => {
        var _a;
        return credential.id && (!usedCredentials[credential.id] || ((_a = usedCredentials[credential.id]) == null ? void 0 : _a.currentUserHasAccess));
      })
    );
  }
  function getConnectionsForNodes(nodes, includeNodeNames) {
    const connections2 = {};
    for (const node2 of nodes) {
      const outgoingConnections = workflowsStore.outgoingConnectionsByNodeName(node2.name);
      if (!Object.keys(outgoingConnections).length) continue;
      const filteredConnections = filterConnectionsByNodes(outgoingConnections, includeNodeNames);
      if (Object.keys(filteredConnections).length) {
        connections2[node2.name] = filteredConnections;
      }
    }
    return connections2;
  }
  function filterConnectionsByNodes(connections2, includeNodeNames) {
    const filteredConnections = {};
    for (const [type, typeConnections] of Object.entries(connections2)) {
      const validConnections = typeConnections.map(
        (sourceConnections) => sourceConnections.filter((connection) => includeNodeNames.has(connection.node))
      ).filter((sourceConnections) => sourceConnections.length > 0);
      if (validConnections.length) {
        filteredConnections[type] = validConnections;
      }
    }
    return filteredConnections;
  }
  async function duplicateNodes(ids) {
    var _a;
    const workflowData = deepCopy(getNodesToSave(workflowsStore.getNodesByIds(ids)));
    const result = await importWorkflowData(workflowData, "duplicate", false);
    return ((_a = result.nodes) == null ? void 0 : _a.map((node2) => node2.id).filter(isPresent)) ?? [];
  }
  async function copyNodes(ids) {
    const workflowData = deepCopy(getNodesToSave(workflowsStore.getNodesByIds(ids)));
    await clipboard.copy(JSON.stringify(workflowData, null, 2));
    telemetry.track("User copied nodes", {
      node_types: workflowData.nodes.map((node2) => node2.type),
      workflow_id: workflowsStore.workflowId
    });
  }
  async function cutNodes(ids) {
    await copyNodes(ids);
    deleteNodes(ids);
  }
  return {
    lastClickPosition,
    editableWorkflow,
    editableWorkflowObject,
    triggerNodes,
    requireNodeTypeDescription,
    addNodes: addNodes2,
    addNode,
    resolveNodePosition,
    revertAddNode,
    updateNodesPosition,
    updateNodePosition,
    revertUpdateNodePosition,
    setNodeActive,
    setNodeActiveByName,
    setNodeSelected,
    toggleNodesDisabled,
    revertToggleNodeDisabled,
    toggleNodesPinned,
    setNodeParameters,
    renameNode,
    revertRenameNode,
    deleteNode,
    deleteNodes,
    copyNodes,
    cutNodes,
    duplicateNodes,
    getNodesToSave,
    revertDeleteNode,
    addConnections,
    createConnection,
    revertCreateConnection,
    deleteConnection,
    revertDeleteConnection,
    deleteConnectionsByNodeId,
    isConnectionAllowed,
    importWorkflowData,
    fetchWorkflowDataFromUrl,
    resetWorkspace,
    initializeWorkspace
  };
}
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "CanvasStopCurrentExecutionButton",
  props: {
    stopping: { type: Boolean }
  },
  setup(__props) {
    const props = __props;
    const i18n2 = useI18n();
    const title2 = computed(
      () => props.stopping ? i18n2.baseText("nodeView.stoppingCurrentExecution") : i18n2.baseText("nodeView.stopCurrentExecution")
    );
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        icon: "stop",
        size: "large",
        class: "stop-execution",
        type: "secondary",
        title: title2.value,
        loading: _ctx.stopping,
        "data-test-id": "stop-execution-button"
      }, null, 8, ["title", "loading"]);
    };
  }
});
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "CanvasStopWaitingForWebhookButton",
  setup(__props) {
    const i18n2 = useI18n();
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        class: "stop-execution",
        icon: "stop",
        size: "large",
        title: unref(i18n2).baseText("nodeView.stopWaitingForWebhookCall"),
        type: "secondary",
        "data-test-id": "stop-execution-waiting-for-webhook-button"
      }, null, 8, ["title"]);
    };
  }
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "CanvasClearExecutionDataButton",
  setup(__props) {
    const i18n2 = useI18n();
    return (_ctx, _cache) => {
      const _component_N8nIconButton = resolveComponent("N8nIconButton");
      return openBlock(), createBlock(_component_N8nIconButton, {
        title: unref(i18n2).baseText("nodeView.deletesTheCurrentExecutionData"),
        icon: "trash",
        size: "large",
        "data-test-id": "clear-execution-data-button"
      }, null, 8, ["title"]);
    };
  }
});
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "NodeView.v2",
  setup(__props) {
    const LazyNodeCreation2 = defineAsyncComponent(
      async () => await __vitePreload(() => import("./NodeCreation-CH8QZkmg.js").then((n) => n.N), true ? __vite__mapDeps([16,1,2,17]) : void 0)
    );
    const LazyNodeDetailsView = defineAsyncComponent(
      async () => await __vitePreload(() => Promise.resolve().then(() => NodeDetailsView), true ? void 0 : void 0)
    );
    const $style = useCssModule();
    const router = useRouter();
    const route = useRoute();
    const i18n2 = useI18n();
    const telemetry = useTelemetry();
    const externalHooks = useExternalHooks();
    const toast = useToast();
    const message = useMessage();
    const documentTitle = useDocumentTitle();
    const workflowHelpers = useWorkflowHelpers({ router });
    const nodeHelpers = useNodeHelpers();
    const nodeTypesStore = useNodeTypesStore();
    const uiStore = useUIStore();
    const workflowsStore = useWorkflowsStore();
    const sourceControlStore = useSourceControlStore();
    const nodeCreatorStore = useNodeCreatorStore();
    const settingsStore = useSettingsStore();
    const credentialsStore = useCredentialsStore();
    const environmentsStore = useEnvironmentsStore();
    const externalSecretsStore = useExternalSecretsStore();
    const rootStore = useRootStore();
    const executionsStore = useExecutionsStore();
    const canvasStore = useCanvasStore();
    const npsSurveyStore = useNpsSurveyStore();
    const historyStore = useHistoryStore();
    const projectsStore = useProjectsStore();
    const usersStore = useUsersStore();
    const tagsStore = useTagsStore();
    const pushConnectionStore = usePushConnectionStore();
    const ndvStore = useNDVStore();
    const templatesStore = useTemplatesStore();
    const canvasEventBus = createEventBus();
    const { addBeforeUnloadEventBindings, removeBeforeUnloadEventBindings } = useBeforeUnload({
      route
    });
    const { registerCustomAction, unregisterCustomAction } = useGlobalLinkActions();
    const { runWorkflow, runWorkflowResolvePending, stopCurrentExecution, stopWaitingForWebhook } = useRunWorkflow({ router });
    const {
      updateNodePosition,
      updateNodesPosition,
      revertUpdateNodePosition,
      renameNode,
      revertRenameNode,
      setNodeActive,
      setNodeSelected,
      toggleNodesDisabled,
      revertToggleNodeDisabled,
      toggleNodesPinned,
      setNodeParameters,
      deleteNode,
      deleteNodes,
      copyNodes,
      cutNodes,
      duplicateNodes,
      revertDeleteNode,
      addNodes: addNodes2,
      revertAddNode,
      createConnection,
      revertCreateConnection,
      deleteConnection,
      revertDeleteConnection,
      setNodeActiveByName,
      addConnections,
      importWorkflowData,
      fetchWorkflowDataFromUrl,
      resetWorkspace,
      initializeWorkspace,
      editableWorkflow,
      editableWorkflowObject,
      lastClickPosition
    } = useCanvasOperations({ router });
    const { applyExecutionData } = useExecutionDebugging();
    useClipboard({ onPaste: onClipboardPaste });
    const isLoading = ref(true);
    const isBlankRedirect = ref(false);
    const readOnlyNotification = ref(null);
    const isProductionExecutionPreview = ref(false);
    const isExecutionPreview = ref(false);
    const canOpenNDV = ref(true);
    const hideNodeIssues = ref(false);
    const initializedWorkflowId = ref();
    const workflowId = computed(() => {
      const workflowIdParam = route.params.name;
      return [PLACEHOLDER_EMPTY_WORKFLOW_ID, NEW_WORKFLOW_ID].includes(workflowIdParam) ? void 0 : workflowIdParam;
    });
    const isNewWorkflowRoute = computed(() => route.name === VIEWS.NEW_WORKFLOW || !workflowId.value);
    const isWorkflowRoute = computed(() => {
      var _a;
      return !!((_a = route == null ? void 0 : route.meta) == null ? void 0 : _a.nodeView) || isDemoRoute.value;
    });
    const isDemoRoute = computed(() => route.name === VIEWS.DEMO);
    const isReadOnlyRoute = computed(() => {
      var _a;
      return !!((_a = route == null ? void 0 : route.meta) == null ? void 0 : _a.readOnlyCanvas);
    });
    const isReadOnlyEnvironment = computed(() => {
      return sourceControlStore.preferences.branchReadOnly;
    });
    const isCanvasReadOnly = computed(() => {
      return isDemoRoute.value || isReadOnlyEnvironment.value || !(workflowPermissions.value.update ?? projectPermissions.value.workflow.update);
    });
    const fallbackNodes = computed(
      () => isLoading.value || isCanvasReadOnly.value ? [] : [
        {
          id: CanvasNodeRenderType.AddNodes,
          name: CanvasNodeRenderType.AddNodes,
          type: CanvasNodeRenderType.AddNodes,
          typeVersion: 1,
          position: [0, 0],
          parameters: {}
        }
      ]
    );
    const keyBindingsEnabled = computed(() => {
      return !ndvStore.activeNode && uiStore.activeModals.length === 0;
    });
    async function initializeData() {
      const loadPromises = (() => {
        if (settingsStore.isPreviewMode && isDemoRoute.value) return [];
        const promises = [
          workflowsStore.fetchActiveWorkflows(),
          credentialsStore.fetchAllCredentials(),
          credentialsStore.fetchCredentialTypes(true)
        ];
        if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.Variables]) {
          promises.push(environmentsStore.fetchAllVariables());
        }
        if (settingsStore.isEnterpriseFeatureEnabled[EnterpriseEditionFeature.ExternalSecrets]) {
          promises.push(externalSecretsStore.fetchAllSecrets());
        }
        if (nodeTypesStore.allNodeTypes.length === 0) {
          promises.push(nodeTypesStore.getNodeTypes());
        }
        return promises;
      })();
      try {
        await Promise.all(loadPromises);
      } catch (error2) {
        toast.showError(
          error2,
          i18n2.baseText("nodeView.showError.mounted1.title"),
          i18n2.baseText("nodeView.showError.mounted1.message") + ":"
        );
        return;
      }
    }
    async function initializeRoute() {
      var _a;
      if (route.params.action === "workflowSave") {
        uiStore.stateIsDirty = false;
        return;
      }
      const isAlreadyInitialized = initializedWorkflowId.value && [NEW_WORKFLOW_ID, workflowId.value].includes(initializedWorkflowId.value);
      if (isBlankRedirect.value) {
        isBlankRedirect.value = false;
      } else if (route.name === VIEWS.TEMPLATE_IMPORT) {
        const templateId = route.params.id;
        await openWorkflowTemplate(templateId.toString());
      } else if (isWorkflowRoute.value && !isAlreadyInitialized) {
        historyStore.reset();
        if (isNewWorkflowRoute.value || !workflowId.value) {
          if (((_a = route.meta) == null ? void 0 : _a.nodeView) === true) {
            await initializeWorkspaceForNewWorkflow();
          }
          return;
        }
        await initializeWorkspaceForExistingWorkflow(workflowId.value);
        await loadCredentials();
        await initializeDebugMode();
        void nextTick(() => {
          nodeHelpers.updateNodesInputIssues();
          nodeHelpers.updateNodesCredentialsIssues();
          nodeHelpers.updateNodesParameterIssues();
        });
      }
    }
    async function initializeWorkspaceForNewWorkflow() {
      resetWorkspace();
      await workflowsStore.getNewWorkflowData(void 0, projectsStore.currentProjectId);
      workflowsStore.makeNewWorkflowShareable();
      uiStore.nodeViewInitialized = true;
      initializedWorkflowId.value = NEW_WORKFLOW_ID;
    }
    async function initializeWorkspaceForExistingWorkflow(id2) {
      var _a;
      try {
        const workflowData = await workflowsStore.fetchWorkflow(id2);
        await openWorkflow(workflowData);
        if ((_a = workflowData.meta) == null ? void 0 : _a.onboardingId) {
          trackOpenWorkflowFromOnboardingTemplate();
        }
        await projectsStore.setProjectNavActiveIdByWorkflowHomeProject(
          editableWorkflow.value.homeProject
        );
      } catch (error2) {
        toast.showError(error2, i18n2.baseText("openWorkflow.workflowNotFoundError"));
        void router.push({
          name: VIEWS.NEW_WORKFLOW
        });
      } finally {
        uiStore.nodeViewInitialized = true;
        initializedWorkflowId.value = workflowId.value;
      }
    }
    async function openWorkflow(data) {
      resetWorkspace();
      workflowHelpers.setDocumentTitle(data.name, "IDLE");
      await initializeWorkspace(data);
      void externalHooks.run("workflow.open", {
        workflowId: data.id,
        workflowName: data.name
      });
      fitView();
    }
    function trackOpenWorkflowFromOnboardingTemplate() {
      var _a;
      telemetry.track(
        `User opened workflow from onboarding template with ID ${(_a = editableWorkflow.value.meta) == null ? void 0 : _a.onboardingId}`,
        {
          workflow_id: workflowId.value
        },
        {
          withPostHog: true
        }
      );
    }
    async function openWorkflowTemplate(templateId) {
      resetWorkspace();
      canvasStore.startLoading();
      canvasStore.setLoadingText(i18n2.baseText("nodeView.loadingTemplate"));
      workflowsStore.currentWorkflowExecutions = [];
      executionsStore.activeExecution = null;
      let data;
      try {
        void externalHooks.run("template.requested", { templateId });
        data = await templatesStore.getFixedWorkflowTemplate(templateId);
        if (!data) {
          throw new Error(
            i18n2.baseText("nodeView.workflowTemplateWithIdCouldNotBeFound", {
              interpolate: { templateId }
            })
          );
        }
      } catch (error2) {
        toast.showError(error2, i18n2.baseText("nodeView.couldntImportWorkflow"));
        await router.replace({ name: VIEWS.NEW_WORKFLOW });
        return;
      }
      trackOpenWorkflowTemplate(templateId);
      isBlankRedirect.value = true;
      await router.replace({ name: VIEWS.NEW_WORKFLOW, query: { templateId } });
      const convertedNodes = data.workflow.nodes.map(workflowsStore.convertTemplateNodeToNodeUi);
      workflowsStore.setConnections(data.workflow.connections);
      await addNodes2(convertedNodes);
      await workflowsStore.getNewWorkflowData(data.name, projectsStore.currentProjectId);
      workflowsStore.addToWorkflowMetadata({ templateId });
      uiStore.stateIsDirty = true;
      canvasStore.stopLoading();
      void externalHooks.run("template.open", {
        templateId,
        templateName: data.name,
        workflow: data.workflow
      });
      fitView();
    }
    function trackOpenWorkflowTemplate(templateId) {
      telemetry.track(
        "User inserted workflow template",
        {
          source: "workflow",
          template_id: tryToParseNumber(templateId),
          wf_template_repo_session_id: templatesStore.previousSessionId
        },
        {
          withPostHog: true
        }
      );
    }
    const triggerNodes = computed(() => {
      return editableWorkflow.value.nodes.filter(
        (node2) => node2.type === START_NODE_TYPE || nodeTypesStore.isTriggerNode(node2.type)
      );
    });
    const containsTriggerNodes = computed(() => triggerNodes.value.length > 0);
    const allTriggerNodesDisabled = computed(() => {
      const disabledTriggerNodes = triggerNodes.value.filter((node2) => node2.disabled);
      return disabledTriggerNodes.length === triggerNodes.value.length;
    });
    function onUpdateNodesPosition(events) {
      updateNodesPosition(events, { trackHistory: true });
    }
    function onUpdateNodePosition(id2, position2) {
      updateNodePosition(id2, position2, { trackHistory: true });
    }
    function onRevertNodePosition({ nodeName, position: position2 }) {
      revertUpdateNodePosition(nodeName, { x: position2[0], y: position2[1] });
    }
    function onDeleteNode(id2) {
      deleteNode(id2, { trackHistory: true });
    }
    function onDeleteNodes(ids) {
      deleteNodes(ids);
    }
    function onRevertDeleteNode({ node: node2 }) {
      revertDeleteNode(node2);
    }
    function onToggleNodeDisabled(id2) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesDisabled([id2]);
    }
    function onRevertToggleNodeDisabled({ nodeName }) {
      revertToggleNodeDisabled(nodeName);
    }
    function onToggleNodesDisabled(ids) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesDisabled(ids);
    }
    function onSetNodeActive(id2) {
      setNodeActive(id2);
    }
    function onSetNodeSelected(id2) {
      setNodeSelected(id2);
    }
    async function onCopyNodes(ids) {
      await copyNodes(ids);
      toast.showMessage({ title: i18n2.baseText("generic.copiedToClipboard"), type: "success" });
    }
    async function onClipboardPaste(plainTextData) {
      var _a;
      if (getNodeViewTab(route) !== MAIN_HEADER_TABS.WORKFLOW || !keyBindingsEnabled.value || !checkIfEditingIsAllowed()) {
        return;
      }
      let workflowData = null;
      if (plainTextData.match(VALID_WORKFLOW_IMPORT_URL_REGEX)) {
        const importConfirm = await message.confirm(
          i18n2.baseText("nodeView.confirmMessage.onClipboardPasteEvent.message", {
            interpolate: { plainTextData }
          }),
          i18n2.baseText("nodeView.confirmMessage.onClipboardPasteEvent.headline"),
          {
            type: "warning",
            confirmButtonText: i18n2.baseText(
              "nodeView.confirmMessage.onClipboardPasteEvent.confirmButtonText"
            ),
            cancelButtonText: i18n2.baseText(
              "nodeView.confirmMessage.onClipboardPasteEvent.cancelButtonText"
            ),
            dangerouslyUseHTMLString: true
          }
        );
        if (importConfirm !== MODAL_CONFIRM) {
          return;
        }
        workflowData = await fetchWorkflowDataFromUrl(plainTextData);
      } else {
        workflowData = jsonParse(plainTextData, { fallbackValue: null });
      }
      if (!workflowData) {
        return;
      }
      const result = await importWorkflowData(workflowData, "paste", false);
      selectNodes(((_a = result.nodes) == null ? void 0 : _a.map((node2) => node2.id)) ?? []);
    }
    async function onCutNodes(ids) {
      if (isCanvasReadOnly.value) {
        await copyNodes(ids);
      } else {
        await cutNodes(ids);
      }
    }
    async function onDuplicateNodes(ids) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      const newIds = await duplicateNodes(ids);
      selectNodes(newIds);
    }
    function onPinNodes(ids, source) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      toggleNodesPinned(ids, source);
    }
    async function onSaveWorkflow() {
      const saved = await workflowHelpers.saveCurrentWorkflow();
      if (saved) {
        canvasEventBus.emit("saved:workflow");
      }
    }
    function addWorkflowSavedEventBindings() {
      canvasEventBus.on("saved:workflow", npsSurveyStore.fetchPromptsData);
      canvasEventBus.on("saved:workflow", onSaveFromWithinNDV);
    }
    function removeWorkflowSavedEventBindings() {
      canvasEventBus.off("saved:workflow", npsSurveyStore.fetchPromptsData);
      canvasEventBus.off("saved:workflow", onSaveFromWithinNDV);
      canvasEventBus.off("saved:workflow", onSaveFromWithinExecutionDebug);
    }
    async function onSaveFromWithinNDV() {
      if (ndvStore.activeNodeName) {
        toast.showMessage({
          title: i18n2.baseText("generic.workflowSaved"),
          type: "success"
        });
      }
    }
    async function onCreateWorkflow() {
      await router.push({ name: VIEWS.NEW_WORKFLOW });
    }
    function onRenameNode(parameterData) {
      if (parameterData.name === "name" && parameterData.oldValue) {
        void renameNode(parameterData.oldValue, parameterData.value);
      }
    }
    async function onOpenRenameNodeModal(id2) {
      var _a;
      const currentName = ((_a = workflowsStore.getNodeById(id2)) == null ? void 0 : _a.name) ?? "";
      try {
        const promptResponsePromise = message.prompt(
          i18n2.baseText("nodeView.prompt.newName") + ":",
          i18n2.baseText("nodeView.prompt.renameNode") + `: ${currentName}`,
          {
            customClass: "rename-prompt",
            confirmButtonText: i18n2.baseText("nodeView.prompt.rename"),
            cancelButtonText: i18n2.baseText("nodeView.prompt.cancel"),
            inputErrorMessage: i18n2.baseText("nodeView.prompt.invalidName"),
            inputValue: currentName,
            inputValidator: (value) => {
              if (!value.trim()) {
                return i18n2.baseText("nodeView.prompt.invalidName");
              }
              return true;
            }
          }
        );
        await nextTick();
        const nameInput = document.querySelector(".rename-prompt .el-input__inner");
        nameInput == null ? void 0 : nameInput.focus();
        nameInput == null ? void 0 : nameInput.select();
        const promptResponse = await promptResponsePromise;
        if (promptResponse.action === MODAL_CONFIRM) {
          await renameNode(currentName, promptResponse.value, { trackHistory: true });
        }
      } catch (e) {
      }
    }
    async function onRevertRenameNode({
      currentName,
      newName
    }) {
      await revertRenameNode(currentName, newName);
    }
    function onUpdateNodeParameters(id2, parameters) {
      setNodeParameters(id2, parameters);
    }
    function onClickNodeAdd(source, sourceHandle) {
      nodeCreatorStore.openNodeCreatorForConnectingNode({
        connection: {
          source,
          sourceHandle
        },
        eventSource: NODE_CREATOR_OPEN_SOURCES.PLUS_ENDPOINT
      });
    }
    async function loadCredentials() {
      var _a, _b, _c;
      let options;
      if (editableWorkflow.value) {
        options = { workflowId: editableWorkflow.value.id };
      } else {
        const queryParam = typeof ((_a = route.query) == null ? void 0 : _a.projectId) === "string" ? (_b = route.query) == null ? void 0 : _b.projectId : void 0;
        const projectId = queryParam ?? ((_c = projectsStore.personalProject) == null ? void 0 : _c.id);
        if (projectId === void 0) {
          throw new Error(
            "Could not find projectId in the query nor could I find the personal project in the project store"
          );
        }
        options = { projectId };
      }
      await credentialsStore.fetchAllCredentialsForWorkflow(options);
    }
    function onCreateConnection(connection) {
      createConnection(connection, { trackHistory: true });
    }
    function onRevertCreateConnection({ connection }) {
      revertCreateConnection(connection);
    }
    function onCreateConnectionCancelled(event, position2, mouseEvent) {
      var _a;
      const preventDefault2 = (_a = (mouseEvent == null ? void 0 : mouseEvent.target).classList) == null ? void 0 : _a.contains("clickable");
      if (preventDefault2) {
        return;
      }
      uiStore.lastInteractedWithNodeId = event.nodeId;
      uiStore.lastInteractedWithNodeHandle = event.handleId;
      uiStore.lastCancelledConnectionPosition = [position2.x, position2.y];
      setTimeout(() => {
        if (!event.nodeId) return;
        nodeCreatorStore.openNodeCreatorForConnectingNode({
          connection: {
            source: event.nodeId,
            sourceHandle: event.handleId
          },
          eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_DROP
        });
      });
    }
    function onDeleteConnection(connection) {
      deleteConnection(connection, { trackHistory: true });
    }
    function onRevertDeleteConnection({ connection }) {
      revertDeleteConnection(connection);
    }
    async function importWorkflowExact({ workflow: workflowData }) {
      if (!workflowData.nodes || !workflowData.connections) {
        throw new Error("Invalid workflow object");
      }
      resetWorkspace();
      await initializeData();
      await initializeWorkspace({
        ...workflowData,
        nodes: getFixedNodesList(workflowData.nodes)
      });
      fitView();
    }
    async function onImportWorkflowDataEvent(data) {
      var _a;
      const workflowData = data.data;
      await importWorkflowData(workflowData, "file");
      fitView();
      selectNodes(((_a = workflowData.nodes) == null ? void 0 : _a.map((node2) => node2.id)) ?? []);
    }
    async function onImportWorkflowUrlEvent(data) {
      var _a;
      const workflowData = await fetchWorkflowDataFromUrl(data.url);
      if (!workflowData) {
        return;
      }
      await importWorkflowData(workflowData, "url");
      fitView();
      selectNodes(((_a = workflowData.nodes) == null ? void 0 : _a.map((node2) => node2.id)) ?? []);
    }
    function addImportEventBindings() {
      nodeViewEventBus.on("importWorkflowData", onImportWorkflowDataEvent);
      nodeViewEventBus.on("importWorkflowUrl", onImportWorkflowUrlEvent);
    }
    function removeImportEventBindings() {
      nodeViewEventBus.off("importWorkflowData", onImportWorkflowDataEvent);
      nodeViewEventBus.off("importWorkflowUrl", onImportWorkflowUrlEvent);
    }
    async function onAddNodesAndConnections({ nodes, connections: connections2 }, dragAndDrop = false, position2) {
      if (!checkIfEditingIsAllowed()) {
        return;
      }
      await addNodes2(nodes, { dragAndDrop, position: position2, trackHistory: true, telemetry: true });
      await nextTick();
      const offsetIndex = editableWorkflow.value.nodes.length - nodes.length;
      const mappedConnections = connections2.map(({ from, to }) => {
        const fromNode = editableWorkflow.value.nodes[offsetIndex + from.nodeIndex];
        const toNode = editableWorkflow.value.nodes[offsetIndex + to.nodeIndex];
        const type = from.type ?? to.type ?? NodeConnectionType.Main;
        return {
          source: fromNode.id,
          target: toNode.id,
          data: {
            source: {
              index: from.outputIndex ?? 0,
              type
            },
            target: {
              index: to.inputIndex ?? 0,
              type
            }
          }
        };
      });
      addConnections(mappedConnections);
      void nextTick(() => {
        uiStore.resetLastInteractedWith();
      });
    }
    async function onRevertAddNode({ node: node2 }) {
      await revertAddNode(node2.name);
    }
    async function onSwitchActiveNode(nodeName) {
      setNodeActiveByName(nodeName);
    }
    async function onOpenSelectiveNodeCreator(node2, connectionType2) {
      nodeCreatorStore.openSelectiveNodeCreator({ node: node2, connectionType: connectionType2 });
    }
    async function onOpenNodeCreatorForTriggerNodes(source) {
      nodeCreatorStore.openNodeCreatorForTriggerNodes(source);
    }
    function onOpenNodeCreatorFromCanvas(source) {
      onToggleNodeCreator({ createNodeActive: true, source });
    }
    function onToggleNodeCreator(options) {
      nodeCreatorStore.setNodeCreatorState(options);
      if (!options.createNodeActive && !options.hasAddedNodes) {
        uiStore.resetLastInteractedWith();
      }
    }
    function onCreateSticky() {
      void onAddNodesAndConnections({ nodes: [{ type: STICKY_NODE_TYPE }], connections: [] });
    }
    function onClickConnectionAdd(connection) {
      nodeCreatorStore.openNodeCreatorForConnectingNode({
        connection,
        eventSource: NODE_CREATOR_OPEN_SOURCES.NODE_CONNECTION_ACTION
      });
    }
    const workflowPermissions = computed(() => {
      var _a;
      return workflowId.value ? getResourcePermissions((_a = workflowsStore.getWorkflowById(workflowId.value)) == null ? void 0 : _a.scopes).workflow : {};
    });
    const projectPermissions = computed(() => {
      var _a;
      const project = ((_a = route.query) == null ? void 0 : _a.projectId) ? projectsStore.myProjects.find((p) => p.id === route.query.projectId) : projectsStore.currentProject ?? projectsStore.personalProject;
      return getResourcePermissions(project == null ? void 0 : project.scopes);
    });
    const isStoppingExecution = ref(false);
    const isWorkflowRunning = computed(() => workflowsStore.isWorkflowRunning);
    const isExecutionWaitingForWebhook = computed(() => workflowsStore.executionWaitingForWebhook);
    const isExecutionDisabled = computed(() => {
      if (containsChatTriggerNodes.value && isOnlyChatTriggerNodeActive.value && !chatTriggerNodePinnedData.value) {
        return true;
      }
      return !containsTriggerNodes.value || allTriggerNodesDisabled.value;
    });
    const isRunWorkflowButtonVisible = computed(() => !isOnlyChatTriggerNodeActive.value);
    const isStopExecutionButtonVisible = computed(
      () => isWorkflowRunning.value && !isExecutionWaitingForWebhook.value
    );
    const isStopWaitingForWebhookButtonVisible = computed(
      () => isWorkflowRunning.value && isExecutionWaitingForWebhook.value
    );
    const isClearExecutionButtonVisible = computed(
      () => !isReadOnlyRoute.value && !isReadOnlyEnvironment.value && !isWorkflowRunning.value && !allTriggerNodesDisabled.value && workflowExecutionData.value
    );
    const workflowExecutionData = computed(() => workflowsStore.workflowExecutionData);
    async function onRunWorkflow() {
      trackRunWorkflow();
      if (!isExecutionPreview.value && workflowsStore.isWaitingExecution) {
        void runWorkflowResolvePending({});
      } else {
        void runWorkflow({});
      }
    }
    function trackRunWorkflow() {
      void workflowHelpers.getWorkflowDataToSave().then((workflowData) => {
        const telemetryPayload = {
          workflow_id: workflowId.value,
          node_graph_string: JSON.stringify(
            generateNodesGraph(
              workflowData,
              workflowHelpers.getNodeTypes(),
              { isCloudDeployment: settingsStore.isCloudDeployment }
            ).nodeGraph
          )
        };
        telemetry.track("User clicked execute workflow button", telemetryPayload);
        void externalHooks.run("nodeView.onRunWorkflow", telemetryPayload);
      });
    }
    async function onRunWorkflowToNode(id2) {
      const node2 = workflowsStore.getNodeById(id2);
      if (!node2) return;
      trackRunWorkflowToNode(node2);
      if (!isExecutionPreview.value && workflowsStore.isWaitingExecution) {
        void runWorkflowResolvePending({ destinationNode: node2.name, source: "Node.executeNode" });
      } else {
        void runWorkflow({ destinationNode: node2.name, source: "Node.executeNode" });
      }
    }
    function trackRunWorkflowToNode(node2) {
      const telemetryPayload = {
        node_type: node2.type,
        workflow_id: workflowsStore.workflowId,
        source: "canvas",
        push_ref: ndvStore.pushRef
      };
      telemetry.track("User clicked execute node button", telemetryPayload);
      void externalHooks.run("nodeView.onRunNode", telemetryPayload);
    }
    async function openExecution(executionId) {
      canvasStore.startLoading();
      resetWorkspace();
      let data;
      try {
        data = await workflowsStore.getExecution(executionId);
      } catch (error2) {
        toast.showError(error2, i18n2.baseText("nodeView.showError.openExecution.title"));
        return;
      }
      if (data === void 0) {
        throw new Error(`Execution with id "${executionId}" could not be found!`);
      }
      await initializeData();
      await initializeWorkspace(data.workflowData);
      workflowsStore.setWorkflowExecutionData(data);
      uiStore.stateIsDirty = false;
      canvasStore.stopLoading();
      fitView();
      canvasEventBus.emit("open:execution", data);
      void externalHooks.run("execution.open", {
        workflowId: data.workflowData.id,
        workflowName: data.workflowData.name,
        executionId
      });
      telemetry.track("User opened read-only execution", {
        workflow_id: data.workflowData.id,
        execution_mode: data.mode,
        execution_finished: data.finished
      });
    }
    function onExecutionOpenedWithError(data) {
      var _a, _b;
      if (!data.finished && ((_b = (_a = data.data) == null ? void 0 : _a.resultData) == null ? void 0 : _b.error)) {
        let nodeErrorFound = false;
        if (data.data.resultData.runData) {
          const runData2 = data.data.resultData.runData;
          errorCheck: for (const nodeName of Object.keys(runData2)) {
            for (const taskData of runData2[nodeName]) {
              if (taskData.error) {
                nodeErrorFound = true;
                break errorCheck;
              }
            }
          }
        }
        if (!nodeErrorFound && (data.data.resultData.error.stack ?? data.data.resultData.error.message)) {
          console.error(`Execution ${data.id} error:`);
          console.error(data.data.resultData.error.stack);
          toast.showMessage({
            title: i18n2.baseText("nodeView.showError.workflowError"),
            message: data.data.resultData.error.message,
            type: "error",
            duration: 0
          });
        }
      }
    }
    function onExecutionOpenedWithWaitTill(data) {
      if (data.waitTill) {
        toast.showMessage({
          title: i18n2.baseText("nodeView.thisExecutionHasntFinishedYet"),
          message: h(_sfc_main$C),
          type: "warning",
          duration: 0
        });
      }
    }
    function addExecutionOpenedEventBindings() {
      canvasEventBus.on("open:execution", onExecutionOpenedWithError);
      canvasEventBus.on("open:execution", onExecutionOpenedWithWaitTill);
    }
    function removeExecutionOpenedEventBindings() {
      canvasEventBus.off("open:execution", onExecutionOpenedWithError);
      canvasEventBus.off("open:execution", onExecutionOpenedWithWaitTill);
    }
    async function onStopExecution() {
      isStoppingExecution.value = true;
      await stopCurrentExecution();
      isStoppingExecution.value = false;
    }
    async function onStopWaitingForWebhook() {
      await stopWaitingForWebhook();
    }
    async function onClearExecutionData() {
      workflowsStore.workflowExecutionData = null;
      nodeHelpers.updateNodesExecutionIssues();
    }
    function onRunWorkflowButtonMouseEnter() {
      nodeViewEventBus.emit("runWorkflowButton:mouseenter");
    }
    function onRunWorkflowButtonMouseLeave() {
      nodeViewEventBus.emit("runWorkflowButton:mouseleave");
    }
    const chatTriggerNode = computed(() => {
      return editableWorkflow.value.nodes.find((node2) => node2.type === CHAT_TRIGGER_NODE_TYPE);
    });
    const containsChatTriggerNodes = computed(() => {
      return !isExecutionWaitingForWebhook.value && !!editableWorkflow.value.nodes.find(
        (node2) => [MANUAL_CHAT_TRIGGER_NODE_TYPE, CHAT_TRIGGER_NODE_TYPE].includes(node2.type) && node2.disabled !== true
      );
    });
    const isOnlyChatTriggerNodeActive = computed(() => {
      return triggerNodes.value.every((node2) => node2.disabled || node2.type === CHAT_TRIGGER_NODE_TYPE);
    });
    const chatTriggerNodePinnedData = computed(() => {
      if (!chatTriggerNode.value) return null;
      return workflowsStore.pinDataByNodeName(chatTriggerNode.value.name);
    });
    async function onOpenChat() {
      uiStore.openModal(WORKFLOW_LM_CHAT_MODAL_KEY);
      const payload = {
        workflow_id: workflowId.value
      };
      void externalHooks.run("nodeView.onOpenChat", payload);
      telemetry.track("User clicked chat open button", payload);
    }
    function addUndoRedoEventBindings() {
      historyBus.on("nodeMove", onRevertNodePosition);
      historyBus.on("revertAddNode", onRevertAddNode);
      historyBus.on("revertRemoveNode", onRevertDeleteNode);
      historyBus.on("revertAddConnection", onRevertCreateConnection);
      historyBus.on("revertRemoveConnection", onRevertDeleteConnection);
      historyBus.on("revertRenameNode", onRevertRenameNode);
      historyBus.on("enableNodeToggle", onRevertToggleNodeDisabled);
    }
    function removeUndoRedoEventBindings() {
      historyBus.off("nodeMove", onRevertNodePosition);
      historyBus.off("revertAddNode", onRevertAddNode);
      historyBus.off("revertRemoveNode", onRevertDeleteNode);
      historyBus.off("revertAddConnection", onRevertCreateConnection);
      historyBus.off("revertRemoveConnection", onRevertDeleteConnection);
      historyBus.off("revertRenameNode", onRevertRenameNode);
      historyBus.off("enableNodeToggle", onRevertToggleNodeDisabled);
    }
    async function onSourceControlPull() {
      try {
        await Promise.all([
          environmentsStore.fetchAllVariables(),
          tagsStore.fetchAll(),
          loadCredentials()
        ]);
        if (workflowId.value && !uiStore.stateIsDirty) {
          const workflowData = await workflowsStore.fetchWorkflow(workflowId.value);
          if (workflowData) {
            workflowHelpers.setDocumentTitle(workflowData.name, "IDLE");
            await openWorkflow(workflowData);
          }
        }
      } catch (error2) {
        console.error(error2);
      }
    }
    function addSourceControlEventBindings() {
      sourceControlEventBus.on("pull", onSourceControlPull);
    }
    function removeSourceControlEventBindings() {
      sourceControlEventBus.off("pull", onSourceControlPull);
    }
    function addPostMessageEventBindings() {
      window.addEventListener("message", onPostMessageReceived);
      if (window.parent) {
        window.parent.postMessage(
          JSON.stringify({ command: "n8nReady", version: rootStore.versionCli }),
          "*"
        );
      }
    }
    function removePostMessageEventBindings() {
      window.removeEventListener("message", onPostMessageReceived);
    }
    async function onPostMessageReceived(messageEvent) {
      var _a, _b;
      if (!messageEvent || typeof messageEvent.data !== "string" || !((_b = (_a = messageEvent.data) == null ? void 0 : _a.includes) == null ? void 0 : _b.call(_a, '"command"'))) {
        return;
      }
      try {
        const json = JSON.parse(messageEvent.data);
        if (json && json.command === "openWorkflow") {
          try {
            await importWorkflowExact(json);
            canOpenNDV.value = json.canOpenNDV ?? true;
            hideNodeIssues.value = json.hideNodeIssues ?? false;
            isExecutionPreview.value = false;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: i18n2.baseText("openWorkflow.workflowImportError")
                }),
                "*"
              );
            }
            toast.showError(e, i18n2.baseText("openWorkflow.workflowImportError"));
          }
        } else if (json && json.command === "openExecution") {
          try {
            isProductionExecutionPreview.value = json.executionMode !== "manual";
            await openExecution(json.executionId);
            canOpenNDV.value = json.canOpenNDV ?? true;
            hideNodeIssues.value = json.hideNodeIssues ?? false;
            isExecutionPreview.value = true;
          } catch (e) {
            if (window.top) {
              window.top.postMessage(
                JSON.stringify({
                  command: "error",
                  message: i18n2.baseText("nodeView.showError.openExecution.title")
                }),
                "*"
              );
            }
            toast.showMessage({
              title: i18n2.baseText("nodeView.showError.openExecution.title"),
              message: e.message,
              type: "error"
            });
          }
        } else if ((json == null ? void 0 : json.command) === "setActiveExecution") {
          executionsStore.activeExecution = await executionsStore.fetchExecution(
            json.executionId
          );
        }
      } catch (e) {
      }
    }
    function checkIfEditingIsAllowed() {
      var _a;
      if (!initializedWorkflowId.value) {
        return true;
      }
      if ((_a = readOnlyNotification.value) == null ? void 0 : _a.visible) {
        return false;
      }
      if (isReadOnlyRoute.value || isReadOnlyEnvironment.value) {
        const messageContext = isReadOnlyRoute.value ? "executions" : "workflows";
        readOnlyNotification.value = toast.showMessage({
          title: i18n2.baseText(
            isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.title` : "readOnly.showMessage.executions.title"
          ),
          message: i18n2.baseText(
            isReadOnlyEnvironment.value ? `readOnlyEnv.showMessage.${messageContext}.message` : "readOnly.showMessage.executions.message"
          ),
          type: "info",
          dangerouslyUseHTMLString: true
        });
        return false;
      }
      return true;
    }
    function checkIfRouteIsAllowed() {
      if (isReadOnlyEnvironment.value && [VIEWS.NEW_WORKFLOW, VIEWS.TEMPLATE_IMPORT].find((view) => view === route.name)) {
        void nextTick(async () => {
          resetWorkspace();
          uiStore.stateIsDirty = false;
          await router.replace({ name: VIEWS.HOMEPAGE });
        });
      }
    }
    async function initializeDebugMode() {
      if (route.name === VIEWS.EXECUTION_DEBUG) {
        workflowHelpers.setDocumentTitle(workflowsStore.workflowName, "DEBUG");
        if (!workflowsStore.isInDebugMode) {
          await applyExecutionData(route.params.executionId);
          workflowsStore.isInDebugMode = true;
        }
        canvasEventBus.on("saved:workflow", onSaveFromWithinExecutionDebug);
      }
    }
    async function onSaveFromWithinExecutionDebug() {
      if (route.name !== VIEWS.EXECUTION_DEBUG) return;
      await router.replace({
        name: VIEWS.WORKFLOW,
        params: { name: workflowId.value }
      });
    }
    const viewportTransform = ref({ x: 0, y: 0, zoom: 1 });
    function onViewportChange(event) {
      viewportTransform.value = event;
      uiStore.nodeViewOffsetPosition = [event.x, event.y];
    }
    function fitView() {
      setTimeout(() => canvasEventBus.emit("fitView"));
    }
    function selectNodes(ids) {
      setTimeout(() => canvasEventBus.emit("nodes:select", { ids }));
    }
    function onClickPane(position2) {
      lastClickPosition.value = [position2.x, position2.y];
      uiStore.isCreateNodeActive = false;
    }
    function registerCustomActions() {
      registerCustomAction({
        key: "openNodeDetail",
        action: ({ node: node2 }) => {
          setNodeActiveByName(node2);
        }
      });
      registerCustomAction({
        key: "openSelectiveNodeCreator",
        action: ({
          connectiontype: connectionType2,
          node: node2
        }) => {
          void onOpenSelectiveNodeCreator(node2, connectionType2);
        }
      });
      registerCustomAction({
        key: "showNodeCreator",
        action: () => {
          ndvStore.activeNodeName = null;
          void nextTick(() => {
            void onOpenNodeCreatorForTriggerNodes(NODE_CREATOR_OPEN_SOURCES.TAB);
          });
        }
      });
    }
    function unregisterCustomActions() {
      unregisterCustomAction("openNodeDetail");
      unregisterCustomAction("openSelectiveNodeCreator");
      unregisterCustomAction("showNodeCreator");
    }
    watch(
      () => route.name,
      async () => {
        await initializeRoute();
      }
    );
    onBeforeMount(() => {
      if (!isDemoRoute.value) {
        pushConnectionStore.pushConnect();
      }
    });
    onMounted(() => {
      canvasStore.startLoading();
      documentTitle.reset();
      resetWorkspace();
      void initializeData().then(() => {
        void initializeRoute().then(() => {
          toast.showNotificationForViews([VIEWS.WORKFLOW, VIEWS.NEW_WORKFLOW]);
        }).finally(() => {
          isLoading.value = false;
          canvasStore.stopLoading();
          void externalHooks.run("nodeView.mount").catch(() => {
          });
        });
        void usersStore.showPersonalizationSurvey();
        checkIfRouteIsAllowed();
      });
      addSourceControlEventBindings();
      addPostMessageEventBindings();
      addWorkflowSavedEventBindings();
      addBeforeUnloadEventBindings();
      addImportEventBindings();
      addExecutionOpenedEventBindings();
      registerCustomActions();
    });
    onActivated(async () => {
      addUndoRedoEventBindings();
    });
    onDeactivated(() => {
      removeUndoRedoEventBindings();
    });
    onBeforeUnmount(() => {
      removeSourceControlEventBindings();
      removePostMessageEventBindings();
      removeWorkflowSavedEventBindings();
      removeBeforeUnloadEventBindings();
      removeImportEventBindings();
      removeExecutionOpenedEventBindings();
      unregisterCustomActions();
      if (!isDemoRoute.value) {
        pushConnectionStore.pushDisconnect();
      }
    });
    return (_ctx, _cache) => {
      const _component_CanvasChatButton = __unplugin_components_0$5;
      return unref(editableWorkflow) && unref(editableWorkflowObject) && !isLoading.value ? (openBlock(), createBlock(WorkflowCanvas, {
        key: 0,
        workflow: unref(editableWorkflow),
        "workflow-object": unref(editableWorkflowObject),
        "fallback-nodes": fallbackNodes.value,
        "event-bus": unref(canvasEventBus),
        "read-only": isCanvasReadOnly.value,
        executing: isWorkflowRunning.value,
        "key-bindings": keyBindingsEnabled.value,
        "onUpdate:nodes:position": onUpdateNodesPosition,
        "onUpdate:node:position": onUpdateNodePosition,
        "onUpdate:node:active": onSetNodeActive,
        "onUpdate:node:selected": onSetNodeSelected,
        "onUpdate:node:enabled": onToggleNodeDisabled,
        "onUpdate:node:name": onOpenRenameNodeModal,
        "onUpdate:node:parameters": onUpdateNodeParameters,
        "onClick:node:add": onClickNodeAdd,
        "onRun:node": onRunWorkflowToNode,
        "onDelete:node": onDeleteNode,
        "onCreate:connection": onCreateConnection,
        "onCreate:connection:cancelled": onCreateConnectionCancelled,
        "onDelete:connection": onDeleteConnection,
        "onClick:connection:add": onClickConnectionAdd,
        "onClick:pane": onClickPane,
        "onCreate:node": onOpenNodeCreatorFromCanvas,
        "onCreate:sticky": onCreateSticky,
        "onDelete:nodes": onDeleteNodes,
        "onUpdate:nodes:enabled": onToggleNodesDisabled,
        "onUpdate:nodes:pin": onPinNodes,
        "onDuplicate:nodes": onDuplicateNodes,
        "onCopy:nodes": onCopyNodes,
        "onCut:nodes": onCutNodes,
        "onRun:workflow": onRunWorkflow,
        "onSave:workflow": onSaveWorkflow,
        "onCreate:workflow": onCreateWorkflow,
        onViewportChange
      }, {
        default: withCtx(() => [
          !isCanvasReadOnly.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref($style).executionButtons)
          }, [
            isRunWorkflowButtonVisible.value ? (openBlock(), createBlock(_sfc_main$5, {
              key: 0,
              "waiting-for-webhook": isExecutionWaitingForWebhook.value,
              disabled: isExecutionDisabled.value,
              executing: isWorkflowRunning.value,
              onMouseenter: onRunWorkflowButtonMouseEnter,
              onMouseleave: onRunWorkflowButtonMouseLeave,
              onClick: onRunWorkflow
            }, null, 8, ["waiting-for-webhook", "disabled", "executing"])) : createCommentVNode("", true),
            containsChatTriggerNodes.value ? (openBlock(), createBlock(_component_CanvasChatButton, {
              key: 1,
              onClick: onOpenChat
            })) : createCommentVNode("", true),
            isStopExecutionButtonVisible.value ? (openBlock(), createBlock(_sfc_main$4, {
              key: 2,
              stopping: isStoppingExecution.value,
              onClick: onStopExecution
            }, null, 8, ["stopping"])) : createCommentVNode("", true),
            isStopWaitingForWebhookButtonVisible.value ? (openBlock(), createBlock(_sfc_main$3, {
              key: 3,
              onClick: onStopWaitingForWebhook
            })) : createCommentVNode("", true),
            isClearExecutionButtonVisible.value ? (openBlock(), createBlock(_sfc_main$2, {
              key: 4,
              onClick: onClearExecutionData
            })) : createCommentVNode("", true)
          ], 2)) : createCommentVNode("", true),
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              !isCanvasReadOnly.value ? (openBlock(), createBlock(unref(LazyNodeCreation2), {
                key: 0,
                "create-node-active": unref(uiStore).isCreateNodeActive,
                "node-view-scale": viewportTransform.value.zoom,
                onToggleNodeCreator,
                onAddNodes: onAddNodesAndConnections
              }, null, 8, ["create-node-active", "node-view-scale"])) : createCommentVNode("", true)
            ]),
            _: 1
          })),
          (openBlock(), createBlock(Suspense, null, {
            default: withCtx(() => [
              createVNode(unref(LazyNodeDetailsView), {
                "workflow-object": unref(editableWorkflowObject),
                "read-only": isCanvasReadOnly.value,
                "is-production-execution-preview": isProductionExecutionPreview.value,
                renaming: false,
                onValueChanged: onRenameNode,
                onStopExecution,
                onSwitchSelectedNode: onSwitchActiveNode,
                onOpenConnectionNodeCreator: onOpenSelectiveNodeCreator,
                onSaveKeyboardShortcut: onSaveWorkflow
              }, null, 8, ["workflow-object", "read-only", "is-production-execution-preview"])
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 8, ["workflow", "workflow-object", "fallback-nodes", "event-bus", "read-only", "executing", "key-bindings"])) : createCommentVNode("", true);
    };
  }
});
const executionButtons = "_executionButtons_1bnph_1";
const style0 = {
  executionButtons
};
const cssModules = {
  "$style": style0
};
const NodeViewV2 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__cssModules", cssModules]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "NodeViewSwitcher",
  setup(__props) {
    const workflowsStore = useWorkflowsStore();
    const sourceControlStore = useSourceControlStore();
    const settingsStore = useSettingsStore();
    const router = useRouter();
    const route = useRoute();
    const workflowHelpers = useWorkflowHelpers({ router });
    const nodeViewVersion = useLocalStorage(
      "NodeView.version",
      settingsStore.deploymentType === "n8n-internal" ? "2" : "1"
    );
    const workflowId = computed(() => route.params.name);
    const isReadOnlyEnvironment = computed(() => {
      return sourceControlStore.preferences.branchReadOnly;
    });
    watch(nodeViewVersion, () => {
      router.go(0);
    });
    onBeforeRouteLeave(async (to, from, next) => {
      const toNodeViewTab = getNodeViewTab(to);
      if (toNodeViewTab === MAIN_HEADER_TABS.EXECUTIONS || from.name === VIEWS.TEMPLATE_IMPORT || toNodeViewTab === MAIN_HEADER_TABS.WORKFLOW && from.name === VIEWS.EXECUTION_DEBUG || isReadOnlyEnvironment.value) {
        next();
        return;
      }
      await workflowHelpers.promptSaveUnsavedWorkflowChanges(next, {
        async confirm() {
          if (from.name === VIEWS.NEW_WORKFLOW) {
            await router.replace({
              name: VIEWS.WORKFLOW,
              params: { name: workflowId.value }
            });
            await router.push(to);
            return false;
          }
          workflowsStore.setWorkflowId(PLACEHOLDER_EMPTY_WORKFLOW_ID);
          return true;
        }
      });
    });
    return (_ctx, _cache) => {
      return unref(nodeViewVersion) === "2" ? (openBlock(), createBlock(NodeViewV2, { key: 0 })) : (openBlock(), createBlock(NodeViewV1, { key: 1 }));
    };
  }
});
const NodeViewSwitcher = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: _sfc_main
}, Symbol.toStringTag, { value: "Module" }));
export {
  AIView as A,
  NodeViewSwitcher as N,
  RegularView as R,
  TriggerView as T,
  VueJsonPretty as V,
  useViewStacks as a,
  useKeyboardNavigation as b,
  camelCase as c,
  flattenCreateElements as d,
  AINodesView as e,
  formatTriggerActionName as f,
  sortNodeCreateElements as s,
  transformNodeType as t,
  useNodeCreatorStore as u
};
