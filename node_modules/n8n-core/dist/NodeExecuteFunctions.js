"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateValueAgainstSchema = exports.removeEmptyBody = void 0;
exports.parseRequestObject = parseRequestObject;
exports.parseIncomingMessage = parseIncomingMessage;
exports.proxyRequestToAxios = proxyRequestToAxios;
exports.getBinaryPath = getBinaryPath;
exports.getBinaryMetadata = getBinaryMetadata;
exports.getBinaryStream = getBinaryStream;
exports.assertBinaryData = assertBinaryData;
exports.getBinaryDataBuffer = getBinaryDataBuffer;
exports.setBinaryDataBuffer = setBinaryDataBuffer;
exports.copyBinaryFile = copyBinaryFile;
exports.checkProcessedAndRecord = checkProcessedAndRecord;
exports.checkProcessedItemsAndRecord = checkProcessedItemsAndRecord;
exports.removeProcessed = removeProcessed;
exports.clearAllProcessedItems = clearAllProcessedItems;
exports.getProcessedDataCount = getProcessedDataCount;
exports.requestOAuth2 = requestOAuth2;
exports.requestOAuth1 = requestOAuth1;
exports.httpRequestWithAuthentication = httpRequestWithAuthentication;
exports.returnJsonArray = returnJsonArray;
exports.constructExecutionMetaData = constructExecutionMetaData;
exports.normalizeItems = normalizeItems;
exports.requestWithAuthentication = requestWithAuthentication;
exports.getAdditionalKeys = getAdditionalKeys;
exports.getCredentials = getCredentials;
exports.cleanupParameterData = cleanupParameterData;
exports.ensureType = ensureType;
exports.getNodeParameter = getNodeParameter;
exports.continueOnFail = continueOnFail;
exports.getNodeWebhookUrl = getNodeWebhookUrl;
exports.getWebhookDescription = getWebhookDescription;
exports.isFilePathBlocked = isFilePathBlocked;
exports.copyInputItems = copyInputItems;
exports.getExecutePollFunctions = getExecutePollFunctions;
exports.getExecuteTriggerFunctions = getExecuteTriggerFunctions;
exports.getExecuteFunctions = getExecuteFunctions;
exports.getExecuteSingleFunctions = getExecuteSingleFunctions;
exports.getCredentialTestFunctions = getCredentialTestFunctions;
exports.getLoadOptionsFunctions = getLoadOptionsFunctions;
exports.getExecuteHookFunctions = getExecuteHookFunctions;
exports.getExecuteWebhookFunctions = getExecuteWebhookFunctions;
const client_oauth2_1 = require("@n8n/client-oauth2");
const axios_1 = __importDefault(require("axios"));
const crypto_1 = __importStar(require("crypto"));
const file_type_1 = __importDefault(require("file-type"));
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = require("fs");
const promises_1 = require("fs/promises");
const http_1 = require("http");
const https_1 = require("https");
const get_1 = __importDefault(require("lodash/get"));
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const merge_1 = __importDefault(require("lodash/merge"));
const pick_1 = __importDefault(require("lodash/pick"));
const luxon_1 = require("luxon");
const mime_types_1 = require("mime-types");
const n8n_workflow_1 = require("n8n-workflow");
const oauth_1_0a_1 = __importDefault(require("oauth-1.0a"));
const path_1 = __importDefault(require("path"));
const qs_1 = require("qs");
const stream_1 = require("stream");
const typedi_1 = __importDefault(require("typedi"));
const url_1 = __importStar(require("url"));
const Agent_1 = require("./Agent");
const BinaryData_service_1 = require("./BinaryData/BinaryData.service");
const utils_1 = require("./BinaryData/utils");
const Constants_1 = require("./Constants");
const CreateNodeAsTool_1 = require("./CreateNodeAsTool");
const data_deduplication_service_1 = require("./data-deduplication-service");
const ExecutionMetadata_1 = require("./ExecutionMetadata");
const ExtractValue_1 = require("./ExtractValue");
const InstanceSettings_1 = require("./InstanceSettings");
const ScheduledTaskManager_1 = require("./ScheduledTaskManager");
const Secrets_1 = require("./Secrets");
const SSHClientsManager_1 = require("./SSHClientsManager");
axios_1.default.defaults.timeout = 300000;
axios_1.default.defaults.headers.post = {};
axios_1.default.defaults.headers.put = {};
axios_1.default.defaults.headers.patch = {};
axios_1.default.defaults.paramsSerializer = (params) => {
    if (params instanceof url_1.URLSearchParams) {
        return params.toString();
    }
    return (0, qs_1.stringify)(params, { arrayFormat: 'indices' });
};
axios_1.default.interceptors.request.use((config) => {
    if (config.data === undefined) {
        config.headers.setContentType(false, false);
    }
    return config;
});
const pushFormDataValue = (form, key, value) => {
    if (value?.hasOwnProperty('value') && value.hasOwnProperty('options')) {
        form.append(key, value.value, value.options);
    }
    else {
        form.append(key, value);
    }
};
const createFormDataObject = (data) => {
    const formData = new form_data_1.default();
    const keys = Object.keys(data);
    keys.forEach((key) => {
        const formField = data[key];
        if (formField instanceof Array) {
            formField.forEach((item) => {
                pushFormDataValue(formData, key, item);
            });
        }
        else {
            pushFormDataValue(formData, key, formField);
        }
    });
    return formData;
};
const validateUrl = (url) => {
    if (!url)
        return false;
    try {
        new url_1.URL(url);
        return true;
    }
    catch (error) {
        return false;
    }
};
function searchForHeader(config, headerName) {
    if (config.headers === undefined) {
        return undefined;
    }
    const headerNames = Object.keys(config.headers);
    headerName = headerName.toLowerCase();
    return headerNames.find((thisHeader) => thisHeader.toLowerCase() === headerName);
}
async function generateContentLengthHeader(config) {
    if (!(config.data instanceof form_data_1.default)) {
        return;
    }
    try {
        const length = await new Promise((res, rej) => {
            config.data.getLength((error, length) => {
                if (error) {
                    rej(error);
                    return;
                }
                res(length);
            });
        });
        config.headers = {
            ...config.headers,
            'content-length': length,
        };
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.error('Unable to calculate form data length', { error });
    }
}
const getHostFromRequestObject = (requestObject) => {
    try {
        const url = (requestObject.url ?? requestObject.uri);
        return new url_1.URL(url, requestObject.baseURL).hostname;
    }
    catch (error) {
        return null;
    }
};
const getBeforeRedirectFn = (agentOptions, axiosConfig) => (redirectedRequest) => {
    const redirectAgent = new https_1.Agent({
        ...agentOptions,
        servername: redirectedRequest.hostname,
    });
    redirectedRequest.agent = redirectAgent;
    redirectedRequest.agents.https = redirectAgent;
    if (axiosConfig.headers?.Authorization) {
        redirectedRequest.headers.Authorization = axiosConfig.headers.Authorization;
    }
    if (axiosConfig.auth) {
        redirectedRequest.auth = `${axiosConfig.auth.username}:${axiosConfig.auth.password}`;
    }
};
async function parseRequestObject(requestObject) {
    const axiosConfig = {};
    if (requestObject.headers !== undefined) {
        axiosConfig.headers = requestObject.headers;
    }
    const contentTypeHeaderKeyName = axiosConfig.headers &&
        Object.keys(axiosConfig.headers).find((headerName) => headerName.toLowerCase() === 'content-type');
    const contentType = contentTypeHeaderKeyName &&
        axiosConfig.headers?.[contentTypeHeaderKeyName];
    if (contentType === 'application/x-www-form-urlencoded' && requestObject.formData === undefined) {
        if (typeof requestObject.body === 'string') {
            axiosConfig.data = requestObject.body;
        }
        else {
            const allData = Object.assign(requestObject.body || {}, requestObject.form || {});
            if (requestObject.useQuerystring === true) {
                axiosConfig.data = (0, qs_1.stringify)(allData, { arrayFormat: 'repeat' });
            }
            else {
                axiosConfig.data = (0, qs_1.stringify)(allData);
            }
        }
    }
    else if (contentType?.includes('multipart/form-data')) {
        if (requestObject.formData !== undefined && requestObject.formData instanceof form_data_1.default) {
            axiosConfig.data = requestObject.formData;
        }
        else {
            const allData = {
                ...requestObject.body,
                ...requestObject.formData,
            };
            axiosConfig.data = createFormDataObject(allData);
        }
        delete axiosConfig.headers?.[contentTypeHeaderKeyName];
        const headers = axiosConfig.data.getHeaders();
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, headers);
        await generateContentLengthHeader(axiosConfig);
    }
    else {
        if (requestObject.form !== undefined && requestObject.body === undefined) {
            axiosConfig.data =
                typeof requestObject.form === 'string'
                    ? (0, qs_1.stringify)(requestObject.form, { format: 'RFC3986' })
                    : (0, qs_1.stringify)(requestObject.form).toString();
            if (axiosConfig.headers !== undefined) {
                const headerName = searchForHeader(axiosConfig, 'content-type');
                if (headerName) {
                    delete axiosConfig.headers[headerName];
                }
                axiosConfig.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
            else {
                axiosConfig.headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
        }
        else if (requestObject.formData !== undefined) {
            if (axiosConfig.headers !== undefined) {
                const headers = Object.keys(axiosConfig.headers);
                headers.forEach((header) => {
                    if (header.toLowerCase() === 'content-type') {
                        delete axiosConfig.headers?.[header];
                    }
                });
            }
            if (requestObject.formData instanceof form_data_1.default) {
                axiosConfig.data = requestObject.formData;
            }
            else {
                axiosConfig.data = createFormDataObject(requestObject.formData);
            }
            const headers = axiosConfig.data.getHeaders();
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, headers);
            await generateContentLengthHeader(axiosConfig);
        }
        else if (requestObject.body !== undefined) {
            if (requestObject.form !== undefined && requestObject.body) {
                requestObject.body = Object.assign(requestObject.body, requestObject.form);
            }
            axiosConfig.data = requestObject.body;
        }
    }
    if (requestObject.uri !== undefined) {
        axiosConfig.url = requestObject.uri?.toString();
    }
    if (requestObject.url !== undefined) {
        axiosConfig.url = requestObject.url?.toString();
    }
    if (requestObject.baseURL !== undefined) {
        axiosConfig.baseURL = requestObject.baseURL?.toString();
    }
    if (requestObject.method !== undefined) {
        axiosConfig.method = requestObject.method;
    }
    if (requestObject.qs !== undefined && Object.keys(requestObject.qs).length > 0) {
        axiosConfig.params = requestObject.qs;
    }
    function hasArrayFormatOptions(arg) {
        if (typeof arg.qsStringifyOptions === 'object' &&
            arg.qsStringifyOptions !== null &&
            !Array.isArray(arg.qsStringifyOptions) &&
            'arrayFormat' in arg.qsStringifyOptions) {
            return true;
        }
        return false;
    }
    if (requestObject.useQuerystring === true ||
        (hasArrayFormatOptions(requestObject) &&
            requestObject.qsStringifyOptions.arrayFormat === 'repeat')) {
        axiosConfig.paramsSerializer = (params) => {
            return (0, qs_1.stringify)(params, { arrayFormat: 'repeat' });
        };
    }
    else if (requestObject.useQuerystring === false) {
        axiosConfig.paramsSerializer = (params) => {
            return (0, qs_1.stringify)(params, { arrayFormat: 'indices' });
        };
    }
    if (hasArrayFormatOptions(requestObject) &&
        requestObject.qsStringifyOptions.arrayFormat === 'brackets') {
        axiosConfig.paramsSerializer = (params) => {
            return (0, qs_1.stringify)(params, { arrayFormat: 'brackets' });
        };
    }
    if (requestObject.auth !== undefined) {
        if (requestObject.auth.bearer !== undefined) {
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
                Authorization: `Bearer ${requestObject.auth.bearer}`,
            });
        }
        else {
            const authObj = requestObject.auth;
            axiosConfig.auth = {
                username: (authObj.user || authObj.username),
                password: (authObj.password || authObj.pass),
            };
        }
    }
    if (requestObject.json === true) {
        const acceptHeaderExists = axiosConfig.headers === undefined
            ? false
            : Object.keys(axiosConfig.headers)
                .map((headerKey) => headerKey.toLowerCase())
                .includes('accept');
        if (!acceptHeaderExists) {
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
                Accept: 'application/json',
            });
        }
    }
    if (requestObject.json === false || requestObject.json === undefined) {
        axiosConfig.transformResponse = (res) => res;
    }
    const { method } = requestObject;
    if ((requestObject.followRedirect !== false &&
        (!method || method === 'GET' || method === 'HEAD')) ||
        requestObject.followAllRedirects) {
        axiosConfig.maxRedirects = requestObject.maxRedirects;
    }
    else {
        axiosConfig.maxRedirects = 0;
    }
    const host = getHostFromRequestObject(requestObject);
    const agentOptions = { ...requestObject.agentOptions };
    if (host) {
        agentOptions.servername = host;
    }
    if (requestObject.rejectUnauthorized === false) {
        agentOptions.rejectUnauthorized = false;
        agentOptions.secureOptions = crypto_1.default.constants.SSL_OP_LEGACY_SERVER_CONNECT;
    }
    axiosConfig.httpsAgent = new https_1.Agent(agentOptions);
    axiosConfig.beforeRedirect = getBeforeRedirectFn(agentOptions, axiosConfig);
    if (requestObject.timeout !== undefined) {
        axiosConfig.timeout = requestObject.timeout;
    }
    if (requestObject.proxy !== undefined) {
        if (typeof requestObject.proxy === 'string') {
            try {
                const url = new url_1.URL(requestObject.proxy);
                const host = url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname;
                axiosConfig.proxy = {
                    host,
                    port: parseInt(url.port, 10),
                    protocol: url.protocol,
                };
                if (!url.port) {
                    if (url.protocol === 'http') {
                        axiosConfig.proxy.port = 80;
                    }
                    else if (url.protocol === 'https') {
                        axiosConfig.proxy.port = 443;
                    }
                }
                if (url.username || url.password) {
                    axiosConfig.proxy.auth = {
                        username: url.username,
                        password: url.password,
                    };
                }
            }
            catch (error) {
                if (requestObject.proxy.includes('@')) {
                    const [userpass, hostport] = requestObject.proxy.split('@');
                    const [username, password] = userpass.split(':');
                    const [hostname, port] = hostport.split(':');
                    const host = hostname.startsWith('[') ? hostname.slice(1, -1) : hostname;
                    axiosConfig.proxy = {
                        host,
                        port: parseInt(port, 10),
                        protocol: 'http',
                        auth: {
                            username,
                            password,
                        },
                    };
                }
                else if (requestObject.proxy.includes(':')) {
                    const [hostname, port] = requestObject.proxy.split(':');
                    axiosConfig.proxy = {
                        host: hostname,
                        port: parseInt(port, 10),
                        protocol: 'http',
                    };
                }
                else {
                    axiosConfig.proxy = {
                        host: requestObject.proxy,
                        port: 80,
                        protocol: 'http',
                    };
                }
            }
        }
        else {
            axiosConfig.proxy = requestObject.proxy;
        }
    }
    if (requestObject.useStream) {
        axiosConfig.responseType = 'stream';
    }
    else if (requestObject.encoding === null) {
        axiosConfig.responseType = 'arraybuffer';
    }
    const allHeaders = axiosConfig.headers ? Object.keys(axiosConfig.headers) : [];
    if (!allHeaders.some((headerKey) => headerKey.toLowerCase() === 'accept')) {
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, { accept: '*/*' });
    }
    if (requestObject.json !== false &&
        axiosConfig.data !== undefined &&
        axiosConfig.data !== '' &&
        !(axiosConfig.data instanceof Buffer) &&
        !allHeaders.some((headerKey) => headerKey.toLowerCase() === 'content-type')) {
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
            'content-type': 'application/json',
        });
    }
    if (requestObject.simple === false) {
        axiosConfig.validateStatus = () => true;
    }
    return axiosConfig;
}
function digestAuthAxiosConfig(axiosConfig, response, auth) {
    const authDetails = response.headers['www-authenticate']
        .split(',')
        .map((v) => v.split('='));
    if (authDetails) {
        const nonceCount = '000000001';
        const cnonce = crypto_1.default.randomBytes(24).toString('hex');
        const realm = authDetails
            .find((el) => el[0].toLowerCase().indexOf('realm') > -1)[1]
            .replace(/"/g, '');
        const opaqueKV = authDetails.find((el) => el[0].toLowerCase().indexOf('opaque') > -1);
        const opaque = opaqueKV ? opaqueKV[1].replace(/"/g, '') : undefined;
        const nonce = authDetails
            .find((el) => el[0].toLowerCase().indexOf('nonce') > -1)[1]
            .replace(/"/g, '');
        const ha1 = crypto_1.default
            .createHash('md5')
            .update(`${auth?.username}:${realm}:${auth?.password}`)
            .digest('hex');
        const urlURL = new url_1.default.URL(axios_1.default.getUri(axiosConfig));
        const path = urlURL.pathname + urlURL.search;
        const ha2 = crypto_1.default
            .createHash('md5')
            .update(`${axiosConfig.method ?? 'GET'}:${path}`)
            .digest('hex');
        const response = crypto_1.default
            .createHash('md5')
            .update(`${ha1}:${nonce}:${nonceCount}:${cnonce}:auth:${ha2}`)
            .digest('hex');
        let authorization = `Digest username="${auth?.username}",realm="${realm}",` +
            `nonce="${nonce}",uri="${path}",qop="auth",algorithm="MD5",` +
            `response="${response}",nc="${nonceCount}",cnonce="${cnonce}"`;
        if (opaque) {
            authorization += `,opaque="${opaque}"`;
        }
        if (axiosConfig.headers) {
            axiosConfig.headers.authorization = authorization;
        }
        else {
            axiosConfig.headers = { authorization };
        }
    }
    return axiosConfig;
}
function parseHeaderParameters(parameters) {
    return parameters.reduce((acc, param) => {
        const [key, value] = param.split('=');
        acc[key.toLowerCase().trim()] = decodeURIComponent(value);
        return acc;
    }, {});
}
function parseContentType(contentType) {
    if (!contentType) {
        return null;
    }
    const [type, ...parameters] = contentType.split(';');
    return {
        type: type.toLowerCase(),
        parameters: { charset: 'utf-8', ...parseHeaderParameters(parameters) },
    };
}
function parseFileName(filename) {
    if (filename?.startsWith('"') && filename?.endsWith('"')) {
        return filename.slice(1, -1);
    }
    return filename;
}
function parseFileNameStar(filename) {
    const [_encoding, _locale, content] = parseFileName(filename)?.split("'") ?? [];
    return content;
}
function parseContentDisposition(contentDisposition) {
    if (!contentDisposition) {
        return null;
    }
    if (!contentDisposition.startsWith('attachment') && !contentDisposition.startsWith('inline')) {
        contentDisposition = `attachment; ${contentDisposition}`;
    }
    const [type, ...parameters] = contentDisposition.split(';');
    const parsedParameters = parseHeaderParameters(parameters);
    return {
        type,
        filename: parseFileNameStar(parsedParameters['filename*']) ?? parseFileName(parsedParameters.filename),
    };
}
function parseIncomingMessage(message) {
    const contentType = parseContentType(message.headers['content-type']);
    if (contentType) {
        const { type, parameters } = contentType;
        message.contentType = type;
        message.encoding = parameters.charset.toLowerCase();
    }
    const contentDisposition = parseContentDisposition(message.headers['content-disposition']);
    if (contentDisposition) {
        message.contentDisposition = contentDisposition;
    }
}
async function binaryToString(body, encoding) {
    const buffer = await (0, utils_1.binaryToBuffer)(body);
    if (!encoding && body instanceof http_1.IncomingMessage) {
        parseIncomingMessage(body);
        encoding = body.encoding;
    }
    return buffer.toString(encoding);
}
async function proxyRequestToAxios(workflow, additionalData, node, uriOrObject, options) {
    let axiosConfig = {
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
    };
    let configObject;
    if (typeof uriOrObject === 'string') {
        configObject = { uri: uriOrObject, ...options };
    }
    else {
        configObject = uriOrObject ?? {};
    }
    axiosConfig = Object.assign(axiosConfig, await parseRequestObject(configObject));
    let requestFn;
    if (configObject.auth?.sendImmediately === false) {
        requestFn = async () => {
            try {
                return await (0, axios_1.default)(axiosConfig);
            }
            catch (error) {
                const { response } = error;
                if (response?.status !== 401 || !response.headers['www-authenticate']?.includes('nonce')) {
                    throw error;
                }
                const { auth } = axiosConfig;
                delete axiosConfig.auth;
                axiosConfig = digestAuthAxiosConfig(axiosConfig, response, auth);
                return await (0, axios_1.default)(axiosConfig);
            }
        };
    }
    else {
        requestFn = async () => await (0, axios_1.default)(axiosConfig);
    }
    try {
        const response = await requestFn();
        let body = response.data;
        if (body instanceof http_1.IncomingMessage && axiosConfig.responseType === 'stream') {
            parseIncomingMessage(body);
        }
        else if (body === '') {
            body = axiosConfig.responseType === 'arraybuffer' ? Buffer.alloc(0) : undefined;
        }
        await additionalData?.hooks?.executeHookFunctions('nodeFetchedData', [workflow?.id, node]);
        return configObject.resolveWithFullResponse
            ? {
                body,
                headers: { ...response.headers },
                statusCode: response.status,
                statusMessage: response.statusText,
                request: response.request,
            }
            : body;
    }
    catch (error) {
        const { config, response } = error;
        if (error.isAxiosError) {
            error.config = error.request = undefined;
            error.options = (0, pick_1.default)(config ?? {}, ['url', 'method', 'data', 'headers']);
            if (response) {
                n8n_workflow_1.LoggerProxy.debug('Request proxied to Axios failed', { status: response.status });
                let responseData = response.data;
                if (Buffer.isBuffer(responseData) || responseData instanceof stream_1.Readable) {
                    responseData = await binaryToString(responseData);
                }
                if (configObject.simple === false) {
                    if (configObject.resolveWithFullResponse) {
                        return {
                            body: responseData,
                            headers: response.headers,
                            statusCode: response.status,
                            statusMessage: response.statusText,
                        };
                    }
                    else {
                        return responseData;
                    }
                }
                error.message = `${response.status} - ${JSON.stringify(responseData)}`;
                throw Object.assign(error, {
                    statusCode: response.status,
                    status: response.status,
                    error: responseData,
                    response: (0, pick_1.default)(response, ['headers', 'status', 'statusText']),
                });
            }
            else if ('rejectUnauthorized' in configObject && error.code?.includes('CERT')) {
                throw new n8n_workflow_1.NodeSslError(error);
            }
        }
        throw error;
    }
}
function convertN8nRequestToAxios(n8nRequest) {
    const { headers, method, timeout, auth, proxy, url } = n8nRequest;
    const axiosRequest = {
        headers: headers ?? {},
        method,
        timeout,
        auth,
        proxy,
        url,
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
    };
    axiosRequest.params = n8nRequest.qs;
    if (n8nRequest.baseURL !== undefined) {
        axiosRequest.baseURL = n8nRequest.baseURL;
    }
    if (n8nRequest.disableFollowRedirect === true) {
        axiosRequest.maxRedirects = 0;
    }
    if (n8nRequest.encoding !== undefined) {
        axiosRequest.responseType = n8nRequest.encoding;
    }
    const host = getHostFromRequestObject(n8nRequest);
    const agentOptions = {};
    if (host) {
        agentOptions.servername = host;
    }
    if (n8nRequest.skipSslCertificateValidation === true) {
        agentOptions.rejectUnauthorized = false;
    }
    axiosRequest.httpsAgent = new https_1.Agent(agentOptions);
    axiosRequest.beforeRedirect = getBeforeRedirectFn(agentOptions, axiosRequest);
    if (n8nRequest.arrayFormat !== undefined) {
        axiosRequest.paramsSerializer = (params) => {
            return (0, qs_1.stringify)(params, { arrayFormat: n8nRequest.arrayFormat });
        };
    }
    const { body } = n8nRequest;
    if (body) {
        const existingContentTypeHeaderKey = searchForHeader(axiosRequest, 'content-type');
        if (existingContentTypeHeaderKey === undefined) {
            axiosRequest.headers = axiosRequest.headers || {};
            if (body instanceof form_data_1.default) {
                axiosRequest.headers = {
                    ...axiosRequest.headers,
                    ...body.getHeaders(),
                };
            }
            else if (body instanceof url_1.URLSearchParams) {
                axiosRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }
        else if (axiosRequest.headers?.[existingContentTypeHeaderKey] === 'application/x-www-form-urlencoded') {
            axiosRequest.data = new url_1.URLSearchParams(n8nRequest.body);
        }
        if (typeof body === 'string' || (typeof body === 'object' && !(0, n8n_workflow_1.isObjectEmpty)(body))) {
            axiosRequest.data = body;
        }
    }
    if (n8nRequest.json) {
        const key = searchForHeader(axiosRequest, 'accept');
        if (!key) {
            axiosRequest.headers = {
                ...axiosRequest.headers,
                Accept: 'application/json',
            };
        }
    }
    const userAgentHeader = searchForHeader(axiosRequest, 'user-agent');
    if (!userAgentHeader) {
        axiosRequest.headers = {
            ...axiosRequest.headers,
            'User-Agent': 'n8n',
        };
    }
    if (n8nRequest.ignoreHttpStatusErrors) {
        axiosRequest.validateStatus = () => true;
    }
    return axiosRequest;
}
const NoBodyHttpMethods = ['GET', 'HEAD', 'OPTIONS'];
const removeEmptyBody = (requestOptions) => {
    const method = requestOptions.method || 'GET';
    if (NoBodyHttpMethods.includes(method) && (0, isEmpty_1.default)(requestOptions.body)) {
        delete requestOptions.body;
    }
};
exports.removeEmptyBody = removeEmptyBody;
async function httpRequest(requestOptions) {
    (0, exports.removeEmptyBody)(requestOptions);
    let axiosRequest = convertN8nRequestToAxios(requestOptions);
    if (axiosRequest.data === undefined ||
        (axiosRequest.method !== undefined && axiosRequest.method.toUpperCase() === 'GET')) {
        delete axiosRequest.data;
    }
    let result;
    try {
        result = await (0, axios_1.default)(axiosRequest);
    }
    catch (error) {
        if (requestOptions.auth?.sendImmediately === false) {
            const { response } = error;
            if (response?.status !== 401 || !response.headers['www-authenticate']?.includes('nonce')) {
                throw error;
            }
            const { auth } = axiosRequest;
            delete axiosRequest.auth;
            axiosRequest = digestAuthAxiosConfig(axiosRequest, response, auth);
            result = await (0, axios_1.default)(axiosRequest);
        }
        throw error;
    }
    if (requestOptions.returnFullResponse) {
        return {
            body: result.data,
            headers: result.headers,
            statusCode: result.status,
            statusMessage: result.statusText,
        };
    }
    return result.data;
}
function getBinaryPath(binaryDataId) {
    return typedi_1.default.get(BinaryData_service_1.BinaryDataService).getPath(binaryDataId);
}
async function getBinaryMetadata(binaryDataId) {
    return await typedi_1.default.get(BinaryData_service_1.BinaryDataService).getMetadata(binaryDataId);
}
async function getBinaryStream(binaryDataId, chunkSize) {
    return await typedi_1.default.get(BinaryData_service_1.BinaryDataService).getAsStream(binaryDataId, chunkSize);
}
function assertBinaryData(inputData, node, itemIndex, propertyName, inputIndex) {
    const binaryKeyData = inputData.main[inputIndex][itemIndex].binary;
    if (binaryKeyData === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `This operation expects the node's input data to contain a binary file '${propertyName}', but none was found [item ${itemIndex}]`, {
            itemIndex,
            description: 'Make sure that the previous node outputs a binary file',
        });
    }
    const binaryPropertyData = binaryKeyData[propertyName];
    if (binaryPropertyData === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `The item has no binary field '${propertyName}' [item ${itemIndex}]`, {
            itemIndex,
            description: 'Check that the parameter where you specified the input binary field name is correct, and that it matches a field in the binary input',
        });
    }
    return binaryPropertyData;
}
async function getBinaryDataBuffer(inputData, itemIndex, propertyName, inputIndex) {
    const binaryData = inputData.main[inputIndex][itemIndex].binary[propertyName];
    return await typedi_1.default.get(BinaryData_service_1.BinaryDataService).getAsBuffer(binaryData);
}
async function setBinaryDataBuffer(binaryData, bufferOrStream, workflowId, executionId) {
    return await typedi_1.default.get(BinaryData_service_1.BinaryDataService).store(workflowId, executionId, bufferOrStream, binaryData);
}
async function copyBinaryFile(workflowId, executionId, filePath, fileName, mimeType) {
    let fileExtension;
    if (!mimeType) {
        if (filePath) {
            const mimeTypeLookup = (0, mime_types_1.lookup)(filePath);
            if (mimeTypeLookup) {
                mimeType = mimeTypeLookup;
            }
        }
        if (!mimeType) {
            const fileTypeData = await file_type_1.default.fromFile(filePath);
            if (fileTypeData) {
                mimeType = fileTypeData.mime;
                fileExtension = fileTypeData.ext;
            }
        }
    }
    if (!fileExtension && mimeType) {
        fileExtension = (0, mime_types_1.extension)(mimeType) || undefined;
    }
    if (!mimeType) {
        mimeType = 'text/plain';
    }
    const returnData = {
        mimeType,
        fileType: (0, n8n_workflow_1.fileTypeFromMimeType)(mimeType),
        fileExtension,
        data: '',
    };
    if (fileName) {
        returnData.fileName = fileName;
    }
    else if (filePath) {
        returnData.fileName = path_1.default.parse(filePath).base;
    }
    return await typedi_1.default.get(BinaryData_service_1.BinaryDataService).copyBinaryFile(workflowId, executionId, returnData, filePath);
}
async function prepareBinaryData(binaryData, executionId, workflowId, filePath, mimeType) {
    let fileExtension;
    if (binaryData instanceof http_1.IncomingMessage) {
        if (!filePath) {
            try {
                const { responseUrl } = binaryData;
                filePath =
                    binaryData.contentDisposition?.filename ??
                        ((responseUrl && new url_1.URL(responseUrl).pathname) ?? binaryData.req?.path)?.slice(1);
            }
            catch { }
        }
        if (!mimeType) {
            mimeType = binaryData.contentType;
        }
    }
    if (!mimeType) {
        if (filePath) {
            const mimeTypeLookup = (0, mime_types_1.lookup)(filePath);
            if (mimeTypeLookup) {
                mimeType = mimeTypeLookup;
            }
        }
        if (!mimeType) {
            if (Buffer.isBuffer(binaryData)) {
                const fileTypeData = await file_type_1.default.fromBuffer(binaryData);
                if (fileTypeData) {
                    mimeType = fileTypeData.mime;
                    fileExtension = fileTypeData.ext;
                }
            }
            else if (binaryData instanceof http_1.IncomingMessage) {
                mimeType = binaryData.headers['content-type'];
            }
            else {
            }
        }
    }
    if (!fileExtension && mimeType) {
        fileExtension = (0, mime_types_1.extension)(mimeType) || undefined;
    }
    if (!mimeType) {
        mimeType = 'text/plain';
    }
    const returnData = {
        mimeType,
        fileType: (0, n8n_workflow_1.fileTypeFromMimeType)(mimeType),
        fileExtension,
        data: '',
    };
    if (filePath) {
        if (filePath.includes('?')) {
            filePath = filePath.split('?').shift();
        }
        const filePathParts = path_1.default.parse(filePath);
        if (filePathParts.dir !== '') {
            returnData.directory = filePathParts.dir;
        }
        returnData.fileName = filePathParts.base;
        const fileExtension = filePathParts.ext.slice(1);
        if (fileExtension) {
            returnData.fileExtension = fileExtension;
        }
    }
    return await setBinaryDataBuffer(returnData, binaryData, workflowId, executionId);
}
async function checkProcessedAndRecord(items, scope, contextData, options) {
    return await data_deduplication_service_1.DataDeduplicationService.getInstance().checkProcessedAndRecord(items, scope, contextData, options);
}
async function checkProcessedItemsAndRecord(key, items, scope, contextData, options) {
    return await data_deduplication_service_1.DataDeduplicationService.getInstance().checkProcessedItemsAndRecord(key, items, scope, contextData, options);
}
async function removeProcessed(items, scope, contextData, options) {
    return await data_deduplication_service_1.DataDeduplicationService.getInstance().removeProcessed(items, scope, contextData, options);
}
async function clearAllProcessedItems(scope, contextData, options) {
    return await data_deduplication_service_1.DataDeduplicationService.getInstance().clearAllProcessedItems(scope, contextData, options);
}
async function getProcessedDataCount(scope, contextData, options) {
    return await data_deduplication_service_1.DataDeduplicationService.getInstance().getProcessedDataCount(scope, contextData, options);
}
function applyPaginationRequestData(requestData, paginationRequestData) {
    const preparedPaginationData = {
        ...paginationRequestData,
        uri: paginationRequestData.url,
    };
    if ('formData' in requestData) {
        preparedPaginationData.formData = paginationRequestData.body;
        delete preparedPaginationData.body;
    }
    else if ('form' in requestData) {
        preparedPaginationData.form = paginationRequestData.body;
        delete preparedPaginationData.body;
    }
    return (0, merge_1.default)({}, requestData, preparedPaginationData);
}
async function requestOAuth2(credentialsType, requestOptions, node, additionalData, oAuth2Options, isN8nRequest = false) {
    (0, exports.removeEmptyBody)(requestOptions);
    const credentials = (await this.getCredentials(credentialsType));
    if (credentials.grantType === 'authorizationCode' && credentials.oauthTokenData === undefined) {
        throw new n8n_workflow_1.ApplicationError('OAuth credentials not connected');
    }
    const oAuthClient = new client_oauth2_1.ClientOAuth2({
        clientId: credentials.clientId,
        clientSecret: credentials.clientSecret,
        accessTokenUri: credentials.accessTokenUrl,
        scopes: credentials.scope.split(' '),
        ignoreSSLIssues: credentials.ignoreSSLIssues,
        authentication: credentials.authentication ?? 'header',
    });
    let oauthTokenData = credentials.oauthTokenData;
    if (credentials.grantType === 'clientCredentials' &&
        (oauthTokenData === undefined ||
            Object.keys(oauthTokenData).length === 0 ||
            oauthTokenData.access_token === '')) {
        const { data } = await oAuthClient.credentials.getToken();
        if (!node.credentials?.[credentialsType]) {
            throw new n8n_workflow_1.ApplicationError('Node does not have credential type', {
                extra: { nodeName: node.name },
                tags: { credentialType: credentialsType },
            });
        }
        const nodeCredentials = node.credentials[credentialsType];
        credentials.oauthTokenData = data;
        await additionalData.credentialsHelper.updateCredentials(nodeCredentials, credentialsType, credentials);
        oauthTokenData = data;
    }
    const accessToken = (0, get_1.default)(oauthTokenData, oAuth2Options?.property) || oauthTokenData.accessToken;
    const refreshToken = oauthTokenData.refreshToken;
    const token = oAuthClient.createToken({
        ...oauthTokenData,
        ...(accessToken ? { access_token: accessToken } : {}),
        ...(refreshToken ? { refresh_token: refreshToken } : {}),
    }, oAuth2Options?.tokenType || oauthTokenData.tokenType);
    requestOptions.rejectUnauthorized = !credentials.ignoreSSLIssues;
    const newRequestOptions = token.sign(requestOptions);
    const newRequestHeaders = (newRequestOptions.headers = newRequestOptions.headers ?? {});
    if (oAuth2Options?.keepBearer === false && typeof newRequestHeaders.Authorization === 'string') {
        newRequestHeaders.Authorization = newRequestHeaders.Authorization.split(' ')[1];
    }
    if (oAuth2Options?.keyToIncludeInAccessTokenHeader) {
        Object.assign(newRequestHeaders, {
            [oAuth2Options.keyToIncludeInAccessTokenHeader]: token.accessToken,
        });
    }
    if (isN8nRequest) {
        return await this.helpers.httpRequest(newRequestOptions).catch(async (error) => {
            if (error.response?.status === 401) {
                n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" expired. Should revalidate.`);
                const tokenRefreshOptions = {};
                if (oAuth2Options?.includeCredentialsOnRefreshOnBody) {
                    const body = {
                        client_id: credentials.clientId,
                        ...(credentials.grantType === 'authorizationCode' && {
                            client_secret: credentials.clientSecret,
                        }),
                    };
                    tokenRefreshOptions.body = body;
                    tokenRefreshOptions.headers = {
                        Authorization: '',
                    };
                }
                let newToken;
                n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been renewed.`);
                if (credentials.grantType === 'clientCredentials') {
                    newToken = await token.client.credentials.getToken();
                }
                else {
                    newToken = await token.refresh(tokenRefreshOptions);
                }
                n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been renewed.`);
                credentials.oauthTokenData = newToken.data;
                if (!node.credentials?.[credentialsType]) {
                    throw new n8n_workflow_1.ApplicationError('Node does not have credential type', {
                        extra: { nodeName: node.name, credentialType: credentialsType },
                    });
                }
                const nodeCredentials = node.credentials[credentialsType];
                await additionalData.credentialsHelper.updateCredentials(nodeCredentials, credentialsType, credentials);
                const refreshedRequestOption = newToken.sign(requestOptions);
                if (oAuth2Options?.keyToIncludeInAccessTokenHeader) {
                    Object.assign(newRequestHeaders, {
                        [oAuth2Options.keyToIncludeInAccessTokenHeader]: token.accessToken,
                    });
                }
                return await this.helpers.httpRequest(refreshedRequestOption);
            }
            throw error;
        });
    }
    const tokenExpiredStatusCode = oAuth2Options?.tokenExpiredStatusCode === undefined
        ? 401
        : oAuth2Options?.tokenExpiredStatusCode;
    return await this.helpers
        .request(newRequestOptions)
        .then((response) => {
        const requestOptions = newRequestOptions;
        if (requestOptions.resolveWithFullResponse === true &&
            requestOptions.simple === false &&
            response.statusCode === tokenExpiredStatusCode) {
            throw response;
        }
        return response;
    })
        .catch(async (error) => {
        if (error.statusCode === tokenExpiredStatusCode) {
            const tokenRefreshOptions = {};
            if (oAuth2Options?.includeCredentialsOnRefreshOnBody) {
                const body = {
                    client_id: credentials.clientId,
                    client_secret: credentials.clientSecret,
                };
                tokenRefreshOptions.body = body;
                tokenRefreshOptions.headers = {
                    Authorization: '',
                };
            }
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" expired. Should revalidate.`);
            let newToken;
            if (credentials.grantType === 'clientCredentials') {
                newToken = await token.client.credentials.getToken();
            }
            else {
                newToken = await token.refresh(tokenRefreshOptions);
            }
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been renewed.`);
            credentials.oauthTokenData = newToken.data;
            if (!node.credentials?.[credentialsType]) {
                throw new n8n_workflow_1.ApplicationError('Node does not have credential type', {
                    tags: { credentialType: credentialsType },
                    extra: { nodeName: node.name },
                });
            }
            const nodeCredentials = node.credentials[credentialsType];
            await additionalData.credentialsHelper.updateCredentials(nodeCredentials, credentialsType, credentials);
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been saved to database successfully.`);
            const newRequestOptions = newToken.sign(requestOptions);
            newRequestOptions.headers = newRequestOptions.headers ?? {};
            if (oAuth2Options?.keyToIncludeInAccessTokenHeader) {
                Object.assign(newRequestOptions.headers, {
                    [oAuth2Options.keyToIncludeInAccessTokenHeader]: token.accessToken,
                });
            }
            return await this.helpers.request(newRequestOptions);
        }
        throw error;
    });
}
async function requestOAuth1(credentialsType, requestOptions, isN8nRequest = false) {
    (0, exports.removeEmptyBody)(requestOptions);
    const credentials = await this.getCredentials(credentialsType);
    if (credentials === undefined) {
        throw new n8n_workflow_1.ApplicationError('No credentials were returned');
    }
    if (credentials.oauthTokenData === undefined) {
        throw new n8n_workflow_1.ApplicationError('OAuth credentials not connected');
    }
    const oauth = new oauth_1_0a_1.default({
        consumer: {
            key: credentials.consumerKey,
            secret: credentials.consumerSecret,
        },
        signature_method: credentials.signatureMethod,
        hash_function(base, key) {
            let algorithm;
            switch (credentials.signatureMethod) {
                case 'HMAC-SHA256':
                    algorithm = 'sha256';
                    break;
                case 'HMAC-SHA512':
                    algorithm = 'sha512';
                    break;
                default:
                    algorithm = 'sha1';
                    break;
            }
            return (0, crypto_1.createHmac)(algorithm, key).update(base).digest('base64');
        },
    });
    const oauthTokenData = credentials.oauthTokenData;
    const token = {
        key: oauthTokenData.oauth_token,
        secret: oauthTokenData.oauth_token_secret,
    };
    requestOptions.data = { ...requestOptions.qs, ...requestOptions.form };
    if ('uri' in requestOptions && !requestOptions.url) {
        requestOptions.url = requestOptions.uri;
        delete requestOptions.uri;
    }
    requestOptions.headers = oauth.toHeader(oauth.authorize(requestOptions, token));
    if (isN8nRequest) {
        return await this.helpers.httpRequest(requestOptions);
    }
    return await this.helpers
        .request(requestOptions)
        .catch(async (error) => {
        throw error;
    });
}
async function httpRequestWithAuthentication(credentialsType, requestOptions, workflow, node, additionalData, additionalCredentialOptions) {
    (0, exports.removeEmptyBody)(requestOptions);
    let credentialsDecrypted;
    try {
        const parentTypes = additionalData.credentialsHelper.getParentTypes(credentialsType);
        if (parentTypes.includes('oAuth1Api')) {
            return await requestOAuth1.call(this, credentialsType, requestOptions, true);
        }
        if (parentTypes.includes('oAuth2Api')) {
            return await requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, additionalCredentialOptions?.oauth2, true);
        }
        if (additionalCredentialOptions?.credentialsDecrypted) {
            credentialsDecrypted = additionalCredentialOptions.credentialsDecrypted.data;
        }
        else {
            credentialsDecrypted =
                await this.getCredentials(credentialsType);
        }
        if (credentialsDecrypted === undefined) {
            throw new n8n_workflow_1.NodeOperationError(node, `Node "${node.name}" does not have any credentials of type "${credentialsType}" set`, { level: 'warning' });
        }
        const data = await additionalData.credentialsHelper.preAuthentication({ helpers: this.helpers }, credentialsDecrypted, credentialsType, node, false);
        if (data) {
            Object.assign(credentialsDecrypted, data);
        }
        requestOptions = await additionalData.credentialsHelper.authenticate(credentialsDecrypted, credentialsType, requestOptions, workflow, node);
        return await httpRequest(requestOptions);
    }
    catch (error) {
        if (error.response?.status === 401 &&
            additionalData.credentialsHelper.preAuthentication !== undefined) {
            try {
                if (credentialsDecrypted !== undefined) {
                    const data = await additionalData.credentialsHelper.preAuthentication({ helpers: this.helpers }, credentialsDecrypted, credentialsType, node, true);
                    if (data) {
                        Object.assign(credentialsDecrypted, data);
                    }
                    requestOptions = await additionalData.credentialsHelper.authenticate(credentialsDecrypted, credentialsType, requestOptions, workflow, node);
                }
                return await httpRequest(requestOptions);
            }
            catch (error) {
                throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
            }
        }
        throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
    }
}
function returnJsonArray(jsonData) {
    const returnData = [];
    if (!Array.isArray(jsonData)) {
        jsonData = [jsonData];
    }
    jsonData.forEach((data) => {
        if (data?.json) {
            returnData.push({ ...data, json: data.json });
        }
        else {
            returnData.push({ json: data });
        }
    });
    return returnData;
}
function constructExecutionMetaData(inputData, options) {
    const { itemData } = options;
    return inputData.map((data) => {
        const { json, ...rest } = data;
        return { json, pairedItem: itemData, ...rest };
    });
}
function normalizeItems(executionData) {
    if (typeof executionData === 'object' && !Array.isArray(executionData)) {
        executionData = executionData.json ? [executionData] : [{ json: executionData }];
    }
    if (executionData.every((item) => typeof item === 'object' && 'json' in item))
        return executionData;
    if (executionData.some((item) => typeof item === 'object' && 'json' in item)) {
        throw new n8n_workflow_1.ApplicationError('Inconsistent item format');
    }
    if (executionData.every((item) => typeof item === 'object' && 'binary' in item)) {
        const normalizedItems = [];
        executionData.forEach((item) => {
            const json = Object.keys(item).reduce((acc, key) => {
                if (key === 'binary')
                    return acc;
                return { ...acc, [key]: item[key] };
            }, {});
            normalizedItems.push({
                json,
                binary: item.binary,
            });
        });
        return normalizedItems;
    }
    if (executionData.some((item) => typeof item === 'object' && 'binary' in item)) {
        throw new n8n_workflow_1.ApplicationError('Inconsistent item format');
    }
    return executionData.map((item) => {
        return { json: item };
    });
}
async function requestWithAuthentication(credentialsType, requestOptions, workflow, node, additionalData, additionalCredentialOptions, itemIndex) {
    (0, exports.removeEmptyBody)(requestOptions);
    let credentialsDecrypted;
    try {
        const parentTypes = additionalData.credentialsHelper.getParentTypes(credentialsType);
        if (credentialsType === 'oAuth1Api' || parentTypes.includes('oAuth1Api')) {
            return await requestOAuth1.call(this, credentialsType, requestOptions, false);
        }
        if (credentialsType === 'oAuth2Api' || parentTypes.includes('oAuth2Api')) {
            return await requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, additionalCredentialOptions?.oauth2, false);
        }
        if (additionalCredentialOptions?.credentialsDecrypted) {
            credentialsDecrypted = additionalCredentialOptions.credentialsDecrypted.data;
        }
        else {
            credentialsDecrypted = await this.getCredentials(credentialsType, itemIndex);
        }
        if (credentialsDecrypted === undefined) {
            throw new n8n_workflow_1.NodeOperationError(node, `Node "${node.name}" does not have any credentials of type "${credentialsType}" set`, { level: 'warning' });
        }
        const data = await additionalData.credentialsHelper.preAuthentication({ helpers: this.helpers }, credentialsDecrypted, credentialsType, node, false);
        if (data) {
            Object.assign(credentialsDecrypted, data);
        }
        requestOptions = (await additionalData.credentialsHelper.authenticate(credentialsDecrypted, credentialsType, requestOptions, workflow, node));
        return await proxyRequestToAxios(workflow, additionalData, node, requestOptions);
    }
    catch (error) {
        try {
            if (credentialsDecrypted !== undefined) {
                const data = await additionalData.credentialsHelper.preAuthentication({ helpers: this.helpers }, credentialsDecrypted, credentialsType, node, true);
                if (data) {
                    Object.assign(credentialsDecrypted, data);
                    requestOptions = (await additionalData.credentialsHelper.authenticate(credentialsDecrypted, credentialsType, requestOptions, workflow, node));
                    return await proxyRequestToAxios(workflow, additionalData, node, requestOptions);
                }
            }
            throw error;
        }
        catch (error) {
            if (error instanceof n8n_workflow_1.ExecutionBaseError)
                throw error;
            throw new n8n_workflow_1.NodeApiError(this.getNode(), error);
        }
    }
}
function getAdditionalKeys(additionalData, mode, runExecutionData, options) {
    const executionId = additionalData.executionId || Constants_1.PLACEHOLDER_EMPTY_EXECUTION_ID;
    const resumeUrl = `${additionalData.webhookWaitingBaseUrl}/${executionId}`;
    const resumeFormUrl = `${additionalData.formWaitingBaseUrl}/${executionId}`;
    return {
        $execution: {
            id: executionId,
            mode: mode === 'manual' ? 'test' : 'production',
            resumeUrl,
            resumeFormUrl,
            customData: runExecutionData
                ? {
                    set(key, value) {
                        try {
                            (0, ExecutionMetadata_1.setWorkflowExecutionMetadata)(runExecutionData, key, value);
                        }
                        catch (e) {
                            if (mode === 'manual') {
                                throw e;
                            }
                            n8n_workflow_1.LoggerProxy.debug(e.message);
                        }
                    },
                    setAll(obj) {
                        try {
                            (0, ExecutionMetadata_1.setAllWorkflowExecutionMetadata)(runExecutionData, obj);
                        }
                        catch (e) {
                            if (mode === 'manual') {
                                throw e;
                            }
                            n8n_workflow_1.LoggerProxy.debug(e.message);
                        }
                    },
                    get(key) {
                        return (0, ExecutionMetadata_1.getWorkflowExecutionMetadata)(runExecutionData, key);
                    },
                    getAll() {
                        return (0, ExecutionMetadata_1.getAllWorkflowExecutionMetadata)(runExecutionData);
                    },
                }
                : undefined,
        },
        $vars: additionalData.variables,
        $secrets: options?.secretsEnabled ? (0, Secrets_1.getSecretsProxy)(additionalData) : undefined,
        $executionId: executionId,
        $resumeWebhookUrl: resumeUrl,
    };
}
async function getCredentials(workflow, node, type, additionalData, mode, executeData, runExecutionData, runIndex, connectionInputData, itemIndex) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" is not known so can not get credentials`);
    }
    const fullAccess = [Constants_1.HTTP_REQUEST_NODE_TYPE, Constants_1.HTTP_REQUEST_TOOL_NODE_TYPE].includes(node.type);
    let nodeCredentialDescription;
    if (!fullAccess) {
        if (nodeType.description.credentials === undefined) {
            throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials defined`, { level: 'warning' });
        }
        nodeCredentialDescription = nodeType.description.credentials.find((credentialTypeDescription) => credentialTypeDescription.name === type);
        if (nodeCredentialDescription === undefined) {
            throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials of type "${type}" defined`, { level: 'warning' });
        }
        if (!n8n_workflow_1.NodeHelpers.displayParameter(additionalData.currentNodeParameters || node.parameters, nodeCredentialDescription, node, node.parameters)) {
            throw new n8n_workflow_1.NodeOperationError(node, 'Credentials not found');
        }
    }
    if (!fullAccess && !node.credentials?.[type]) {
        if (nodeCredentialDescription?.required === true) {
            if (!node.credentials) {
                throw new n8n_workflow_1.NodeOperationError(node, 'Node does not have any credentials set', {
                    level: 'warning',
                });
            }
            if (!node.credentials[type]) {
                throw new n8n_workflow_1.NodeOperationError(node, `Node does not have any credentials set for "${type}"`, {
                    level: 'warning',
                });
            }
        }
        else {
            throw new n8n_workflow_1.NodeOperationError(node, 'Node does not require credentials');
        }
    }
    if (fullAccess && !node.credentials?.[type]) {
        throw new n8n_workflow_1.NodeOperationError(node, 'Credentials not found');
    }
    let expressionResolveValues;
    if (connectionInputData && runExecutionData && runIndex !== undefined) {
        expressionResolveValues = {
            connectionInputData,
            itemIndex: itemIndex || 0,
            node,
            runExecutionData,
            runIndex,
            workflow,
        };
    }
    const nodeCredentials = node.credentials
        ? node.credentials[type]
        : {};
    const decryptedDataObject = await additionalData.credentialsHelper.getDecrypted(additionalData, nodeCredentials, type, mode, executeData, false, expressionResolveValues);
    return decryptedDataObject;
}
function cleanupParameterData(inputData) {
    if (typeof inputData !== 'object' || inputData === null) {
        return;
    }
    if (Array.isArray(inputData)) {
        inputData.forEach((value) => cleanupParameterData(value));
        return;
    }
    if (typeof inputData === 'object') {
        Object.keys(inputData).forEach((key) => {
            const value = inputData[key];
            if (typeof value === 'object') {
                if (luxon_1.DateTime.isDateTime(value)) {
                    inputData[key] = value.toString();
                }
                else {
                    cleanupParameterData(value);
                }
            }
        });
    }
}
const validateResourceMapperValue = (parameterName, paramValues, node, skipRequiredCheck = false) => {
    const result = { valid: true, newValue: paramValues };
    const paramNameParts = parameterName.split('.');
    if (paramNameParts.length !== 2) {
        return result;
    }
    const resourceMapperParamName = paramNameParts[0];
    const resourceMapperField = node.parameters[resourceMapperParamName];
    if (!resourceMapperField || !(0, n8n_workflow_1.isResourceMapperValue)(resourceMapperField)) {
        return result;
    }
    const schema = resourceMapperField.schema;
    const paramValueNames = Object.keys(paramValues);
    for (let i = 0; i < paramValueNames.length; i++) {
        const key = paramValueNames[i];
        const resolvedValue = paramValues[key];
        const schemaEntry = schema.find((s) => s.id === key);
        if (!skipRequiredCheck &&
            schemaEntry?.required === true &&
            schemaEntry.type !== 'boolean' &&
            !resolvedValue) {
            return {
                valid: false,
                errorMessage: `The value "${String(key)}" is required but not set`,
                fieldName: key,
            };
        }
        if (schemaEntry?.type) {
            const validationResult = (0, n8n_workflow_1.validateFieldType)(key, resolvedValue, schemaEntry.type, {
                valueOptions: schemaEntry.options,
            });
            if (!validationResult.valid) {
                return { ...validationResult, fieldName: key };
            }
            else {
                paramValues[key] = validationResult.newValue;
            }
        }
    }
    return result;
};
const validateCollection = (node, runIndex, itemIndex, propertyDescription, parameterPath, validationResult) => {
    let nestedDescriptions;
    if (propertyDescription.type === 'fixedCollection') {
        nestedDescriptions = propertyDescription.options.find((entry) => entry.name === parameterPath[1])?.values;
    }
    if (propertyDescription.type === 'collection') {
        nestedDescriptions = propertyDescription.options;
    }
    if (!nestedDescriptions) {
        return validationResult;
    }
    const validationMap = {};
    for (const prop of nestedDescriptions) {
        if (!prop.validateType || prop.ignoreValidationDuringExecution)
            continue;
        validationMap[prop.name] = {
            type: prop.validateType,
            displayName: prop.displayName,
            options: prop.validateType === 'options' ? prop.options : undefined,
        };
    }
    if (!Object.keys(validationMap).length) {
        return validationResult;
    }
    if (validationResult.valid) {
        for (const value of Array.isArray(validationResult.newValue)
            ? validationResult.newValue
            : [validationResult.newValue]) {
            for (const key of Object.keys(value)) {
                if (!validationMap[key])
                    continue;
                const fieldValidationResult = (0, n8n_workflow_1.validateFieldType)(key, value[key], validationMap[key].type, {
                    valueOptions: validationMap[key].options,
                });
                if (!fieldValidationResult.valid) {
                    throw new n8n_workflow_1.ExpressionError(`Invalid input for field '${validationMap[key].displayName}' inside '${propertyDescription.displayName}' in [item ${itemIndex}]`, {
                        description: fieldValidationResult.errorMessage,
                        runIndex,
                        itemIndex,
                        nodeCause: node.name,
                    });
                }
                value[key] = fieldValidationResult.newValue;
            }
        }
    }
    return validationResult;
};
const validateValueAgainstSchema = (node, nodeType, parameterValue, parameterName, runIndex, itemIndex) => {
    const parameterPath = parameterName.split('.');
    const propertyDescription = nodeType.description.properties.find((prop) => parameterPath[0] === prop.name && n8n_workflow_1.NodeHelpers.displayParameter(node.parameters, prop, node));
    if (!propertyDescription) {
        return parameterValue;
    }
    let validationResult = { valid: true, newValue: parameterValue };
    if (parameterPath.length === 1 &&
        propertyDescription.validateType &&
        !propertyDescription.ignoreValidationDuringExecution) {
        validationResult = (0, n8n_workflow_1.validateFieldType)(parameterName, parameterValue, propertyDescription.validateType);
    }
    else if (propertyDescription.type === 'resourceMapper' &&
        parameterPath[1] === 'value' &&
        typeof parameterValue === 'object') {
        validationResult = validateResourceMapperValue(parameterName, parameterValue, node, propertyDescription.typeOptions?.resourceMapper?.mode !== 'add');
    }
    else if (['fixedCollection', 'collection'].includes(propertyDescription.type)) {
        validationResult = validateCollection(node, runIndex, itemIndex, propertyDescription, parameterPath, validationResult);
    }
    if (!validationResult.valid) {
        throw new n8n_workflow_1.ExpressionError(`Invalid input for '${validationResult.fieldName
            ? String(validationResult.fieldName)
            : propertyDescription.displayName}' [item ${itemIndex}]`, {
            description: validationResult.errorMessage,
            runIndex,
            itemIndex,
            nodeCause: node.name,
        });
    }
    return validationResult.newValue;
};
exports.validateValueAgainstSchema = validateValueAgainstSchema;
function ensureType(toType, parameterValue, parameterName, errorOptions) {
    let returnData = parameterValue;
    if (returnData === null) {
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must not be null`, errorOptions);
    }
    if (returnData === undefined) {
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be 'undefined'`, errorOptions);
    }
    if (['object', 'array', 'json'].includes(toType)) {
        if (typeof returnData !== 'object') {
            if (typeof returnData === 'string' && returnData.length) {
                try {
                    const parsedValue = JSON.parse(returnData);
                    returnData = parsedValue;
                }
                catch (error) {
                    throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be parsed`, {
                        ...errorOptions,
                        description: error.message,
                    });
                }
            }
            else {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be an ${toType}, but we got '${String(parameterValue)}'`, errorOptions);
            }
        }
        else if (toType === 'json') {
            try {
                JSON.stringify(returnData);
            }
            catch (error) {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' is not valid JSON`, {
                    ...errorOptions,
                    description: error.message,
                });
            }
        }
        if (toType === 'array' && !Array.isArray(returnData)) {
            throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be an array, but we got object`, errorOptions);
        }
    }
    try {
        if (toType === 'string') {
            if (typeof returnData === 'object') {
                returnData = JSON.stringify(returnData);
            }
            else {
                returnData = String(returnData);
            }
        }
        if (toType === 'number') {
            returnData = Number(returnData);
            if (Number.isNaN(returnData)) {
                throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' must be a number, but we got '${parameterValue}'`, errorOptions);
            }
        }
        if (toType === 'boolean') {
            returnData = Boolean(returnData);
        }
    }
    catch (error) {
        if (error instanceof n8n_workflow_1.ExpressionError)
            throw error;
        throw new n8n_workflow_1.ExpressionError(`Parameter '${parameterName}' could not be converted to ${toType}`, {
            ...errorOptions,
            description: error.message,
        });
    }
    return returnData;
}
function getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, additionalKeys, executeData, fallbackValue, options) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType === undefined) {
        throw new n8n_workflow_1.ApplicationError('Node type is unknown so cannot return parameter value', {
            tags: { nodeType: node.type },
        });
    }
    const value = (0, get_1.default)(node.parameters, parameterName, fallbackValue);
    if (value === undefined) {
        throw new n8n_workflow_1.ApplicationError('Could not get parameter', { extra: { parameterName } });
    }
    if (options?.rawExpressions) {
        return value;
    }
    let returnData;
    try {
        returnData = workflow.expression.getParameterValue(value, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys, executeData, false, {}, options?.contextNode?.name);
        cleanupParameterData(returnData);
    }
    catch (e) {
        if (e instanceof n8n_workflow_1.ExpressionError && node.continueOnFail && node.type === 'n8n-nodes-base.set') {
            returnData = [{ name: undefined, value: undefined }];
        }
        else {
            if (e.context)
                e.context.parameter = parameterName;
            e.cause = value;
            throw e;
        }
    }
    if (options?.extractValue) {
        returnData = (0, ExtractValue_1.extractValue)(returnData, parameterName, node, nodeType, itemIndex);
    }
    if (options?.ensureType) {
        returnData = ensureType(options.ensureType, returnData, parameterName, {
            itemIndex,
            runIndex,
            nodeCause: node.name,
        });
    }
    returnData = (0, exports.validateValueAgainstSchema)(node, nodeType, returnData, parameterName, runIndex, itemIndex);
    return returnData;
}
function continueOnFail(node) {
    const onError = (0, get_1.default)(node, 'onError', undefined);
    if (onError === undefined) {
        return (0, get_1.default)(node, 'continueOnFail', false);
    }
    return ['continueRegularOutput', 'continueErrorOutput'].includes(onError);
}
function getNodeWebhookUrl(name, workflow, node, additionalData, mode, additionalKeys, isTest) {
    let baseUrl = additionalData.webhookBaseUrl;
    if (isTest === true) {
        baseUrl = additionalData.webhookTestBaseUrl;
    }
    const webhookDescription = getWebhookDescription(name, workflow, node);
    if (webhookDescription === undefined) {
        return undefined;
    }
    const path = workflow.expression.getSimpleParameterValue(node, webhookDescription.path, mode, additionalKeys);
    if (path === undefined) {
        return undefined;
    }
    const isFullPath = workflow.expression.getSimpleParameterValue(node, webhookDescription.isFullPath, mode, additionalKeys, undefined, false);
    return n8n_workflow_1.NodeHelpers.getNodeWebhookUrl(baseUrl, workflow.id, node, path.toString(), isFullPath);
}
function getWebhookDescription(name, workflow, node) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType.description.webhooks === undefined) {
        return undefined;
    }
    for (const webhookDescription of nodeType.description.webhooks) {
        if (webhookDescription.name === name) {
            return webhookDescription;
        }
    }
    return undefined;
}
const addExecutionDataFunctions = async (type, nodeName, data, runExecutionData, connectionType, additionalData, sourceNodeName, sourceNodeRunIndex, currentNodeRunIndex) => {
    if (connectionType === "main") {
        throw new n8n_workflow_1.ApplicationError('Setting type is not supported for main connection', {
            extra: { type },
        });
    }
    let taskData;
    if (type === 'input') {
        taskData = {
            startTime: new Date().getTime(),
            executionTime: 0,
            executionStatus: 'running',
            source: [null],
        };
    }
    else {
        taskData = (0, get_1.default)(runExecutionData, ['resultData', 'runData', nodeName, currentNodeRunIndex], undefined);
        if (taskData === undefined) {
            return;
        }
    }
    taskData = taskData;
    if (data instanceof Error) {
        taskData.executionStatus = 'error';
        taskData.error = data;
    }
    else {
        if (type === 'output') {
            taskData.executionStatus = 'success';
        }
        taskData.data = {
            [connectionType]: data,
        };
    }
    if (type === 'input') {
        if (!(data instanceof Error)) {
            taskData.inputOverride = {
                [connectionType]: data,
            };
        }
        if (!runExecutionData.resultData.runData.hasOwnProperty(nodeName)) {
            runExecutionData.resultData.runData[nodeName] = [];
        }
        runExecutionData.resultData.runData[nodeName][currentNodeRunIndex] = taskData;
        if (additionalData.sendDataToUI) {
            additionalData.sendDataToUI('nodeExecuteBefore', {
                executionId: additionalData.executionId,
                nodeName,
            });
        }
    }
    else {
        taskData.executionTime = new Date().getTime() - taskData.startTime;
        if (additionalData.sendDataToUI) {
            additionalData.sendDataToUI('nodeExecuteAfter', {
                executionId: additionalData.executionId,
                nodeName,
                data: taskData,
            });
        }
        if ((0, get_1.default)(runExecutionData, 'executionData.metadata', undefined) === undefined) {
            runExecutionData.executionData.metadata = {};
        }
        let sourceTaskData = (0, get_1.default)(runExecutionData, ['executionData', 'metadata', sourceNodeName]);
        if (!sourceTaskData) {
            runExecutionData.executionData.metadata[sourceNodeName] = [];
            sourceTaskData = runExecutionData.executionData.metadata[sourceNodeName];
        }
        if (!sourceTaskData[sourceNodeRunIndex]) {
            sourceTaskData[sourceNodeRunIndex] = {
                subRun: [],
            };
        }
        sourceTaskData[sourceNodeRunIndex].subRun.push({
            node: nodeName,
            runIndex: currentNodeRunIndex,
        });
    }
};
async function getInputConnectionData(workflow, runExecutionData, runIndex, connectionInputData, additionalData, executeData, mode, closeFunctions, inputName, itemIndex) {
    const node = this.getNode();
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    const inputs = n8n_workflow_1.NodeHelpers.getNodeInputs(workflow, node, nodeType.description);
    let inputConfiguration = inputs.find((input) => {
        if (typeof input === 'string') {
            return input === inputName;
        }
        return input.type === inputName;
    });
    if (inputConfiguration === undefined) {
        throw new n8n_workflow_1.ApplicationError('Node does not have input of type', {
            extra: { nodeName: node.name, inputName },
        });
    }
    if (typeof inputConfiguration === 'string') {
        inputConfiguration = {
            type: inputConfiguration,
        };
    }
    const parentNodes = workflow.getParentNodes(node.name, inputName, 1);
    if (parentNodes.length === 0) {
        if (inputConfiguration.required) {
            throw new n8n_workflow_1.NodeOperationError(node, `A ${inputConfiguration?.displayName ?? inputName} sub-node must be connected`);
        }
        return inputConfiguration.maxConnections === 1 ? undefined : [];
    }
    const constParentNodes = parentNodes
        .map((nodeName) => {
        return workflow.getNode(nodeName);
    })
        .filter((connectedNode) => connectedNode.disabled !== true)
        .map(async (connectedNode) => {
        const nodeType = workflow.nodeTypes.getByNameAndVersion(connectedNode.type, connectedNode.typeVersion);
        const context = Object.assign({}, this);
        context.getNodeParameter = (parameterName, itemIndex, fallbackValue, options) => {
            return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, connectedNode, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData, fallbackValue, { ...(options || {}), contextNode: node });
        };
        context.getNode = () => {
            return (0, n8n_workflow_1.deepCopy)(connectedNode);
        };
        context.getCredentials = async (key) => {
            try {
                return await getCredentials(workflow, connectedNode, key, additionalData, mode, executeData, runExecutionData, runIndex, connectionInputData, itemIndex);
            }
            catch (error) {
                let currentNodeRunIndex = 0;
                if (runExecutionData.resultData.runData.hasOwnProperty(node.name)) {
                    currentNodeRunIndex = runExecutionData.resultData.runData[node.name].length;
                }
                await addExecutionDataFunctions('input', connectedNode.name, error, runExecutionData, inputName, additionalData, node.name, runIndex, currentNodeRunIndex);
                throw error;
            }
        };
        if (!nodeType.supplyData) {
            if (nodeType.description.outputs.includes("ai_tool")) {
                nodeType.supplyData = async function () {
                    return (0, CreateNodeAsTool_1.createNodeAsTool)(this, nodeType, this.getNode().parameters);
                };
            }
            else {
                throw new n8n_workflow_1.ApplicationError('Node does not have a `supplyData` method defined', {
                    extra: { nodeName: connectedNode.name },
                });
            }
        }
        try {
            const response = await nodeType.supplyData.call(context, itemIndex);
            if (response.closeFunction) {
                closeFunctions.push(response.closeFunction);
            }
            return response;
        }
        catch (error) {
            if (error.functionality === 'configuration-node')
                throw error;
            if (!(error instanceof n8n_workflow_1.ExecutionBaseError)) {
                error = new n8n_workflow_1.NodeOperationError(connectedNode, error, {
                    itemIndex,
                });
            }
            let currentNodeRunIndex = 0;
            if (runExecutionData.resultData.runData.hasOwnProperty(node.name)) {
                currentNodeRunIndex = runExecutionData.resultData.runData[node.name].length;
            }
            await addExecutionDataFunctions('input', connectedNode.name, error, runExecutionData, inputName, additionalData, node.name, runIndex, currentNodeRunIndex);
            throw new n8n_workflow_1.NodeOperationError(connectedNode, `Error in sub-node ${connectedNode.name}`, {
                itemIndex,
                functionality: 'configuration-node',
                description: error.message,
            });
        }
    });
    const nodes = await Promise.all(constParentNodes);
    if (inputConfiguration.required && nodes.length === 0) {
        throw new n8n_workflow_1.NodeOperationError(node, `A ${inputConfiguration?.displayName ?? inputName} sub-node must be connected`);
    }
    if (inputConfiguration.maxConnections !== undefined &&
        nodes.length > inputConfiguration.maxConnections) {
        throw new n8n_workflow_1.NodeOperationError(node, `Only ${inputConfiguration.maxConnections} ${inputName} sub-nodes are/is allowed to be connected`);
    }
    return inputConfiguration.maxConnections === 1
        ? (nodes || [])[0]?.response
        : nodes.map((node) => node.response);
}
const getCommonWorkflowFunctions = (workflow, node, additionalData) => ({
    logger: n8n_workflow_1.LoggerProxy,
    getExecutionId: () => additionalData.executionId,
    getNode: () => (0, n8n_workflow_1.deepCopy)(node),
    getWorkflow: () => ({
        id: workflow.id,
        name: workflow.name,
        active: workflow.active,
    }),
    getWorkflowStaticData: (type) => workflow.getStaticData(type, node),
    getChildNodes: (nodeName) => {
        const output = [];
        const nodes = workflow.getChildNodes(nodeName);
        for (const nodeName of nodes) {
            const node = workflow.nodes[nodeName];
            output.push({
                name: node.name,
                type: node.type,
                typeVersion: node.typeVersion,
            });
        }
        return output;
    },
    getParentNodes: (nodeName) => {
        const output = [];
        const nodes = workflow.getParentNodes(nodeName);
        for (const nodeName of nodes) {
            const node = workflow.nodes[nodeName];
            output.push({
                name: node.name,
                type: node.type,
                typeVersion: node.typeVersion,
            });
        }
        return output;
    },
    getKnownNodeTypes: () => workflow.nodeTypes.getKnownTypes(),
    getRestApiUrl: () => additionalData.restApiUrl,
    getInstanceBaseUrl: () => additionalData.instanceBaseUrl,
    getInstanceId: () => typedi_1.default.get(InstanceSettings_1.InstanceSettings).instanceId,
    getTimezone: () => workflow.timezone,
    getCredentialsProperties: (type) => additionalData.credentialsHelper.getCredentialsProperties(type),
    prepareOutputData: async (outputData) => [outputData],
});
const executionCancellationFunctions = (abortSignal) => ({
    getExecutionCancelSignal: () => abortSignal,
    onExecutionCancellation: (handler) => {
        const fn = () => {
            abortSignal?.removeEventListener('abort', fn);
            handler();
        };
        abortSignal?.addEventListener('abort', fn);
    },
});
const getRequestHelperFunctions = (workflow, node, additionalData, runExecutionData = null, connectionInputData = []) => {
    const getResolvedValue = (parameterValue, itemIndex, runIndex, executeData, additionalKeys, returnObjectAsString = false) => {
        const mode = 'internal';
        if (typeof parameterValue === 'object' ||
            (typeof parameterValue === 'string' && parameterValue.charAt(0) === '=')) {
            return workflow.expression.getParameterValue(parameterValue, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys ?? {}, executeData, returnObjectAsString);
        }
        return parameterValue;
    };
    return {
        httpRequest,
        async requestWithAuthenticationPaginated(requestOptions, itemIndex, paginationOptions, credentialsType, additionalCredentialOptions) {
            const responseData = [];
            if (!requestOptions.qs) {
                requestOptions.qs = {};
            }
            requestOptions.resolveWithFullResponse = true;
            requestOptions.simple = false;
            let tempResponseData;
            let makeAdditionalRequest;
            let paginateRequestData;
            const runIndex = 0;
            const additionalKeys = {
                $request: requestOptions,
                $response: {},
                $version: node.typeVersion,
                $pageCount: 0,
            };
            const executeData = {
                data: {},
                node,
                source: null,
            };
            const hashData = {
                identicalCount: 0,
                previousLength: 0,
                previousHash: '',
            };
            do {
                paginateRequestData = getResolvedValue(paginationOptions.request, itemIndex, runIndex, executeData, additionalKeys, false);
                const tempRequestOptions = applyPaginationRequestData(requestOptions, paginateRequestData);
                if (!validateUrl(tempRequestOptions.uri)) {
                    throw new n8n_workflow_1.NodeOperationError(node, `'${paginateRequestData.url}' is not a valid URL.`, {
                        itemIndex,
                        runIndex,
                        type: 'invalid_url',
                    });
                }
                if (credentialsType) {
                    tempResponseData = await this.helpers.requestWithAuthentication.call(this, credentialsType, tempRequestOptions, additionalCredentialOptions);
                }
                else {
                    tempResponseData = await this.helpers.request(tempRequestOptions);
                }
                const newResponse = Object.assign({
                    body: {},
                    headers: {},
                    statusCode: 0,
                }, (0, pick_1.default)(tempResponseData, ['body', 'headers', 'statusCode']));
                let contentBody;
                if (newResponse.body instanceof stream_1.Readable && paginationOptions.binaryResult !== true) {
                    contentBody = await binaryToString(newResponse.body);
                    const responseContentType = newResponse.headers['content-type']?.toString() ?? '';
                    if (responseContentType.includes('application/json')) {
                        newResponse.body = (0, n8n_workflow_1.jsonParse)(contentBody, { fallbackValue: {} });
                    }
                    else {
                        newResponse.body = contentBody;
                    }
                    tempResponseData.__bodyResolved = true;
                    tempResponseData.body = newResponse.body;
                }
                else {
                    contentBody = newResponse.body;
                }
                if (paginationOptions.binaryResult !== true || tempResponseData.headers.etag) {
                    let contentLength = 0;
                    if ('content-length' in tempResponseData.headers) {
                        contentLength = parseInt(tempResponseData.headers['content-length']) || 0;
                    }
                    if (hashData.previousLength === contentLength) {
                        let hash;
                        if (tempResponseData.headers.etag) {
                            hash = tempResponseData.headers.etag;
                        }
                        else {
                            if (typeof contentBody !== 'string') {
                                contentBody = JSON.stringify(contentBody);
                            }
                            hash = crypto_1.default.createHash('md5').update(contentBody).digest('base64');
                        }
                        if (hashData.previousHash === hash) {
                            hashData.identicalCount += 1;
                            if (hashData.identicalCount > 2) {
                                throw new n8n_workflow_1.NodeOperationError(node, 'The returned response was identical 5x, so requests got stopped', {
                                    itemIndex,
                                    description: 'Check if "Pagination Completed When" has been configured correctly.',
                                });
                            }
                        }
                        else {
                            hashData.identicalCount = 0;
                        }
                        hashData.previousHash = hash;
                    }
                    else {
                        hashData.identicalCount = 0;
                    }
                    hashData.previousLength = contentLength;
                }
                responseData.push(tempResponseData);
                additionalKeys.$response = newResponse;
                additionalKeys.$pageCount = additionalKeys.$pageCount + 1;
                const maxRequests = getResolvedValue(paginationOptions.maxRequests, itemIndex, runIndex, executeData, additionalKeys, false);
                if (maxRequests && additionalKeys.$pageCount >= maxRequests) {
                    break;
                }
                makeAdditionalRequest = getResolvedValue(paginationOptions.continue, itemIndex, runIndex, executeData, additionalKeys, false);
                if (makeAdditionalRequest) {
                    if (paginationOptions.requestInterval) {
                        const requestInterval = getResolvedValue(paginationOptions.requestInterval, itemIndex, runIndex, executeData, additionalKeys, false);
                        await (0, n8n_workflow_1.sleep)(requestInterval);
                    }
                    if (tempResponseData.statusCode < 200 || tempResponseData.statusCode >= 300) {
                        let data = tempResponseData.body;
                        if (data instanceof stream_1.Readable && paginationOptions.binaryResult !== true) {
                            data = await binaryToString(data);
                        }
                        else if (typeof data === 'object') {
                            data = JSON.stringify(data);
                        }
                        throw Object.assign(new Error(`${tempResponseData.statusCode} - "${data?.toString()}"`), {
                            statusCode: tempResponseData.statusCode,
                            error: data,
                            isAxiosError: true,
                            response: {
                                headers: tempResponseData.headers,
                                status: tempResponseData.statusCode,
                                statusText: tempResponseData.statusMessage,
                            },
                        });
                    }
                }
            } while (makeAdditionalRequest);
            return responseData;
        },
        async httpRequestWithAuthentication(credentialsType, requestOptions, additionalCredentialOptions) {
            return await httpRequestWithAuthentication.call(this, credentialsType, requestOptions, workflow, node, additionalData, additionalCredentialOptions);
        },
        request: async (uriOrObject, options) => await proxyRequestToAxios(workflow, additionalData, node, uriOrObject, options),
        async requestWithAuthentication(credentialsType, requestOptions, additionalCredentialOptions, itemIndex) {
            return await requestWithAuthentication.call(this, credentialsType, requestOptions, workflow, node, additionalData, additionalCredentialOptions, itemIndex);
        },
        async requestOAuth1(credentialsType, requestOptions) {
            return await requestOAuth1.call(this, credentialsType, requestOptions);
        },
        async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
            return await requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
        },
    };
};
const getSSHTunnelFunctions = () => ({
    getSSHClient: async (credentials) => await typedi_1.default.get(SSHClientsManager_1.SSHClientsManager).getClient(credentials),
});
const getSchedulingFunctions = (workflow) => {
    const scheduledTaskManager = typedi_1.default.get(ScheduledTaskManager_1.ScheduledTaskManager);
    return {
        registerCron: (cronExpression, onTick) => scheduledTaskManager.registerCron(workflow, cronExpression, onTick),
    };
};
const getAllowedPaths = () => {
    const restrictFileAccessTo = process.env[Constants_1.RESTRICT_FILE_ACCESS_TO];
    if (!restrictFileAccessTo) {
        return [];
    }
    const allowedPaths = restrictFileAccessTo
        .split(';')
        .map((path) => path.trim())
        .filter((path) => path);
    return allowedPaths;
};
function isFilePathBlocked(filePath) {
    const allowedPaths = getAllowedPaths();
    const resolvedFilePath = path_1.default.resolve(filePath);
    const blockFileAccessToN8nFiles = process.env[Constants_1.BLOCK_FILE_ACCESS_TO_N8N_FILES] !== 'false';
    if (allowedPaths.length) {
        for (const path of allowedPaths) {
            if (resolvedFilePath.startsWith(path)) {
                return false;
            }
        }
        return true;
    }
    if (blockFileAccessToN8nFiles) {
        const { n8nFolder, staticCacheDir } = typedi_1.default.get(InstanceSettings_1.InstanceSettings);
        const restrictedPaths = [n8nFolder, staticCacheDir];
        if (process.env[Constants_1.CONFIG_FILES]) {
            restrictedPaths.push(...process.env[Constants_1.CONFIG_FILES].split(','));
        }
        if (process.env[Constants_1.CUSTOM_EXTENSION_ENV]) {
            const customExtensionFolders = process.env[Constants_1.CUSTOM_EXTENSION_ENV].split(';');
            restrictedPaths.push(...customExtensionFolders);
        }
        if (process.env[Constants_1.BINARY_DATA_STORAGE_PATH]) {
            restrictedPaths.push(process.env[Constants_1.BINARY_DATA_STORAGE_PATH]);
        }
        if (process.env[Constants_1.UM_EMAIL_TEMPLATES_INVITE]) {
            restrictedPaths.push(process.env[Constants_1.UM_EMAIL_TEMPLATES_INVITE]);
        }
        if (process.env[Constants_1.UM_EMAIL_TEMPLATES_PWRESET]) {
            restrictedPaths.push(process.env[Constants_1.UM_EMAIL_TEMPLATES_PWRESET]);
        }
        for (const path of restrictedPaths) {
            if (resolvedFilePath.startsWith(path)) {
                return true;
            }
        }
    }
    return false;
}
const getFileSystemHelperFunctions = (node) => ({
    async createReadStream(filePath) {
        try {
            await (0, promises_1.access)(filePath);
        }
        catch (error) {
            throw error.code === 'ENOENT'
                ? new n8n_workflow_1.NodeOperationError(node, error, {
                    message: `The file "${String(filePath)}" could not be accessed.`,
                    level: 'warning',
                })
                : error;
        }
        if (isFilePathBlocked(filePath)) {
            const allowedPaths = getAllowedPaths();
            const message = allowedPaths.length ? ` Allowed paths: ${allowedPaths.join(', ')}` : '';
            throw new n8n_workflow_1.NodeOperationError(node, `Access to the file is not allowed.${message}`, {
                level: 'warning',
            });
        }
        return (0, fs_1.createReadStream)(filePath);
    },
    getStoragePath() {
        return path_1.default.join(typedi_1.default.get(InstanceSettings_1.InstanceSettings).n8nFolder, `storage/${node.type}`);
    },
    async writeContentToFile(filePath, content, flag) {
        if (isFilePathBlocked(filePath)) {
            throw new n8n_workflow_1.NodeOperationError(node, `The file "${String(filePath)}" is not writable.`, {
                level: 'warning',
            });
        }
        return await (0, promises_1.writeFile)(filePath, content, { encoding: 'binary', flag });
    },
});
const getNodeHelperFunctions = ({ executionId }, workflowId) => ({
    copyBinaryFile: async (filePath, fileName, mimeType) => await copyBinaryFile(workflowId, executionId, filePath, fileName, mimeType),
});
const getBinaryHelperFunctions = ({ executionId }, workflowId) => ({
    getBinaryPath,
    getBinaryStream,
    getBinaryMetadata,
    binaryToBuffer: utils_1.binaryToBuffer,
    binaryToString,
    prepareBinaryData: async (binaryData, filePath, mimeType) => await prepareBinaryData(binaryData, executionId, workflowId, filePath, mimeType),
    setBinaryDataBuffer: async (data, binaryData) => await setBinaryDataBuffer(data, binaryData, workflowId, executionId),
    copyBinaryFile: async () => {
        throw new n8n_workflow_1.ApplicationError('`copyBinaryFile` has been removed. Please upgrade this node.');
    },
});
const getCheckProcessedHelperFunctions = (workflow, node) => ({
    async checkProcessedAndRecord(items, scope, options) {
        return await checkProcessedAndRecord(items, scope, { node, workflow }, options);
    },
    async checkProcessedItemsAndRecord(propertyName, items, scope, options) {
        return await checkProcessedItemsAndRecord(propertyName, items, scope, { node, workflow }, options);
    },
    async removeProcessed(items, scope, options) {
        return await removeProcessed(items, scope, { node, workflow }, options);
    },
    async clearAllProcessedItems(scope, options) {
        return await clearAllProcessedItems(scope, { node, workflow }, options);
    },
    async getProcessedDataCount(scope, options) {
        return await getProcessedDataCount(scope, { node, workflow }, options);
    },
});
function copyInputItems(items, properties) {
    return items.map((item) => {
        const newItem = {};
        for (const property of properties) {
            if (item.json[property] === undefined) {
                newItem[property] = null;
            }
            else {
                newItem[property] = (0, n8n_workflow_1.deepCopy)(item.json[property]);
            }
        }
        return newItem;
    });
}
function getExecutePollFunctions(workflow, node, additionalData, mode, activation) {
    return ((workflow, node) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            __emit: () => {
                throw new n8n_workflow_1.ApplicationError('Overwrite NodeExecuteFunctions.getExecutePollFunctions.__emit function');
            },
            __emitError() {
                throw new n8n_workflow_1.ApplicationError('Overwrite NodeExecuteFunctions.getExecutePollFunctions.__emitError function');
            },
            getMode: () => mode,
            getActivationMode: () => activation,
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, mode),
            getNodeParameter: (parameterName, fallbackValue, options) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), undefined, fallbackValue, options);
            },
            helpers: {
                createDeferredPromise: n8n_workflow_1.createDeferredPromise,
                ...getRequestHelperFunctions(workflow, node, additionalData),
                ...getBinaryHelperFunctions(additionalData, workflow.id),
                ...getSchedulingFunctions(workflow),
                returnJsonArray,
            },
        };
    })(workflow, node);
}
function getExecuteTriggerFunctions(workflow, node, additionalData, mode, activation) {
    return ((workflow, node) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            emit: () => {
                throw new n8n_workflow_1.ApplicationError('Overwrite NodeExecuteFunctions.getExecuteTriggerFunctions.emit function');
            },
            emitError: () => {
                throw new n8n_workflow_1.ApplicationError('Overwrite NodeExecuteFunctions.getExecuteTriggerFunctions.emit function');
            },
            getMode: () => mode,
            getActivationMode: () => activation,
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, mode),
            getNodeParameter: (parameterName, fallbackValue, options) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), undefined, fallbackValue, options);
            },
            helpers: {
                createDeferredPromise: n8n_workflow_1.createDeferredPromise,
                ...getSSHTunnelFunctions(),
                ...getRequestHelperFunctions(workflow, node, additionalData),
                ...getBinaryHelperFunctions(additionalData, workflow.id),
                ...getSchedulingFunctions(workflow),
                returnJsonArray,
            },
        };
    })(workflow, node);
}
function getExecuteFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, additionalData, executeData, mode, closeFunctions, abortSignal) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            ...executionCancellationFunctions(abortSignal),
            getMode: () => mode,
            getCredentials: async (type, itemIndex) => await getCredentials(workflow, node, type, additionalData, mode, executeData, runExecutionData, runIndex, connectionInputData, itemIndex),
            getExecuteData: () => executeData,
            continueOnFail: () => {
                return continueOnFail(node);
            },
            evaluateExpression: (expression, itemIndex) => {
                return workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData);
            },
            async executeWorkflow(workflowInfo, inputData, parentCallbackManager) {
                return await additionalData
                    .executeWorkflow(workflowInfo, additionalData, {
                    parentWorkflowId: workflow.id?.toString(),
                    inputData,
                    parentWorkflowSettings: workflow.settings,
                    node,
                    parentCallbackManager,
                })
                    .then(async (result) => await typedi_1.default.get(BinaryData_service_1.BinaryDataService).duplicateBinaryData(workflow.id, additionalData.executionId, result));
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            async getInputConnectionData(inputName, itemIndex) {
                return await getInputConnectionData.call(this, workflow, runExecutionData, runIndex, connectionInputData, additionalData, executeData, mode, closeFunctions, inputName, itemIndex);
            },
            getNodeInputs() {
                const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
                return n8n_workflow_1.NodeHelpers.getNodeInputs(workflow, node, nodeType.description).map((output) => {
                    if (typeof output === 'string') {
                        return {
                            type: output,
                        };
                    }
                    return output;
                });
            },
            getNodeOutputs() {
                const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
                return n8n_workflow_1.NodeHelpers.getNodeOutputs(workflow, node, nodeType.description).map((output) => {
                    if (typeof output === 'string') {
                        return {
                            type: output,
                        };
                    }
                    return output;
                });
            },
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return [];
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new n8n_workflow_1.ApplicationError('Could not get input with given index', {
                        extra: { inputIndex, inputName },
                    });
                }
                if (inputData[inputName][inputIndex] === null) {
                    throw new n8n_workflow_1.ApplicationError('Value of input was not set', {
                        extra: { inputIndex, inputName },
                    });
                }
                return inputData[inputName][inputIndex];
            },
            getInputSourceData: (inputIndex = 0, inputName = 'main') => {
                if (executeData?.source === null) {
                    throw new n8n_workflow_1.ApplicationError('Source data is missing');
                }
                return executeData.source[inputName][inputIndex];
            },
            getNodeParameter: (parameterName, itemIndex, fallbackValue, options) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData, fallbackValue, options);
            },
            getWorkflowDataProxy: (itemIndex) => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, {}, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData);
                return dataProxy.getDataProxy();
            },
            async putExecutionToWait(waitTill) {
                runExecutionData.waitTill = waitTill;
                if (additionalData.setExecutionStatus) {
                    additionalData.setExecutionStatus('waiting');
                }
            },
            logNodeOutput(...args) {
                if (mode === 'manual') {
                    this.sendMessageToUI(...args);
                    return;
                }
                if (process.env.CODE_ENABLE_STDOUT === 'true') {
                    console.log(`[Workflow "${this.getWorkflow().id}"][Node "${node.name}"]`, ...args);
                }
            },
            sendMessageToUI(...args) {
                if (mode !== 'manual') {
                    return;
                }
                try {
                    if (additionalData.sendDataToUI) {
                        args = args.map((arg) => {
                            if (arg.isLuxonDateTime && arg.invalidReason)
                                return { ...arg };
                            if (arg.isLuxonDateTime)
                                return new Date(arg.ts).toString();
                            if (arg instanceof Date)
                                return arg.toString();
                            return arg;
                        });
                        additionalData.sendDataToUI('sendConsoleMessage', {
                            source: `[Node: "${node.name}"]`,
                            messages: args,
                        });
                    }
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.warn(`There was a problem sending message to UI: ${error.message}`);
                }
            },
            async sendResponse(response) {
                await additionalData.hooks?.executeHookFunctions('sendResponse', [response]);
            },
            addInputData(connectionType, data) {
                const nodeName = this.getNode().name;
                let currentNodeRunIndex = 0;
                if (runExecutionData.resultData.runData.hasOwnProperty(nodeName)) {
                    currentNodeRunIndex = runExecutionData.resultData.runData[nodeName].length;
                }
                addExecutionDataFunctions('input', this.getNode().name, data, runExecutionData, connectionType, additionalData, node.name, runIndex, currentNodeRunIndex).catch((error) => {
                    n8n_workflow_1.LoggerProxy.warn(`There was a problem logging input data of node "${this.getNode().name}": ${error.message}`);
                });
                return { index: currentNodeRunIndex };
            },
            addOutputData(connectionType, currentNodeRunIndex, data) {
                addExecutionDataFunctions('output', this.getNode().name, data, runExecutionData, connectionType, additionalData, node.name, runIndex, currentNodeRunIndex).catch((error) => {
                    n8n_workflow_1.LoggerProxy.warn(`There was a problem logging output data of node "${this.getNode().name}": ${error.message}`);
                });
            },
            helpers: {
                createDeferredPromise: n8n_workflow_1.createDeferredPromise,
                copyInputItems,
                ...getRequestHelperFunctions(workflow, node, additionalData, runExecutionData, connectionInputData),
                ...getSSHTunnelFunctions(),
                ...getFileSystemHelperFunctions(node),
                ...getBinaryHelperFunctions(additionalData, workflow.id),
                ...getCheckProcessedHelperFunctions(workflow, node),
                assertBinaryData: (itemIndex, propertyName) => assertBinaryData(inputData, node, itemIndex, propertyName, 0),
                getBinaryDataBuffer: async (itemIndex, propertyName) => await getBinaryDataBuffer(inputData, itemIndex, propertyName, 0),
                returnJsonArray,
                normalizeItems,
                constructExecutionMetaData,
            },
            nodeHelpers: getNodeHelperFunctions(additionalData, workflow.id),
            logAiEvent: async (eventName, msg) => {
                return additionalData.logAiEvent(eventName, {
                    executionId: additionalData.executionId ?? 'unsaved-execution',
                    nodeName: node.name,
                    workflowName: workflow.name ?? 'Unnamed workflow',
                    nodeType: node.type,
                    workflowId: workflow.id ?? 'unsaved-workflow',
                    msg,
                });
            },
            getParentCallbackManager: () => additionalData.parentCallbackManager,
            startJob: (0, Agent_1.createAgentStartJob)(additionalData, inputData, node, workflow, runExecutionData, runIndex, node.name, connectionInputData, {}, mode, executeData),
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node);
}
function getExecuteSingleFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, itemIndex, additionalData, executeData, mode, abortSignal) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node, itemIndex) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            ...executionCancellationFunctions(abortSignal),
            continueOnFail: () => continueOnFail(node),
            evaluateExpression: (expression, evaluateItemIndex) => {
                evaluateItemIndex = evaluateItemIndex === undefined ? itemIndex : evaluateItemIndex;
                return workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, runExecutionData, runIndex, evaluateItemIndex, node.name, connectionInputData, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData);
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, mode, executeData, runExecutionData, runIndex, connectionInputData, itemIndex),
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return { json: {} };
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new n8n_workflow_1.ApplicationError('Could not get input index', {
                        extra: { inputIndex, inputName },
                    });
                }
                const allItems = inputData[inputName][inputIndex];
                if (allItems === null) {
                    throw new n8n_workflow_1.ApplicationError('Input index was not set', {
                        extra: { inputIndex, inputName },
                    });
                }
                if (allItems[itemIndex] === null) {
                    throw new n8n_workflow_1.ApplicationError('Value of input with given index was not set', {
                        extra: { inputIndex, inputName, itemIndex },
                    });
                }
                return allItems[itemIndex];
            },
            getInputSourceData: (inputIndex = 0, inputName = 'main') => {
                if (executeData?.source === null) {
                    throw new n8n_workflow_1.ApplicationError('Source data is missing');
                }
                return executeData.source[inputName][inputIndex];
            },
            getItemIndex: () => itemIndex,
            getMode: () => mode,
            getExecuteData: () => executeData,
            getNodeParameter: (parameterName, fallbackValue, options) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData, fallbackValue, options);
            },
            getWorkflowDataProxy: () => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, {}, mode, getAdditionalKeys(additionalData, mode, runExecutionData), executeData);
                return dataProxy.getDataProxy();
            },
            helpers: {
                createDeferredPromise: n8n_workflow_1.createDeferredPromise,
                ...getRequestHelperFunctions(workflow, node, additionalData, runExecutionData, connectionInputData),
                ...getBinaryHelperFunctions(additionalData, workflow.id),
                assertBinaryData: (propertyName, inputIndex = 0) => assertBinaryData(inputData, node, itemIndex, propertyName, inputIndex),
                getBinaryDataBuffer: async (propertyName, inputIndex = 0) => await getBinaryDataBuffer(inputData, itemIndex, propertyName, inputIndex),
            },
            logAiEvent: async (eventName, msg) => {
                return additionalData.logAiEvent(eventName, {
                    executionId: additionalData.executionId ?? 'unsaved-execution',
                    nodeName: node.name,
                    workflowName: workflow.name ?? 'Unnamed workflow',
                    nodeType: node.type,
                    workflowId: workflow.id ?? 'unsaved-workflow',
                    msg,
                });
            },
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node, itemIndex);
}
function getCredentialTestFunctions() {
    return {
        helpers: {
            ...getSSHTunnelFunctions(),
            request: async (uriOrObject, options) => {
                return await proxyRequestToAxios(undefined, undefined, undefined, uriOrObject, options);
            },
        },
    };
}
function getLoadOptionsFunctions(workflow, node, path, additionalData) {
    return ((workflow, node, path) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, 'internal'),
            getCurrentNodeParameter: (parameterPath, options) => {
                const nodeParameters = additionalData.currentNodeParameters;
                if (parameterPath.charAt(0) === '&') {
                    parameterPath = `${path.split('.').slice(1, -1).join('.')}.${parameterPath.slice(1)}`;
                }
                let returnData = (0, get_1.default)(nodeParameters, parameterPath);
                if (options?.extractValue) {
                    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
                    if (nodeType === undefined) {
                        throw new n8n_workflow_1.ApplicationError('Node type is not known so cannot return parameter value', {
                            tags: { nodeType: node.type },
                        });
                    }
                    returnData = (0, ExtractValue_1.extractValue)(returnData, parameterPath, node, nodeType);
                }
                return returnData;
            },
            getCurrentNodeParameters: () => additionalData.currentNodeParameters,
            getNodeParameter: (parameterName, fallbackValue, options) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const mode = 'internal';
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), undefined, fallbackValue, options);
            },
            helpers: {
                ...getSSHTunnelFunctions(),
                ...getRequestHelperFunctions(workflow, node, additionalData),
            },
        };
    })(workflow, node, path);
}
function getExecuteHookFunctions(workflow, node, additionalData, mode, activation, webhookData) {
    return ((workflow, node) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, mode),
            getMode: () => mode,
            getActivationMode: () => activation,
            getNodeParameter: (parameterName, fallbackValue, options) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData, mode, runExecutionData), undefined, fallbackValue, options);
            },
            getNodeWebhookUrl: (name) => {
                return getNodeWebhookUrl(name, workflow, node, additionalData, mode, getAdditionalKeys(additionalData, mode, null), webhookData?.isTest);
            },
            getWebhookName() {
                if (webhookData === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Only supported in webhook functions');
                }
                return webhookData.webhookDescription.name;
            },
            getWebhookDescription: (name) => getWebhookDescription(name, workflow, node),
            helpers: getRequestHelperFunctions(workflow, node, additionalData),
        };
    })(workflow, node);
}
function getExecuteWebhookFunctions(workflow, node, additionalData, mode, webhookData, closeFunctions, runExecutionData) {
    return ((workflow, node, runExecutionData) => {
        return {
            ...getCommonWorkflowFunctions(workflow, node, additionalData),
            getBodyData() {
                if (additionalData.httpRequest === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Request is missing');
                }
                return additionalData.httpRequest.body;
            },
            getCredentials: async (type) => await getCredentials(workflow, node, type, additionalData, mode),
            getHeaderData() {
                if (additionalData.httpRequest === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Request is missing');
                }
                return additionalData.httpRequest.headers;
            },
            async getInputConnectionData(inputName, itemIndex) {
                const connectionInputData = [
                    { json: additionalData.httpRequest?.body || {} },
                ];
                const runExecutionData = {
                    resultData: {
                        runData: {},
                    },
                };
                const executeData = {
                    data: {
                        main: [connectionInputData],
                    },
                    node,
                    source: null,
                };
                const runIndex = 0;
                return await getInputConnectionData.call(this, workflow, runExecutionData, runIndex, connectionInputData, additionalData, executeData, mode, closeFunctions, inputName, itemIndex);
            },
            getMode: () => mode,
            getNodeParameter: (parameterName, fallbackValue, options) => {
                const itemIndex = 0;
                const runIndex = 0;
                let connectionInputData = [];
                let executionData;
                if (runExecutionData?.executionData !== undefined) {
                    executionData = runExecutionData.executionData.nodeExecutionStack[0];
                    if (executionData !== undefined) {
                        connectionInputData = executionData.data.main[0];
                    }
                }
                const additionalKeys = getAdditionalKeys(additionalData, mode, runExecutionData);
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, additionalKeys, executionData, fallbackValue, options);
            },
            getParamsData() {
                if (additionalData.httpRequest === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Request is missing');
                }
                return additionalData.httpRequest.params;
            },
            getQueryData() {
                if (additionalData.httpRequest === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Request is missing');
                }
                return additionalData.httpRequest.query;
            },
            getRequestObject() {
                if (additionalData.httpRequest === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Request is missing');
                }
                return additionalData.httpRequest;
            },
            getResponseObject() {
                if (additionalData.httpResponse === undefined) {
                    throw new n8n_workflow_1.ApplicationError('Response is missing');
                }
                return additionalData.httpResponse;
            },
            getNodeWebhookUrl: (name) => getNodeWebhookUrl(name, workflow, node, additionalData, mode, getAdditionalKeys(additionalData, mode, null)),
            getWebhookName: () => webhookData.webhookDescription.name,
            helpers: {
                createDeferredPromise: n8n_workflow_1.createDeferredPromise,
                ...getRequestHelperFunctions(workflow, node, additionalData),
                ...getBinaryHelperFunctions(additionalData, workflow.id),
                returnJsonArray,
            },
            nodeHelpers: getNodeHelperFunctions(additionalData, workflow.id),
        };
    })(workflow, node, runExecutionData);
}
//# sourceMappingURL=NodeExecuteFunctions.js.map