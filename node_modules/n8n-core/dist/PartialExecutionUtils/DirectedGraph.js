"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectedGraph = void 0;
const a = __importStar(require("assert"));
const n8n_workflow_1 = require("n8n-workflow");
class DirectedGraph {
    constructor() {
        this.nodes = new Map();
        this.connections = new Map();
    }
    getNodes() {
        return new Map(this.nodes.entries());
    }
    getConnections(filter = {}) {
        const filteredCopy = [];
        for (const connection of this.connections.values()) {
            const toMatches = filter.to ? connection.to === filter.to : true;
            if (toMatches) {
                filteredCopy.push(connection);
            }
        }
        return filteredCopy;
    }
    addNode(node) {
        this.nodes.set(node.name, node);
        return this;
    }
    addNodes(...nodes) {
        for (const node of nodes) {
            this.addNode(node);
        }
        return this;
    }
    removeNode(node, options = { reconnectConnections: false }) {
        if (options.reconnectConnections) {
            const incomingConnections = this.getDirectParentConnections(node);
            const outgoingConnections = this.getDirectChildConnections(node);
            const newConnections = [];
            for (const incomingConnection of incomingConnections) {
                if (options.skipConnectionFn && options.skipConnectionFn(incomingConnection)) {
                    continue;
                }
                for (const outgoingConnection of outgoingConnections) {
                    if (options.skipConnectionFn && options.skipConnectionFn(outgoingConnection)) {
                        continue;
                    }
                    const newConnection = {
                        ...incomingConnection,
                        to: outgoingConnection.to,
                        inputIndex: outgoingConnection.inputIndex,
                    };
                    newConnections.push(newConnection);
                }
            }
            for (const [key, connection] of this.connections.entries()) {
                if (connection.to === node || connection.from === node) {
                    this.connections.delete(key);
                }
            }
            for (const newConnection of newConnections) {
                this.connections.set(this.makeKey(newConnection), newConnection);
            }
            this.nodes.delete(node.name);
            return newConnections;
        }
        else {
            for (const [key, connection] of this.connections.entries()) {
                if (connection.to === node || connection.from === node) {
                    this.connections.delete(key);
                }
            }
            this.nodes.delete(node.name);
            return;
        }
    }
    addConnection(connectionInput) {
        const { from, to } = connectionInput;
        const fromExists = this.nodes.get(from.name) === from;
        const toExists = this.nodes.get(to.name) === to;
        a.ok(fromExists);
        a.ok(toExists);
        const connection = {
            ...connectionInput,
            type: connectionInput.type ?? "main",
            outputIndex: connectionInput.outputIndex ?? 0,
            inputIndex: connectionInput.inputIndex ?? 0,
        };
        this.connections.set(this.makeKey(connection), connection);
        return this;
    }
    addConnections(...connectionInputs) {
        for (const connectionInput of connectionInputs) {
            this.addConnection(connectionInput);
        }
        return this;
    }
    getDirectChildConnections(node) {
        const nodeExists = this.nodes.get(node.name) === node;
        a.ok(nodeExists);
        const directChildren = [];
        for (const connection of this.connections.values()) {
            if (connection.from !== node) {
                continue;
            }
            directChildren.push(connection);
        }
        return directChildren;
    }
    getChildrenRecursive(node, children) {
        const directChildren = this.getDirectChildConnections(node);
        for (const directChild of directChildren) {
            if (children.has(directChild.to)) {
                continue;
            }
            children.add(directChild.to);
            this.getChildrenRecursive(directChild.to, children);
        }
        return children;
    }
    getChildren(node) {
        return this.getChildrenRecursive(node, new Set());
    }
    getDirectParentConnections(node) {
        const nodeExists = this.nodes.get(node.name) === node;
        a.ok(nodeExists);
        const directParents = [];
        for (const connection of this.connections.values()) {
            if (connection.to !== node) {
                continue;
            }
            directParents.push(connection);
        }
        return directParents;
    }
    getParentConnectionsRecursive(node, connections) {
        const parentConnections = this.getDirectParentConnections(node);
        for (const connection of parentConnections) {
            if (connections.has(connection)) {
                continue;
            }
            connections.add(connection);
            this.getParentConnectionsRecursive(connection.from, connections);
        }
        return connections;
    }
    getParentConnections(node) {
        return this.getParentConnectionsRecursive(node, new Set());
    }
    getConnection(from, outputIndex, type, inputIndex, to) {
        return this.connections.get(this.makeKey({
            from,
            outputIndex,
            type,
            inputIndex,
            to,
        }));
    }
    toWorkflow(parameters) {
        return new n8n_workflow_1.Workflow({
            ...parameters,
            nodes: [...this.nodes.values()],
            connections: this.toIConnections(),
        });
    }
    static fromWorkflow(workflow) {
        const graph = new DirectedGraph();
        graph.addNodes(...Object.values(workflow.nodes));
        for (const [fromNodeName, iConnection] of Object.entries(workflow.connectionsBySourceNode)) {
            const from = workflow.getNode(fromNodeName);
            a.ok(from);
            for (const [outputType, outputs] of Object.entries(iConnection)) {
                for (const [outputIndex, conns] of outputs.entries()) {
                    for (const conn of conns) {
                        const { node: toNodeName, type: _inputType, index: inputIndex } = conn;
                        const to = workflow.getNode(toNodeName);
                        a.ok(to);
                        graph.addConnection({
                            from,
                            to,
                            type: outputType,
                            outputIndex,
                            inputIndex,
                        });
                    }
                }
            }
        }
        return graph;
    }
    toIConnections() {
        const result = {};
        for (const connection of this.connections.values()) {
            const { from, to, type, outputIndex, inputIndex } = connection;
            result[from.name] = result[from.name] ?? {
                [type]: [],
            };
            const resultConnection = result[from.name];
            resultConnection[type][outputIndex] = resultConnection[type][outputIndex] ?? [];
            const group = resultConnection[type][outputIndex];
            group.push({
                node: to.name,
                type,
                index: inputIndex,
            });
        }
        return result;
    }
    makeKey(connection) {
        return `${connection.from.name}-${connection.type}-${connection.outputIndex}-${connection.inputIndex}-${connection.to.name}`;
    }
}
exports.DirectedGraph = DirectedGraph;
//# sourceMappingURL=DirectedGraph.js.map