"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRunner = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const nanoid_1 = require("nanoid");
const node_url_1 = require("node:url");
const ws_1 = require("ws");
const runner_types_1 = require("./runner-types");
const VALID_TIME_MS = 1000;
const VALID_EXTRA_MS = 100;
class TaskRunner {
    constructor(taskType, wsUrl, grantToken, maxConcurrency, name) {
        this.taskType = taskType;
        this.maxConcurrency = maxConcurrency;
        this.name = name;
        this.id = (0, nanoid_1.nanoid)();
        this.canSendOffers = false;
        this.runningTasks = new Map();
        this.openOffers = new Map();
        this.dataRequests = new Map();
        this.rpcCalls = new Map();
        this.receiveMessage = (message) => {
            const data = JSON.parse(message.data);
            void this.onMessage(data);
        };
        this.stopTaskOffers = () => {
            this.canSendOffers = false;
            if (this.offerInterval) {
                clearInterval(this.offerInterval);
                this.offerInterval = undefined;
            }
        };
        const url = new node_url_1.URL(wsUrl);
        url.searchParams.append('id', this.id);
        this.ws = new ws_1.WebSocket(url.toString(), {
            headers: {
                authorization: `Bearer ${grantToken}`,
            },
        });
        this.ws.addEventListener('message', this.receiveMessage);
        this.ws.addEventListener('close', this.stopTaskOffers);
    }
    startTaskOffers() {
        this.canSendOffers = true;
        if (this.offerInterval) {
            clearInterval(this.offerInterval);
        }
        this.offerInterval = setInterval(() => this.sendOffers(), 250);
    }
    deleteStaleOffers() {
        this.openOffers.forEach((offer, key) => {
            if (offer.validUntil < process.hrtime.bigint()) {
                this.openOffers.delete(key);
            }
        });
    }
    sendOffers() {
        this.deleteStaleOffers();
        const offersToSend = this.maxConcurrency -
            (Object.values(this.openOffers).length + Object.values(this.runningTasks).length);
        for (let i = 0; i < offersToSend; i++) {
            const offer = {
                offerId: (0, nanoid_1.nanoid)(),
                validUntil: process.hrtime.bigint() + BigInt((VALID_TIME_MS + VALID_EXTRA_MS) * 1_000_000),
            };
            this.openOffers.set(offer.offerId, offer);
            this.send({
                type: 'runner:taskoffer',
                taskType: this.taskType,
                offerId: offer.offerId,
                validFor: VALID_TIME_MS,
            });
        }
    }
    send(message) {
        this.ws.send(JSON.stringify(message));
    }
    onMessage(message) {
        switch (message.type) {
            case 'broker:inforequest':
                this.send({
                    type: 'runner:info',
                    name: this.name ?? 'Node.js Task Runner SDK',
                    types: [this.taskType],
                });
                break;
            case 'broker:runnerregistered':
                this.startTaskOffers();
                break;
            case 'broker:taskofferaccept':
                this.offerAccepted(message.offerId, message.taskId);
                break;
            case 'broker:taskcancel':
                this.taskCancelled(message.taskId);
                break;
            case 'broker:tasksettings':
                void this.receivedSettings(message.taskId, message.settings);
                break;
            case 'broker:taskdataresponse':
                this.processDataResponse(message.requestId, message.data);
                break;
            case 'broker:rpcresponse':
                this.handleRpcResponse(message.callId, message.status, message.data);
        }
    }
    processDataResponse(requestId, data) {
        const request = this.dataRequests.get(requestId);
        if (!request) {
            return;
        }
        request.resolve(data);
    }
    hasOpenTasks() {
        return Object.values(this.runningTasks).length < this.maxConcurrency;
    }
    offerAccepted(offerId, taskId) {
        if (!this.hasOpenTasks()) {
            this.send({
                type: 'runner:taskrejected',
                taskId,
                reason: 'No open task slots',
            });
            return;
        }
        const offer = this.openOffers.get(offerId);
        if (!offer) {
            this.send({
                type: 'runner:taskrejected',
                taskId,
                reason: 'Offer expired and no open task slots',
            });
            return;
        }
        else {
            this.openOffers.delete(offerId);
        }
        this.runningTasks.set(taskId, {
            taskId,
            active: false,
            cancelled: false,
        });
        this.send({
            type: 'runner:taskaccepted',
            taskId,
        });
    }
    taskCancelled(taskId) {
        const task = this.runningTasks.get(taskId);
        if (!task) {
            return;
        }
        task.cancelled = true;
        if (task.active) {
        }
        else {
            this.runningTasks.delete(taskId);
        }
        this.sendOffers();
    }
    taskErrored(taskId, error) {
        this.send({
            type: 'runner:taskerror',
            taskId,
            error,
        });
        this.runningTasks.delete(taskId);
        this.sendOffers();
    }
    taskDone(taskId, data) {
        this.send({
            type: 'runner:taskdone',
            taskId,
            data,
        });
        this.runningTasks.delete(taskId);
        this.sendOffers();
    }
    async receivedSettings(taskId, settings) {
        const task = this.runningTasks.get(taskId);
        if (!task) {
            return;
        }
        if (task.cancelled) {
            this.runningTasks.delete(taskId);
            return;
        }
        task.settings = settings;
        task.active = true;
        try {
            const data = await this.executeTask(task);
            this.taskDone(taskId, data);
        }
        catch (error) {
            this.taskErrored(taskId, error);
        }
    }
    async executeTask(_task) {
        throw new n8n_workflow_1.ApplicationError('Unimplemented');
    }
    async requestData(taskId, type, param) {
        const requestId = (0, nanoid_1.nanoid)();
        const p = new Promise((resolve, reject) => {
            this.dataRequests.set(requestId, {
                requestId,
                resolve: resolve,
                reject,
            });
        });
        this.send({
            type: 'runner:taskdatarequest',
            taskId,
            requestId,
            requestType: type,
            param,
        });
        try {
            return await p;
        }
        finally {
            this.dataRequests.delete(requestId);
        }
    }
    async makeRpcCall(taskId, name, params) {
        const callId = (0, nanoid_1.nanoid)();
        const dataPromise = new Promise((resolve, reject) => {
            this.rpcCalls.set(callId, {
                callId,
                resolve,
                reject,
            });
        });
        this.send({
            type: 'runner:rpc',
            callId,
            taskId,
            name,
            params,
        });
        try {
            return await dataPromise;
        }
        finally {
            this.rpcCalls.delete(callId);
        }
    }
    handleRpcResponse(callId, status, data) {
        const call = this.rpcCalls.get(callId);
        if (!call) {
            return;
        }
        if (status === 'success') {
            call.resolve(data);
        }
        else {
            call.reject(typeof data === 'string' ? new Error(data) : data);
        }
    }
    buildRpcCallObject(taskId) {
        const rpcObject = {};
        for (const r of runner_types_1.RPC_ALLOW_LIST) {
            const splitPath = r.split('.');
            let obj = rpcObject;
            splitPath.forEach((s, index) => {
                if (index !== splitPath.length - 1) {
                    obj[s] = {};
                    obj = obj[s];
                    return;
                }
                obj[s] = async (...args) => await this.makeRpcCall(taskId, r, args);
            });
        }
        return rpcObject;
    }
    async stop() {
        this.stopTaskOffers();
        await this.waitUntilAllTasksAreDone();
        await this.closeConnection();
    }
    async closeConnection() {
        this.ws.close(1000, 'Shutting down');
        await new Promise((resolve) => {
            this.ws.once('close', resolve);
        });
    }
    async waitUntilAllTasksAreDone(maxWaitTimeInMs = 30_000) {
        const start = Date.now();
        while (this.runningTasks.size > 0) {
            if (Date.now() - start > maxWaitTimeInMs) {
                throw new n8n_workflow_1.ApplicationError('Timeout while waiting for tasks to finish');
            }
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
    }
}
exports.TaskRunner = TaskRunner;
//# sourceMappingURL=task-runner.js.map