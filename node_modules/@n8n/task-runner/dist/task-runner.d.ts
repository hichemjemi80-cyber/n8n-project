import { WebSocket } from 'ws';
import { type RunnerMessage, type N8nMessage, type TaskResultData } from './runner-types';
export interface Task<T = unknown> {
    taskId: string;
    settings?: T;
    active: boolean;
    cancelled: boolean;
}
export interface TaskOffer {
    offerId: string;
    validUntil: bigint;
}
interface DataRequest {
    requestId: string;
    resolve: (data: unknown) => void;
    reject: (error: unknown) => void;
}
interface RPCCall {
    callId: string;
    resolve: (data: unknown) => void;
    reject: (error: unknown) => void;
}
export interface RPCCallObject {
    [name: string]: ((...args: unknown[]) => Promise<unknown>) | RPCCallObject;
}
export declare abstract class TaskRunner {
    taskType: string;
    private maxConcurrency;
    name?: string | undefined;
    id: string;
    ws: WebSocket;
    canSendOffers: boolean;
    runningTasks: Map<Task['taskId'], Task>;
    offerInterval: NodeJS.Timeout | undefined;
    openOffers: Map<TaskOffer['offerId'], TaskOffer>;
    dataRequests: Map<DataRequest['requestId'], DataRequest>;
    rpcCalls: Map<RPCCall['callId'], RPCCall>;
    constructor(taskType: string, wsUrl: string, grantToken: string, maxConcurrency: number, name?: string | undefined);
    private receiveMessage;
    private stopTaskOffers;
    private startTaskOffers;
    deleteStaleOffers(): void;
    sendOffers(): void;
    send(message: RunnerMessage.ToN8n.All): void;
    onMessage(message: N8nMessage.ToRunner.All): void;
    processDataResponse(requestId: string, data: unknown): void;
    hasOpenTasks(): boolean;
    offerAccepted(offerId: string, taskId: string): void;
    taskCancelled(taskId: string): void;
    taskErrored(taskId: string, error: unknown): void;
    taskDone(taskId: string, data: RunnerMessage.ToN8n.TaskDone['data']): void;
    receivedSettings(taskId: string, settings: unknown): Promise<void>;
    executeTask(_task: Task): Promise<TaskResultData>;
    requestData<T = unknown>(taskId: Task['taskId'], type: RunnerMessage.ToN8n.TaskDataRequest['requestType'], param?: string): Promise<T>;
    makeRpcCall(taskId: string, name: RunnerMessage.ToN8n.RPC['name'], params: unknown[]): Promise<unknown>;
    handleRpcResponse(callId: string, status: N8nMessage.ToRunner.RPCResponse['status'], data: unknown): void;
    buildRpcCallObject(taskId: string): RPCCallObject;
    stop(): Promise<void>;
    private closeConnection;
    private waitUntilAllTasksAreDone;
}
export {};
