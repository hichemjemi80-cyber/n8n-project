"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConnectedTools = void 0;
exports.getMetadataFiltersValues = getMetadataFiltersValues;
exports.isBaseChatMemory = isBaseChatMemory;
exports.isBaseChatMessageHistory = isBaseChatMessageHistory;
exports.isChatInstance = isChatInstance;
exports.isToolsInstance = isToolsInstance;
exports.getOptionalOutputParsers = getOptionalOutputParsers;
exports.getPromptInputByType = getPromptInputByType;
exports.getSessionId = getSessionId;
exports.logAiEvent = logAiEvent;
exports.serializeChatHistory = serializeChatHistory;
const n8n_workflow_1 = require("n8n-workflow");
const N8nTool_1 = require("./N8nTool");
function hasMethods(obj, ...methodNames) {
    return methodNames.every((methodName) => typeof obj === 'object' &&
        obj !== null &&
        methodName in obj &&
        typeof obj[methodName] === 'function');
}
function getMetadataFiltersValues(ctx, itemIndex) {
    const options = ctx.getNodeParameter('options', itemIndex, {});
    if (options.metadata) {
        const { metadataValues: metadata } = options.metadata;
        if (metadata.length > 0) {
            return metadata.reduce((acc, { name, value }) => ({ ...acc, [name]: value }), {});
        }
    }
    if (options.searchFilterJson) {
        return ctx.getNodeParameter('options.searchFilterJson', itemIndex, '', {
            ensureType: 'object',
        });
    }
    return undefined;
}
function isBaseChatMemory(obj) {
    return hasMethods(obj, 'loadMemoryVariables', 'saveContext');
}
function isBaseChatMessageHistory(obj) {
    return hasMethods(obj, 'getMessages', 'addMessage');
}
function isChatInstance(model) {
    const namespace = model?.lc_namespace ?? [];
    return namespace.includes('chat_models');
}
function isToolsInstance(model) {
    const namespace = model?.lc_namespace ?? [];
    return namespace.includes('tools');
}
async function getOptionalOutputParsers(ctx) {
    let outputParsers = [];
    if (ctx.getNodeParameter('hasOutputParser', 0, true) === true) {
        outputParsers = (await ctx.getInputConnectionData("ai_outputParser", 0));
    }
    return outputParsers;
}
function getPromptInputByType(options) {
    const { ctx, i, promptTypeKey, inputKey } = options;
    const prompt = ctx.getNodeParameter(promptTypeKey, i);
    let input;
    if (prompt === 'auto') {
        input = ctx.evaluateExpression('{{ $json["chatInput"] }}', i);
    }
    else {
        input = ctx.getNodeParameter(inputKey, i);
    }
    if (input === undefined) {
        throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No prompt specified', {
            description: "Expected to find the prompt in an input field called 'chatInput' (this is what the chat trigger node outputs). To use something else, change the 'Prompt' parameter",
        });
    }
    return input;
}
function getSessionId(ctx, itemIndex, selectorKey = 'sessionIdType', autoSelect = 'fromInput', customKey = 'sessionKey') {
    let sessionId = '';
    const selectorType = ctx.getNodeParameter(selectorKey, itemIndex);
    if (selectorType === autoSelect) {
        if ('getBodyData' in ctx) {
            const bodyData = ctx.getBodyData() ?? {};
            sessionId = bodyData.sessionId;
        }
        else {
            sessionId = ctx.evaluateExpression('{{ $json.sessionId }}', itemIndex);
        }
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'No session ID found', {
                description: "Expected to find the session ID in an input field called 'sessionId' (this is what the chat trigger node outputs). To use something else, change the 'Session ID' parameter",
                itemIndex,
            });
        }
    }
    else {
        sessionId = ctx.getNodeParameter(customKey, itemIndex, '');
        if (sessionId === '' || sessionId === undefined) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), 'Key parameter is empty', {
                description: "Provide a key to use as session ID in the 'Key' parameter or use the 'Take from previous node automatically' option to use the session ID from the previous node, e.t. chat trigger node",
                itemIndex,
            });
        }
    }
    return sessionId;
}
async function logAiEvent(executeFunctions, event, data) {
    try {
        await executeFunctions.logAiEvent(event, data ? (0, n8n_workflow_1.jsonStringify)(data) : undefined);
    }
    catch (error) {
        executeFunctions.logger.debug(`Error logging AI event: ${event}`);
    }
}
function serializeChatHistory(chatHistory) {
    return chatHistory
        .map((chatMessage) => {
        if (chatMessage._getType() === 'human') {
            return `Human: ${chatMessage.content}`;
        }
        else if (chatMessage._getType() === 'ai') {
            return `Assistant: ${chatMessage.content}`;
        }
        else {
            return `${chatMessage.content}`;
        }
    })
        .join('\n');
}
const getConnectedTools = async (ctx, enforceUniqueNames, convertStructuredTool = true) => {
    const connectedTools = (await ctx.getInputConnectionData("ai_tool", 0)) || [];
    if (!enforceUniqueNames)
        return connectedTools;
    const seenNames = new Set();
    const finalTools = [];
    for (const tool of connectedTools) {
        const { name } = tool;
        if (seenNames.has(name)) {
            throw new n8n_workflow_1.NodeOperationError(ctx.getNode(), `You have multiple tools with the same name: '${name}', please rename them to avoid conflicts`);
        }
        seenNames.add(name);
        if (convertStructuredTool && tool instanceof N8nTool_1.N8nTool) {
            finalTools.push(tool.asDynamicTool());
        }
        else {
            finalTools.push(tool);
        }
    }
    return finalTools;
};
exports.getConnectedTools = getConnectedTools;
//# sourceMappingURL=helpers.js.map