"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toolsAgentExecute = toolsAgentExecute;
const messages_1 = require("@langchain/core/messages");
const prompts_1 = require("@langchain/core/prompts");
const runnables_1 = require("@langchain/core/runnables");
const tools_1 = require("@langchain/core/tools");
const agents_1 = require("langchain/agents");
const output_parsers_1 = require("langchain/output_parsers");
const lodash_1 = require("lodash");
const n8n_workflow_1 = require("n8n-workflow");
const zod_1 = require("zod");
const prompt_1 = require("./prompt");
const helpers_1 = require("../../../../../utils/helpers");
function getOutputParserSchema(outputParser) {
    const parserType = outputParser.lc_namespace[outputParser.lc_namespace.length - 1];
    let schema;
    if (parserType === 'structured') {
        schema = outputParser.schema;
    }
    else if (parserType === 'fix' && outputParser instanceof output_parsers_1.OutputFixingParser) {
        schema = outputParser.parser.schema;
    }
    else {
        schema = zod_1.z.object({ text: zod_1.z.string() });
    }
    return schema;
}
async function extractBinaryMessages(ctx) {
    const binaryData = ctx.getInputData(0, 'main')?.[0]?.binary ?? {};
    const binaryMessages = await Promise.all(Object.values(binaryData)
        .filter((data) => data.mimeType.startsWith('image/'))
        .map(async (data) => {
        let binaryUrlString;
        if (data.id) {
            const binaryBuffer = await ctx.helpers.binaryToBuffer(await ctx.helpers.getBinaryStream(data.id));
            binaryUrlString = `data:${data.mimeType};base64,${Buffer.from(binaryBuffer).toString(n8n_workflow_1.BINARY_ENCODING)}`;
        }
        else {
            binaryUrlString = data.data.includes('base64')
                ? data.data
                : `data:${data.mimeType};base64,${data.data}`;
        }
        return {
            type: 'image_url',
            image_url: {
                url: binaryUrlString,
            },
        };
    }));
    return new messages_1.HumanMessage({
        content: [...binaryMessages],
    });
}
function fixEmptyContentMessage(steps) {
    if (!Array.isArray(steps))
        return steps;
    steps.forEach((step) => {
        if ('messageLog' in step && step.messageLog !== undefined) {
            if (Array.isArray(step.messageLog)) {
                step.messageLog.forEach((message) => {
                    if ('content' in message && Array.isArray(message.content)) {
                        message.content.forEach((content) => {
                            if (content.input === '') {
                                content.input = {};
                            }
                        });
                    }
                });
            }
        }
    });
    return steps;
}
async function toolsAgentExecute() {
    this.logger.debug('Executing Tools Agent');
    const model = await this.getInputConnectionData("ai_languageModel", 0);
    if (!(0, helpers_1.isChatInstance)(model) || !model.bindTools) {
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Tools Agent requires Chat Model which supports Tools calling');
    }
    const memory = (await this.getInputConnectionData("ai_memory", 0));
    const tools = (await (0, helpers_1.getConnectedTools)(this, true, false));
    const outputParser = (await (0, helpers_1.getOptionalOutputParsers)(this))?.[0];
    let structuredOutputParserTool;
    function handleAgentFinishOutput(steps) {
        const agentFinishSteps = steps;
        if (agentFinishSteps.returnValues) {
            const isMultiOutput = Array.isArray(agentFinishSteps.returnValues?.output);
            if (isMultiOutput) {
                const multiOutputSteps = agentFinishSteps.returnValues.output;
                const isTextOnly = (multiOutputSteps ?? []).every((output) => 'text' in output);
                if (isTextOnly) {
                    agentFinishSteps.returnValues.output = multiOutputSteps
                        .map((output) => output.text)
                        .join('\n')
                        .trim();
                }
                return agentFinishSteps;
            }
        }
        return agentFinishSteps;
    }
    function handleParsedStepOutput(output) {
        return {
            returnValues: memory ? { output: JSON.stringify(output) } : output,
            log: 'Final response formatted',
        };
    }
    async function agentStepsParser(steps) {
        if (Array.isArray(steps)) {
            const responseParserTool = steps.find((step) => step.tool === 'format_final_response');
            if (responseParserTool) {
                const toolInput = responseParserTool?.toolInput;
                const returnValues = (await outputParser.parse(toolInput));
                return handleParsedStepOutput(returnValues);
            }
        }
        if (outputParser && typeof steps === 'object' && steps.returnValues) {
            const finalResponse = steps.returnValues;
            const returnValues = (await outputParser.parse(finalResponse));
            return handleParsedStepOutput(returnValues);
        }
        return handleAgentFinishOutput(steps);
    }
    if (outputParser) {
        const schema = getOutputParserSchema(outputParser);
        structuredOutputParserTool = new tools_1.DynamicStructuredTool({
            schema,
            name: 'format_final_response',
            description: 'Always use this tool for the final output to the user. It validates the output so only use it when you are sure the output is final.',
            func: async () => '',
        });
        tools.push(structuredOutputParserTool);
    }
    const options = this.getNodeParameter('options', 0, {});
    const passthroughBinaryImages = this.getNodeParameter('options.passthroughBinaryImages', 0, true);
    const messages = [
        ['system', `{system_message}${outputParser ? '\n\n{formatting_instructions}' : ''}`],
        ['placeholder', '{chat_history}'],
        ['human', '{input}'],
        ['placeholder', '{agent_scratchpad}'],
    ];
    const hasBinaryData = this.getInputData(0, 'main')?.[0]?.binary !== undefined;
    if (hasBinaryData && passthroughBinaryImages) {
        const binaryMessage = await extractBinaryMessages(this);
        messages.push(binaryMessage);
    }
    const prompt = prompts_1.ChatPromptTemplate.fromMessages(messages);
    const agent = (0, agents_1.createToolCallingAgent)({
        llm: model,
        tools,
        prompt,
        streamRunnable: false,
    });
    agent.streamRunnable = false;
    const runnableAgent = runnables_1.RunnableSequence.from([agent, agentStepsParser, fixEmptyContentMessage]);
    const executor = agents_1.AgentExecutor.fromAgentAndTools({
        agent: runnableAgent,
        memory,
        tools,
        returnIntermediateSteps: options.returnIntermediateSteps === true,
        maxIterations: options.maxIterations ?? 10,
    });
    const returnData = [];
    const items = this.getInputData();
    for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
        try {
            const input = (0, helpers_1.getPromptInputByType)({
                ctx: this,
                i: itemIndex,
                inputKey: 'text',
                promptTypeKey: 'promptType',
            });
            if (input === undefined) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'The ‘text‘ parameter is empty.');
            }
            if (model.lc_namespace.includes('openai') && tools.length === 0) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), "Please connect at least one tool. If you don't need any, try the conversational agent instead");
            }
            const response = await executor.invoke({
                input,
                system_message: options.systemMessage ?? prompt_1.SYSTEM_MESSAGE,
                formatting_instructions: 'IMPORTANT: Always call `format_final_response` to format your final response!',
            });
            if (memory && outputParser) {
                const parsedOutput = (0, n8n_workflow_1.jsonParse)(response.output);
                response.output = parsedOutput?.output ?? parsedOutput;
            }
            returnData.push({
                json: (0, lodash_1.omit)(response, 'system_message', 'formatting_instructions', 'input', 'chat_history', 'agent_scratchpad'),
            });
        }
        catch (error) {
            if (this.continueOnFail()) {
                returnData.push({
                    json: { error: error.message },
                    pairedItem: { item: itemIndex },
                });
                continue;
            }
            throw error;
        }
    }
    return [returnData];
}
//# sourceMappingURL=execute.js.map