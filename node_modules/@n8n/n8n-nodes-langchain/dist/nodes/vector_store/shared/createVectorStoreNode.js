"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVectorStoreNode = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const logWrapper_1 = require("../../../utils/logWrapper");
const N8nJsonLoader_1 = require("../../../utils/N8nJsonLoader");
const helpers_1 = require("../../../utils/helpers");
const sharedFields_1 = require("../../../utils/sharedFields");
const processDocuments_1 = require("./processDocuments");
const DEFAULT_OPERATION_MODES = ['load', 'insert', 'retrieve'];
function transformDescriptionForOperationMode(fields, mode) {
    return fields.map((field) => ({
        ...field,
        displayOptions: { show: { mode: [mode] } },
    }));
}
function isUpdateSupported(args) {
    return args.meta.operationModes?.includes('update') ?? false;
}
function getOperationModeOptions(args) {
    const enabledOperationModes = args.meta.operationModes ?? DEFAULT_OPERATION_MODES;
    const allOptions = [
        {
            name: 'Get Many',
            value: 'load',
            description: 'Get many ranked documents from vector store for query',
            action: 'Get ranked documents from vector store',
        },
        {
            name: 'Insert Documents',
            value: 'insert',
            description: 'Insert documents into vector store',
            action: 'Add documents to vector store',
        },
        {
            name: 'Retrieve Documents (For Agent/Chain)',
            value: 'retrieve',
            description: 'Retrieve documents from vector store to be used with AI nodes',
            action: 'Retrieve documents for AI processing',
        },
        {
            name: 'Update Documents',
            value: 'update',
            description: 'Update documents in vector store by ID',
            action: 'Update vector store documents',
        },
    ];
    return allOptions.filter(({ value }) => enabledOperationModes.includes(value));
}
const createVectorStoreNode = (args) => class VectorStoreNodeType {
    constructor() {
        this.description = {
            displayName: args.meta.displayName,
            name: args.meta.name,
            description: args.meta.description,
            icon: args.meta.icon,
            group: ['transform'],
            version: 1,
            defaults: {
                name: args.meta.displayName,
            },
            codex: {
                categories: ['AI'],
                subcategories: {
                    AI: ['Vector Stores', 'Root Nodes'],
                },
                resources: {
                    primaryDocumentation: [
                        {
                            url: args.meta.docsUrl,
                        },
                    ],
                },
            },
            credentials: args.meta.credentials,
            inputs: `={{
			((parameters) => {
				const mode = parameters?.mode;
				const inputs = [{ displayName: "Embedding", type: "${"ai_embedding"}", required: true, maxConnections: 1}]

				if (['insert', 'load', 'update'].includes(mode)) {
					inputs.push({ displayName: "", type: "${"main"}"})
				}

				if (['insert'].includes(mode)) {
					inputs.push({ displayName: "Document", type: "${"ai_document"}", required: true, maxConnections: 1})
				}
				return inputs
			})($parameter)
		}}`,
            outputs: `={{
			((parameters) => {
				const mode = parameters?.mode ?? 'retrieve';
				if (mode === 'retrieve') {
					return [{ displayName: "Vector Store", type: "${"ai_vectorStore"}"}]
				}
				return [{ displayName: "", type: "${"main"}"}]
			})($parameter)
		}}`,
            properties: [
                {
                    displayName: 'Operation Mode',
                    name: 'mode',
                    type: 'options',
                    noDataExpression: true,
                    default: 'retrieve',
                    options: getOperationModeOptions(args),
                },
                {
                    ...(0, sharedFields_1.getConnectionHintNoticeField)(["ai_retriever"]),
                    displayOptions: {
                        show: {
                            mode: ['retrieve'],
                        },
                    },
                },
                ...args.sharedFields,
                ...transformDescriptionForOperationMode(args.insertFields ?? [], 'insert'),
                {
                    displayName: 'Prompt',
                    name: 'prompt',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'Search prompt to retrieve matching documents from the vector store using similarity-based ranking',
                    displayOptions: {
                        show: {
                            mode: ['load'],
                        },
                    },
                },
                {
                    displayName: 'Limit',
                    name: 'topK',
                    type: 'number',
                    default: 4,
                    description: 'Number of top results to fetch from vector store',
                    displayOptions: {
                        show: {
                            mode: ['load'],
                        },
                    },
                },
                {
                    displayName: 'ID',
                    name: 'id',
                    type: 'string',
                    default: '',
                    required: true,
                    description: 'ID of an embedding entry',
                    displayOptions: {
                        show: {
                            mode: ['update'],
                        },
                    },
                },
                ...transformDescriptionForOperationMode(args.loadFields ?? [], 'load'),
                ...transformDescriptionForOperationMode(args.retrieveFields ?? [], 'retrieve'),
                ...transformDescriptionForOperationMode(args.updateFields ?? [], 'update'),
            ],
        };
        this.methods = args.methods;
    }
    async execute() {
        const mode = this.getNodeParameter('mode', 0);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'load') {
            const items = this.getInputData(0);
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
                const vectorStore = await args.getVectorStoreClient(this, undefined, embeddings, itemIndex);
                const prompt = this.getNodeParameter('prompt', itemIndex);
                const topK = this.getNodeParameter('topK', itemIndex, 4);
                const embeddedPrompt = await embeddings.embedQuery(prompt);
                const docs = await vectorStore.similaritySearchVectorWithScore(embeddedPrompt, topK, filter);
                const serializedDocs = docs.map(([doc, score]) => {
                    const document = {
                        metadata: doc.metadata,
                        pageContent: doc.pageContent,
                    };
                    return {
                        json: { document, score },
                        pairedItem: {
                            item: itemIndex,
                        },
                    };
                });
                resultData.push(...serializedDocs);
                void (0, helpers_1.logAiEvent)(this, 'ai-vector-store-searched', { query: prompt });
            }
            return [resultData];
        }
        if (mode === 'insert') {
            const items = this.getInputData();
            const documentInput = (await this.getInputConnectionData("ai_document", 0));
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const itemData = items[itemIndex];
                const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(documentInput, itemData, itemIndex);
                resultData.push(...serializedDocuments);
                try {
                    await args.populateVectorStore(this, embeddings, processedDocuments, itemIndex);
                    void (0, helpers_1.logAiEvent)(this, 'ai-vector-store-populated');
                }
                catch (error) {
                    throw error;
                }
            }
            return [resultData];
        }
        if (mode === 'update') {
            if (!isUpdateSupported(args)) {
                throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Update operation is not implemented for this Vector Store');
            }
            const items = this.getInputData();
            const loader = new N8nJsonLoader_1.N8nJsonLoader(this);
            const resultData = [];
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                const itemData = items[itemIndex];
                const documentId = this.getNodeParameter('id', itemIndex, '', {
                    extractValue: true,
                });
                const vectorStore = await args.getVectorStoreClient(this, undefined, embeddings, itemIndex);
                const { processedDocuments, serializedDocuments } = await (0, processDocuments_1.processDocument)(loader, itemData, itemIndex);
                if (processedDocuments?.length !== 1) {
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Single document per item expected');
                }
                resultData.push(...serializedDocuments);
                try {
                    await vectorStore.addDocuments(processedDocuments, {
                        ids: [documentId],
                    });
                    void (0, helpers_1.logAiEvent)(this, 'ai-vector-store-updated');
                }
                catch (error) {
                    throw error;
                }
            }
            return [resultData];
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "load" and "insert" operation modes are supported with execute');
    }
    async supplyData(itemIndex) {
        const mode = this.getNodeParameter('mode', 0);
        const filter = (0, helpers_1.getMetadataFiltersValues)(this, itemIndex);
        const embeddings = (await this.getInputConnectionData("ai_embedding", 0));
        if (mode === 'retrieve') {
            const vectorStore = await args.getVectorStoreClient(this, filter, embeddings, itemIndex);
            return {
                response: (0, logWrapper_1.logWrapper)(vectorStore, this),
            };
        }
        throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Only the "retrieve" operation mode is supported to supply data');
    }
};
exports.createVectorStoreNode = createVectorStoreNode;
//# sourceMappingURL=createVectorStoreNode.js.map